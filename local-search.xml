<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/29/hello-world/"/>
    <url>/2022/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP-进程调度方法</title>
    <link href="/2022/03/28/ostep-homework-4/"/>
    <url>/2022/03/28/ostep-homework-4/</url>
    
    <content type="html"><![CDATA[<h2 id="第七章：进程调度-x2F-介绍"><a href="#第七章：进程调度-x2F-介绍" class="headerlink" title="第七章：进程调度&#x2F;介绍"></a>第七章：进程调度&#x2F;介绍</h2><blockquote><p>参数介绍：</p><p>Response：响应时间，即任务第一次运行的时间</p><p>Turnaround: 完成时刻（周转时间），即任务完成那一刻对应的时间</p><p>Wait: 等待中时间，即任务处于Ready状态，但当前CPU在执行其他任务的等待时间</p></blockquote><ol><li><p>执行结果如下</p><p>FIFO:</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">ARG policy FIFO<br>ARG jlist 200,200,200<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 200.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 200.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 0 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 200.00 )<br>[ time 200 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 400.00 )<br>[ time 400 ] Run job 2 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 200.00  Wait 0.00<br>Job   1 -- Response: 200.00  Turnaround 400.00  Wait 200.00<br>Job   2 -- Response: 400.00  Turnaround 600.00  Wait 400.00<br><br>Average -- Response: 200.00  Turnaround 400.00  Wait 200.00<br></code></pre></td></tr></table></figure><p>同时，对于SJF<code>(Short Job First)</code>，由于每个任务的执行时间相同，所以策略上的处理结果和<code>FIFO</code>相同，不额外列出</p></li><li><p>在按照<code>300</code>,<code>200</code>和<code>100</code>的顺序一次执行任务的时候，对于FIFO策略依次执行，而依据SJF策略，则会先执行时间短的<code>100</code>，依次到最常的<code>300</code>。具体结果如下</p><p> FIFO</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy FIFO<br>ARG jlist 300,200,100<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 300.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 100.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 0 <span class="hljs-keyword">for</span> 300.00 secs ( DONE at 300.00 )<br>[ time 300 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 500.00 )<br>[ time 500 ] Run job 2 <span class="hljs-keyword">for</span> 100.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 300.00  Wait 0.00<br>Job   1 -- Response: 300.00  Turnaround 500.00  Wait 300.00<br>Job   2 -- Response: 500.00  Turnaround 600.00  Wait 500.00<br><br>Average -- Response: 266.67  Turnaround 466.67  Wait 266.67<br></code></pre></td></tr></table></figure><p> SJF</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy SJF<br>ARG jlist 300,200,100<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 300.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 100.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 2 <span class="hljs-keyword">for</span> 100.00 secs ( DONE at 100.00 )<br>[ time 100 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 300.00 )<br>[ time 300 ] Run job 0 <span class="hljs-keyword">for</span> 300.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   2 -- Response: 0.00  Turnaround 100.00  Wait 0.00<br>Job   1 -- Response: 100.00  Turnaround 300.00  Wait 100.00<br>Job   0 -- Response: 300.00  Turnaround 600.00  Wait 300.00<br><br>Average -- Response: 133.33  Turnaround 333.33  Wait 133.33<br></code></pre></td></tr></table></figure><p> SJF的好处在于可以先执行时间短的程序，后执行时间长的程序，同时优化了程序的响应、完成和等待时间。缺点在于因为必须先完整的运行某个任务，后执行下一个任务。如果此时需要高频率执行某任务则无能为力（比如高频率的io输出）</p></li><li><p>采用RR策略，时间片设置为1，依次执行<code>10</code>、<code>20</code>和<code>30</code>有</p><p>RR</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy RR<br>ARG jlist 10,20,30<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 10.0 )<br>Job 1 ( length = 20.0 )<br>Job 2 ( length = 30.0 )<br><br><br>** Solutions **<br><br>Execution trace:<br>[ time   0 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   1 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   2 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   3 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   4 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   5 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   6 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   7 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   8 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   9 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  10 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  11 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  12 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  13 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  14 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  15 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  16 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  17 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  18 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  19 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  20 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  21 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  22 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  23 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  24 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  25 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  26 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  27 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 28.00 )<br>[ time  28 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  29 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  30 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  31 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  32 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  33 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  34 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  35 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  36 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  37 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  38 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  39 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  40 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  41 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  42 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  43 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  44 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  45 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  46 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  47 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  48 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 49.00 )<br>[ time  49 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  50 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  51 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  52 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  53 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  54 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  55 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  56 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  57 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  58 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  59 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 60.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 28.00  Wait 18.00<br>Job   1 -- Response: 1.00  Turnaround 49.00  Wait 29.00<br>Job   2 -- Response: 2.00  Turnaround 60.00  Wait 30.00<br><br>Average -- Response: 1.00  Turnaround 45.67  Wait 25.67<br></code></pre></td></tr></table></figure><p>采用<code>RR</code>策略的时候通过轮转运行三个程序，达到类似”同时”运行程序的效果，缩短了任务的反应时间。缺点是由于轮询过程会同时运行其他任务，因此总体的完成时刻和等待时间都会延长。</p></li><li><p>由于SJF是“短任务优先”的调度策略，因此当到达的任务顺序为先短时间的任务，后长时间任务的时候，SJF和FIFO的周转时间是相同的</p></li><li><p>当RR策略的量子时间大于等于SJF的单个任务最长工作时间时，SJF和RR可以提供相同的响应时间</p></li><li><p>当工作长度逐渐增加的时候，SJF的响应时间会逐渐增加，因为SJF必须要完成一个完整的任务才会运行下一个任务，因此后面的任务响应时间必须等待前一个任务的完成，模拟省略。</p></li><li><p>假定所有任务的长度都大于量子长度，且完成任务的时间都为量子长度的倍数，则可推得以下公式</p><p>$\displaystyle \sum^{N}<em>{i &#x3D; 1}{iQ} \over {N}$ &#x3D; $\displaystyle Q \sum^{N}</em>{i &#x3D; 1}{i} \over {N}$ &#x3D; $\displaystyle \frac{Q * \frac{N(N+1)}{2}}{N}$ &#x3D; $\displaystyle \frac{Q (N+1)}{2}$</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP-上下文切换开销</title>
    <link href="/2022/03/25/ostep-homework-3/"/>
    <url>/2022/03/25/ostep-homework-3/</url>
    
    <content type="html"><![CDATA[<h2 id="第六章：受限制直接执行-x2F-上下文切换"><a href="#第六章：受限制直接执行-x2F-上下文切换" class="headerlink" title="第六章：受限制直接执行&#x2F;上下文切换"></a>第六章：受限制直接执行&#x2F;上下文切换</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>由于该实验要求在单个CPU上运行两个进程并在他们两个UNIX管道，而书中介绍的<code>sche_affinity()</code>函数的具体调用不是很清楚，所以这里通过<code>Docker</code>的参数限制，创建了一个只使用宿主机一个CPU资源的容器进行实验。</p><p>单核<code>Docker</code>容器的创建</p><figure class="highlight docker"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -it -d --cpuset-cpus=<span class="hljs-string">&quot;0&quot;</span> --name=os ubuntu:latest</span><br></code></pre></td></tr></table></figure><blockquote><p>注：在以上环境中如果使用函数查询CPU核心数依旧可以发现为<code>16</code>或其他多核，但是在通过指令<code>stress -c 4</code>实际测试后，性能只会在宿主机的单一CPU核心上运行，不影响实验。但是如果在创建<code>Docker</code>容器的时候使用的是<code>--cpus=1</code>，由于负载均衡，并不能达到单核进行实验的目的。</p></blockquote><h3 id="测量思路"><a href="#测量思路" class="headerlink" title="测量思路"></a>测量思路</h3><ol><li><p>通过<code>gettimeofday()</code>增加时间戳函数，获取执行时间</p></li><li><p>创建10个管道，循环5次，每次循环的时候分别在两个管道之间反复通信，并输出上下文切换时间差</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-comment">// 标记时间戳</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">getTimeTick</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>;</span><br>    gettimeofday(&amp;tv, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> tv.tv_usec;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建十个管道用于读写测试</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">10</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(fd[i]) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">char</span> timeWrite[<span class="hljs-number">256</span>], timeRead[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">switch</span> (rc)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <span class="hljs-comment">// error</span><br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-comment">// 从管道一中读取数据，如果管道一中没有数据，则阻塞等待</span><br>            read(fd[i][<span class="hljs-number">0</span>], timeRead, <span class="hljs-keyword">sizeof</span>(timeRead));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read - Write %d: %lu\n&quot;</span>, i, getTimeTick() - atol(timeRead));<br>            <span class="hljs-comment">// 将时间写入管道二</span><br>            <span class="hljs-built_in">sprintf</span>(timeWrite, <span class="hljs-string">&quot;%lu&quot;</span>, getTimeTick());<br>            write(fd[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], timeWrite, <span class="hljs-keyword">sizeof</span>(timeWrite));<br>            <span class="hljs-comment">// 从管道一中读取数据，并计算进程切换的总时间</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 将时间写入管道一</span><br>            <span class="hljs-built_in">sprintf</span>(timeWrite, <span class="hljs-string">&quot;%lu&quot;</span>, getTimeTick());<br>            write(fd[i][<span class="hljs-number">1</span>], timeWrite, <span class="hljs-keyword">sizeof</span>(timeWrite));<br>            <span class="hljs-comment">// 由于在执行完write之后会继续执行主进程，下方的read也会运行，因此最后结果中奇数进程的结果时间会比偶数进程的时间长，正确答案应该靠近偶数</span><br>            <span class="hljs-comment">// 从管道二读取数据，如果管道二中没有数据，则阻塞等待</span><br>            read(fd[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], timeRead, <span class="hljs-keyword">sizeof</span>(timeRead));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read - Write %d: %lu\n&quot;</span>, i + <span class="hljs-number">1</span>, getTimeTick() - atol(timeRead));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测量结果"><a href="#测量结果" class="headerlink" title="测量结果"></a>测量结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Read - Write 0: 24<br>Read - Write 1: 7<br>Read - Write 2: 16<br>Read - Write 3: 6<br>Read - Write 4: 17<br>Read - Write 5: 7<br>Read - Write 6: 17<br>Read - Write 7: 6<br>Read - Write 8: 18<br>Read - Write 9: 9<br></code></pre></td></tr></table></figure><h3 id="结果差错"><a href="#结果差错" class="headerlink" title="结果差错"></a>结果差错</h3><p>由于在执行完write之后会继续执行主进程，下方的read也会运行，因此最后结果中奇数进程的结果时间会比偶数进程的时间长，正确答案应该靠近偶数（已经在代码中用注释写明）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP-进程API</title>
    <link href="/2022/03/23/ostep-homework-2/"/>
    <url>/2022/03/23/ostep-homework-2/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章：进程API"><a href="#第五章：进程API" class="headerlink" title="第五章：进程API"></a>第五章：进程API</h2><ol><li><p>子进程和父进程的变量<code>x</code>的值内容相互独立。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// child process</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child: %d\n&quot;</span>, x);<br>        <span class="hljs-comment">// 子进程变量增加100</span><br>        x += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child + 100: %d\n&quot;</span>, x);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 父进程在子进程执行完毕后执行</span><br>        <span class="hljs-type">int</span> wc = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// parent process</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent: %d\n&quot;</span>, x);<br>        <span class="hljs-comment">// 父进程变量增加100</span><br>        x += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent + 100: %d\n&quot;</span>, x);<br>    &#125;<br>    <span class="hljs-comment">// 分别再次输入最后的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Final Address: %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 测试结果如下：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">Child: 100<br>Child + 100: 200<br>Final Address: 200<br>Parent: 100<br>Parent + 100: 200<br>Final Address: 200<br></code></pre></td></tr></table></figure></li><li><p>同时打开文件<code>p4.output</code>并且分别写入<code>Child process</code>和<code>Parent Process</code>，可以正常并发写入。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// close stdout and open output file</span><br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0700</span>);<br><br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 结果（p4.output文件）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Child process<br>Parent process<br></code></pre></td></tr></table></figure><p> 或（并发输出的先后顺序不同）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Parent process<br>Child process<br></code></pre></td></tr></table></figure></li><li><p>题目要求的是在不适用<code>wait()</code>函数下实现子进程和父进程的先后，通过<code>vfork()</code>函数可以实现</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// close stdout and open output file</span><br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0700</span>);<br>    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">vfork</span>();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 数据结果可以参考题目2的第一个情况。不过这里插入<a href="https://stackoverflow.com/a/50005978">Stack Overflow</a>上书原作者的话作为备注：</p><blockquote><p>Without calling wait() is hard, and not really the main point. What you did – learning about signals on your own – is a good sign, showing you will seek out deeper knowledge. Good for you!</p><p>Later, you’ll be able to use a shared memory segment, and either condition variables or semaphores, to solve this problem.</p></blockquote></li><li><p>针对不同的调用和变种，写了一篇详细的博客进行解析：<a href="2022-3-19-exec-in-cpp.md">区分不同exec()形式</a></p></li><li><p>在父进程使用<code>wait()</code>，等待子进程完成后，<code>wait()</code>会返回子进程的<code>pid</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fork failed&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Return Value of wait() is %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 运行结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">I am child process 4878<br>I am parent process 4873<br>Return Value of <span class="hljs-built_in">wait</span>() is 4878<br></code></pre></td></tr></table></figure><p> 在子进程中使用wait()则会返回<code>-1</code>，并且在失败后依旧会执行当前子进程</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fork failed&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> fake_ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fake_ws = %d\n&quot;</span>, fake_ws);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Return Value of wait() is %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 运行结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">I am child process 5011<br>fake_ws = -1<br>Test<br>I am parent process 5006<br>Return Value of <span class="hljs-built_in">wait</span>() is 5011<br></code></pre></td></tr></table></figure></li><li><p>针对<code>waitpid()</code>的使用，总结了笔记：<a href="2022-3-23-wait-in-linux.md">waitpid()调用</a></p></li><li><p>子进程中关闭标准输出，父进程输出子进程和本身<code>pid</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from child\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent, child exited with status %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 运行结果，子进程中的输出被关闭，只有父进程输出。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello from parent, child exited with status 1326<br></code></pre></td></tr></table></figure></li><li><p>通过pipe()管道进行传输数据</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 创建两个文件标示符</span><br>    <span class="hljs-type">int</span> rc_pipe = <span class="hljs-built_in">pipe</span>(fd); <span class="hljs-comment">// 创建管道</span><br><br>    <span class="hljs-type">char</span> msg[] = <span class="hljs-string">&quot;Hello_World!&quot;</span>; <span class="hljs-comment">// 用于输出的字符串</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">100</span>];              <span class="hljs-comment">// 用于输出的缓冲区</span><br><br>    <span class="hljs-type">int</span> rc_1 = fork(); <span class="hljs-comment">// 创建第一个进程</span><br><br>    <span class="hljs-keyword">if</span> (rc_1 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process 1: %d\n&quot;</span>, i);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);               <span class="hljs-comment">// 为防止文件读写出现问题，关闭读取端，只允许写入</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>], STDOUT_FILENO); <span class="hljs-comment">// 将标准输出重定向到管道的写入端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg);          <span class="hljs-comment">// 输出字符串到标准输出，然后重定向至管道的写入端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);               <span class="hljs-comment">// 关闭管道的写入端</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                    <span class="hljs-comment">// 结束当前进程</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> rc_2 = fork();<br><br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 即使通过sleep()让第二个进程等待，由于第一个进程的输入管道没有内容，所以第二个进程的scanf会等待至第一个进程将数据写入缓冲区</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process 2: %d\n&quot;</span>, i);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);              <span class="hljs-comment">// 为防止文件读写出现问题，关闭写入端，只允许读取</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], STDIN_FILENO); <span class="hljs-comment">// 将标准输入重定向到管道的读取端</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buff);         <span class="hljs-comment">// 从标准输入读取字符串，然后重定向至管道的读取端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);              <span class="hljs-comment">// 关闭管道的读取端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buff);        <span class="hljs-comment">// 输出由管道传输的字符串</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                   <span class="hljs-comment">// 结束当前进程</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 输出结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Child Process 1: 0<br>Child Process 2: 0<br>Child Process 2: 1<br>Child Process 1: 1<br>Child Process 2: 2<br>Child Process 1: 2<br>Child Process 1: 3  <span class="hljs-comment"># 从这个时候开始，rc_2在等待rc_1通过管道传入&quot;Hello World!&quot;</span><br>Child Process 1: 4<br>Hello_World!        <span class="hljs-comment"># rc_2通过管道读取到了内容，进行输出</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wait()和waitpid()调用</title>
    <link href="/2022/03/23/wait-in-linux/"/>
    <url>/2022/03/23/wait-in-linux/</url>
    
    <content type="html"><![CDATA[<p>在写完<code>OSTEP</code>第五章课后习题之后，通过第八题的答案记录一下自己目前对<code>waitpid()</code>的尝试结果，目前的尝试仅限于进程执行的阻塞和等待，轮询和非阻塞的状态暂时没有遇到，日后补充。</p><h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><p><code>waitpid()</code>不能用于子进程等待更早的另外一个子进程，如果尝试运行则会返回<code>-1</code>。（在父进程中则等待并返回子进程对应的<code>pid</code>)</p><p>这里举例说明，以下为一个不包含任何<code>waitpid()</code>的原始代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建第一个子进程</span><br>    <span class="hljs-type">int</span> rc_1 = fork(); <br>    <span class="hljs-keyword">if</span> (rc_1 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建第二个子进程</span><br>    <span class="hljs-type">int</span> rc_2 = fork();<br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码通过<code>waitpid()</code>函数可以实现在<code>rc_1</code>和<code>rc_2</code>都执行完毕之后，再执行主进程的内容，修改如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建第一个子进程</span><br>    <span class="hljs-type">int</span> rc_1 = fork();<br>    ...<br><br>    <span class="hljs-comment">// 创建第二个子进程</span><br>    <span class="hljs-type">int</span> rc_2 = fork();<br>    ...<br><br>    <span class="hljs-built_in">waitpid</span>(rc_1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待第一个进程(pid为rc_1的进程)结束</span><br>    <span class="hljs-built_in">waitpid</span>(rc_2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待第二个进程(pid为rc_2的进程)结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在子进程中调用<code>waitpid()</code>是不能做到让<code>rc_2</code>等待<code>rc_1</code>的。<a href="https://stackoverflow.com/questions/17330182/what-happens-if-i-use-wait-in-child-process">参考:stackoverflow</a></p><p>比如修改<code>rc_2</code>的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rc_2 = fork();<br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> wr = <span class="hljs-built_in">waitpid</span>(rc_1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过以上的代码并不能让<code>rc_2</code>等待<code>rc_1</code>，如果尝试输出<code>wr</code>会得到<code>wr == -1</code>（在父进程中则应该是等待进程的pid）</p>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区分不同exec()形式</title>
    <link href="/2022/03/19/exec-in-linux/"/>
    <url>/2022/03/19/exec-in-linux/</url>
    
    <content type="html"><![CDATA[<p>该问题为<code>OSTEP</code>第五章<code>进程API</code>上的一个问题，在搜<code>Stack overflow</code>的时候发现一个很好记的答案，单独写一个博客记录一下</p><h2 id="参考回答"><a href="#参考回答" class="headerlink" title="参考回答"></a>参考回答</h2><ol><li><a href="https://stackoverflow.com/a/5769803">what-are-the-different-versions-of-exec-used-for-in-c-and-c</a></li></ol><h2 id="翻译摘抄"><a href="#翻译摘抄" class="headerlink" title="翻译摘抄"></a>翻译摘抄</h2><p>对于<code>exec()</code>函数，在C&#x2F;C++中有以下几个不同的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>其中不同版本的区别通过函数名可以分为以下几个大类：</p><h3 id="L和V"><a href="#L和V" class="headerlink" title="L和V"></a>L和V</h3><ul><li><p>L：L在这里指的是<code>list</code>，执行的时候的将参数以类似如下方式传入：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">execl</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)<br></code></pre></td></tr></table></figure><p>  其中省略号代表了后续分别独立传入的参数，其中，第一个参数应是正在执行的文件关联的文件名，并且参数以<code>空字符NULL</code>作为结尾的判定。</p></li><li><p>V: V在这里指的是<code>vector</code>，执行的时候以<code>char*</code>的形式传入执行指令</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br></code></pre></td></tr></table></figure><p>  对于不确定传入参数的个数的时候，可以使用<code>vector</code>来执行程序。使用带<code>v</code>的函数的时候，首先传入的第一个<code>pathname</code>是指向可执行文件的路径，后面传入的<code>argv[]</code>中，第一个<code>argv</code>的位置上按习惯为可执行文件的名字，后面<code>argv+1</code>等参数则是实际需要调用的可执行文件的参数、</p></li></ul><p>有的命令执行的时候，我们并不知道要传入的参数有几个，而有的命令则必须要一定数量的参数才能运行。通过分别调用带<code>l</code>或带<code>v</code>的函数，在不同的情况下执行某些特定命令很有用</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>E在这里指代的是<code>Environment</code>，在结尾带<code>e</code>的<code>exec()</code>调用的时候的环境变量<code>env</code>与父进程的<code>env</code>并非一定相同，通过带<code>e</code>的函数即可在调用<code>exec()</code>的同时传入一个<code>env</code>供子进程使用</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>P在这里指的是系统环境变量中的<code>PATH</code>，含有<code>p</code>的<code>exec()</code>在调用的时候会在系统变量的<code>PATH</code>当中寻找对应的可执行文件，而缺少<code>p</code>的<code>exec()</code>在执行的时候，如果在当前目录下没有对应的文件名字，则需要传入目标可执行文件的绝对或相对路径。</p>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github actions打卡</title>
    <link href="/2022/03/18/SignIn-Ncu/"/>
    <url>/2022/03/18/SignIn-Ncu/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ol><li>该方法目前稳定性尚不确定，<code>Token</code>有概率会不定时失效，如果使用后果自负</li><li>该方法仅作<code>Python</code>学习使用，了解原理后使用后果自负</li><li>疫情期间请以实际情况打卡汇报，切勿身体有状况而依旧以无状况打卡。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/24180606?theme=dark">简单三步，用 Python 发邮件 - 知乎 (zhihu.com)</a></li><li><a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">github action获取仓库secrets</a></li></ol><h2 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h2><p>​通过Github Actions，在每天通过<code>cron</code>设定的时间实现企业微信打卡</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Github Actions</p><h2 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h2><p>QQ号以及QQ的SMTP密码</p><h2 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h2><ol><li><p>在打卡界面中”复制链接”，并在电脑上打开</p><p><img src="/2021/04/images/ClockIn_1.png" alt="企业微信"></p></li><li><p>电脑浏览器打开链接，按F12，此时可能是电子ID，不用管，在右上角找到<code>Network</code>，并打开。</p><p>(如果提示要按Ctrl+R，按就行)</p><p><img src="/2021/04/images/ClockIn_2.png" alt="Network"></p></li><li><p>在<code>Network</code>下方找到<code>loginByToken</code>，并且找到右边的<code>Token</code>信息，复制保存。</p><p><img src="/2021/04/images/ClockIn_3.png" alt="TokenGet"></p></li></ol><h2 id="获取QQ邮箱的SMTP密码"><a href="#获取QQ邮箱的SMTP密码" class="headerlink" title="获取QQ邮箱的SMTP密码"></a>获取QQ邮箱的SMTP密码</h2><p><a href="https://www.baidu.com/s?wd=%E8%8E%B7%E5%8F%96QQ%E9%82%AE%E7%AE%B1%E7%9A%84SMTP%E5%AF%86%E7%A0%81">百度搜索：获取QQ邮箱的SMTP密码</a></p><h2 id="编辑脚本"><a href="#编辑脚本" class="headerlink" title="编辑脚本"></a>编辑脚本</h2><p>出于对于疫情大环境下的数据考虑，这部分手把手教材略去，大致思路就是通过对应接口抓包后发包即可，更新<code>Token</code>通过接口<code>LoginByToken</code>实现，打卡通过<code>SignIn</code>接口实现。</p><h2 id="运行脚本并测试"><a href="#运行脚本并测试" class="headerlink" title="运行脚本并测试"></a>运行脚本并测试</h2><p>为了仓库的信息安全，所有的密码通过Github仓库下secrets来进行设置，然后参考 <a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">github action获取仓库secrets</a> 中提及的方法修改设置即可。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><em><strong>每个人都有义务在疫情大环境下对自己的真实信息负责，因此本文去除手把手教程，仅提供部分思路，如果有想法欢迎邮件讨论！</strong></em></p>]]></content>
    
    
    
    <tags>
      
      <tag>ncu</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github PAT存储</title>
    <link href="/2022/03/15/github-pat/"/>
    <url>/2022/03/15/github-pat/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/a/51505417">Where to store my Git personal access token?</a></li><li><a href="https://github.com/GitCredentialManager/git-credential-manager/blob/main/docs/credstores.md">GitCreadentitalManager</a></li></ul><h2 id="解决方案引导"><a href="#解决方案引导" class="headerlink" title="解决方案引导"></a>解决方案引导</h2><p>为了更好的管理Github的Token，需要一个Git凭证助手来帮我们记忆用户名和对应的PAT，以下为<code>Git-Credential-Manager-Core</code>引导</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装<a href="https://github.com/microsoft/Git-Credential-Manager-Core/releases/">Lateset Release</a>的GCM，并初始化设置</p>   <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i &lt;path-to-package&gt;<br>git-credential-manager-core configure<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在Linux上使用GCM需要额外设置<code>credential.credentialStore</code>，其中包含的设置方法如下：</p><h4 id="通过Secret-Service-API来存储"><a href="#通过Secret-Service-API来存储" class="headerlink" title="通过Secret Service API来存储"></a>通过<a href="https://specifications.freedesktop.org/secret-service/latest/">Secret Service API</a>来存储</h4><p><em><strong>该方法需要系统有GUI显示功能</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=secretservice<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore secretservice<br></code></pre></td></tr></table></figure><p>这个办法通过<code>libsecret</code>库来和<code>Secret Service</code>进行交互，所有的凭证都存储在“collections”当中。如果要查看的话，可以通过<code>secret-tool</code>或<code>seahorse</code>来进行查看。注：在请求用户帐号信息的时候会通过GUI来进行交互。</p><h4 id="通过Git自带的凭证缓存机制来存储"><a href="#通过Git自带的凭证缓存机制来存储" class="headerlink" title="通过Git自带的凭证缓存机制来存储"></a>通过Git自带的凭证缓存机制来存储</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=cache<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore cache<br></code></pre></td></tr></table></figure><p>这种方法保存的密码不会以可长期读取的文件形式存在硬盘上，如果是需要链接一些临时性的服务可以用这个方法。默认来说<code>git credential-cache</code>会储凭证900s，可以通过如下指令修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_CACHE_OPTIONS=<span class="hljs-string">&quot;--timeout 300&quot;</span><br><span class="hljs-comment"># or</span><br>git config --global credential.cacheOptions <span class="hljs-string">&quot;--timeout 300&quot;</span><br></code></pre></td></tr></table></figure><h4 id="通过纯文本的形式进行保存"><a href="#通过纯文本的形式进行保存" class="headerlink" title="通过纯文本的形式进行保存"></a>通过纯文本的形式进行保存</h4><p><em><strong>这办法不安全</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=plaintext<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore plaintext<br></code></pre></td></tr></table></figure><p>这种办法保存的密码默认会存在<code>~/.gcm/store</code>目录下，目录可通过<code>GCM_PLAINTEXT_STORE_PATH</code>环境变量来进行修改，如果文件不存在则会被创建新创建的文件权限为<code>700</code>.</p><h4 id="通过GPG-x2F-pass进行存储"><a href="#通过GPG-x2F-pass进行存储" class="headerlink" title="通过GPG&#x2F;pass进行存储"></a>通过GPG&#x2F;pass进行存储</h4><p><em><strong>这种方法需要有一对GPG密钥</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=gpg<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore gpg<br></code></pre></td></tr></table></figure><p>这种办法主要使用了<a href="https://www.passwordstore.org/">pass</a>工具，默认情况下文件会保存在<code>~/.password-store</code>文件下，该目录可以通<code>PASSWORD_STORE_DIR</code>来进行修改。在使用这种办法进行凭证管理之前，首先需要通过一对GPG密钥对<code>pass</code>进行初始化操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pass init &lt;gpg-id&gt;<br></code></pre></td></tr></table></figure><p>这里的&lt;gpg-id&gt;指的是当前使用gpg密钥对的用户的系统id。通过以下指令可以创建一个自己的gpg密钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --gen-key<br><span class="hljs-comment"># and follow prompts</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP-进程</title>
    <link href="/2022/03/12/ostep-homework-1/"/>
    <url>/2022/03/12/ostep-homework-1/</url>
    
    <content type="html"><![CDATA[<h2 id="第四章：进程"><a href="#第四章：进程" class="headerlink" title="第四章：进程"></a>第四章：进程</h2><p>作业来自: <a href="https://github.com/remzi-arpacidusseau/ostep-homework">ostep-homework</a></p><ol><li><p>两个程序都只使用CPU，所以CPU的利用率是100%，测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1        RUN:cpu         READY             1          <br>  2        RUN:cpu         READY             1          <br>  3        RUN:cpu         READY             1          <br>  4        RUN:cpu         READY             1          <br>  5        RUN:cpu         READY             1          <br>  6           DONE       RUN:cpu             1          <br>  7           DONE       RUN:cpu             1          <br>  8           DONE       RUN:cpu             1          <br>  9           DONE       RUN:cpu             1          <br>10           DONE       RUN:cpu             1          <br><br>Stats: Total Time 10<br>Stats: CPU Busy 10 (100.00%)<br>Stats: IO Busy  0 (0.00%)<br></code></pre></td></tr></table></figure></li><li><p>总共使用了11 ticks的时间，测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1        RUN:cpu         READY             1          <br>  2        RUN:cpu         READY             1          <br>  3        RUN:cpu         READY             1          <br>  4        RUN:cpu         READY             1          <br>  5           DONE        RUN:io             1          <br>  6           DONE       WAITING                           1<br>  7           DONE       WAITING                           1<br>  8           DONE       WAITING                           1<br>  9           DONE       WAITING                           1<br>10           DONE       WAITING                           1<br>11*          DONE   RUN:io_done             1        <br></code></pre></td></tr></table></figure></li><li><p>交换顺序后，在PID0进行io操作的时候，PID1会切换成RUNNING的状态，提高了CPU的利用效率，所以交换顺序重要。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING       RUN:cpu             1             1<br>  3        WAITING       RUN:cpu             1             1<br>  4        WAITING       RUN:cpu             1             1<br>  5        WAITING       RUN:cpu             1             1<br>  6        WAITING          DONE                           1<br>  7*   RUN:io_done          DONE             1          <br></code></pre></td></tr></table></figure></li><li><p>由于加上了<code>SWITCH_ON_END</code>的标签，此时PID0进行IO操作的时候CPU会空闲等待至IO操作完成，浪费了一定的时间。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING         READY                           1<br>  3        WAITING         READY                           1<br>  4        WAITING         READY                           1<br>  5        WAITING         READY                           1<br>  6        WAITING         READY                           1<br>  7*   RUN:io_done         READY             1          <br>  8           DONE       RUN:cpu             1          <br>  9           DONE       RUN:cpu             1          <br>10           DONE       RUN:cpu             1          <br>11           DONE       RUN:cpu             1  <br></code></pre></td></tr></table></figure></li><li><p>由于这次会在等待IO的时候进行进程的切换，所以在io操作时，CPU没有等待，而是切换到了另外一个进程上继续工作，提高了利用率。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING       RUN:cpu             1             1<br>  3        WAITING       RUN:cpu             1             1<br>  4        WAITING       RUN:cpu             1             1<br>  5        WAITING       RUN:cpu             1             1<br>  6        WAITING          DONE                           1<br>  7*   RUN:io_done          DONE             1   <br></code></pre></td></tr></table></figure></li><li><p>由于IO操作的优先级不是最高的，即使io操作的WAITING结束了，也会等待CPU先将其他进程执行之后，再对IO进行切换，由于IO操作需要消耗比较多的额外时间，而这部分时间没有被CPU利用，所以系统资源没有得到有效利用。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs<br>  1         RUN:io         READY         READY         READY             1          <br>  2        WAITING       RUN:cpu         READY         READY             1             1<br>  3        WAITING       RUN:cpu         READY         READY             1             1<br>  4        WAITING       RUN:cpu         READY         READY             1             1<br>  5        WAITING       RUN:cpu         READY         READY             1             1<br>  6        WAITING       RUN:cpu         READY         READY             1             1<br>  7*         READY          DONE       RUN:cpu         READY             1          <br>  8          READY          DONE       RUN:cpu         READY             1          <br>  9          READY          DONE       RUN:cpu         READY             1          <br>10          READY          DONE       RUN:cpu         READY             1          <br>11          READY          DONE       RUN:cpu         READY             1          <br>12          READY          DONE          DONE       RUN:cpu             1          <br>13          READY          DONE          DONE       RUN:cpu             1          <br>14          READY          DONE          DONE       RUN:cpu             1          <br>15          READY          DONE          DONE       RUN:cpu             1          <br>16          READY          DONE          DONE       RUN:cpu             1          <br>17    RUN:io_done          DONE          DONE          DONE             1          <br>18         RUN:io          DONE          DONE          DONE             1          <br>19        WAITING          DONE          DONE          DONE                           1<br>20        WAITING          DONE          DONE          DONE                           1<br>21        WAITING          DONE          DONE          DONE                           1<br>22        WAITING          DONE          DONE          DONE                           1<br>23        WAITING          DONE          DONE          DONE                           1<br>24*   RUN:io_done          DONE          DONE          DONE             1          <br>25         RUN:io          DONE          DONE          DONE             1          <br>26        WAITING          DONE          DONE          DONE                           1<br>27        WAITING          DONE          DONE          DONE                           1<br>28        WAITING          DONE          DONE          DONE                           1<br>29        WAITING          DONE          DONE          DONE                           1<br>30        WAITING          DONE          DONE          DONE                           1<br>31*   RUN:io_done          DONE          DONE          DONE             1 <br></code></pre></td></tr></table></figure></li><li><p>在使用了IMMEDIATE标签后，每次io_done之后CPU都会先切换io操作，然后用io处理的时间来处理其他进程，提高了系统资源的利用率。测试如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs<br>  1         RUN:io         READY         READY         READY             1          <br>  2        WAITING       RUN:cpu         READY         READY             1             1<br>  3        WAITING       RUN:cpu         READY         READY             1             1<br>  4        WAITING       RUN:cpu         READY         READY             1             1<br>  5        WAITING       RUN:cpu         READY         READY             1             1<br>  6        WAITING       RUN:cpu         READY         READY             1             1<br>  7*   RUN:io_done          DONE         READY         READY             1          <br>  8         RUN:io          DONE         READY         READY             1          <br>  9        WAITING          DONE       RUN:cpu         READY             1             1<br>10        WAITING          DONE       RUN:cpu         READY             1             1<br>11        WAITING          DONE       RUN:cpu         READY             1             1<br>12        WAITING          DONE       RUN:cpu         READY             1             1<br>13        WAITING          DONE       RUN:cpu         READY             1             1<br>14*   RUN:io_done          DONE          DONE         READY             1          <br>15         RUN:io          DONE          DONE         READY             1          <br>16        WAITING          DONE          DONE       RUN:cpu             1             1<br>17        WAITING          DONE          DONE       RUN:cpu             1             1<br>18        WAITING          DONE          DONE       RUN:cpu             1             1<br>19        WAITING          DONE          DONE       RUN:cpu             1             1<br>20        WAITING          DONE          DONE       RUN:cpu             1             1<br>21*   RUN:io_done          DONE          DONE          DONE             1          <br></code></pre></td></tr></table></figure></li><li><p>开放题随机，和前七题大致相同。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结：玩了艾尔登法环的半个月..</title>
    <link href="/2022/03/06/February/"/>
    <url>/2022/03/06/February/</url>
    
    <content type="html"><![CDATA[<p>还是对自己的效率太高估了….每次玩游戏的时候就想着一直玩到通关为止，规划的二月份的学习计划没有一个完成的。</p><p>不过既然说了要写总结还是得写一篇来记录一下。</p><h2 id="做了的事情"><a href="#做了的事情" class="headerlink" title="做了的事情"></a>做了的事情</h2><h3 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h3><p>尝试了用Postman工具进行抓包，不过由于自己偷懒没仔细看文档以及对代理设置的不当配置，前前后后断断续续折腾了四五天还是换回Wireshark进行数据抓包，Python抓包发包本身学习倒是简单不少，一到两个小时就完成了学习，Appium目前也还没有开始接触。Rust相关的课程完全搁置没有进度。CS144的lab搭建好环境并在别人现成已有的Blog下完成了第一个实验，但是由于照葫芦画瓢，成就感很低并且了解不彻底，需要重新完成。力扣打卡断断续续持续了半个月，在2.25艾尔登法环发售到3.6通关群星结局过程没有其他进度。</p><h3 id="游戏方面"><a href="#游戏方面" class="headerlink" title="游戏方面"></a>游戏方面</h3><p>虽然二月份就学习内容上来说摆烂几乎没有进度，但是用了一个礼拜的高强度游戏来感悟宫崎老贼的“魂系”游戏也完全不会让我觉得是在浪费时间。超大的世界观框架+完全自由的探索+五花八门的怪物+永远可以带来惊喜的各种武器，在初高中的时候总幻想一个所有人都可以一起探索的世界，这个世界在玩艾尔登法环的时候完全能够切身体验。在目前的开荒时期，除了自己推图可以发现各种各样的东西，同时最让人流连于其中的则是在目前世界观巨大的情况下，还没有完备的攻略来引导玩家“必须&#x2F;流水线”的一套教程，同时全网玩家又在一起对这个世界进行发掘，让这个本来“单机”的游戏在某种意义上又变成了全网大家一起探索的异次元，这种开荒的乐趣加上老头环本身庞大的世界观绝对能称为我心中的“年度游戏”。</p><h2 id="三月份要做的事情"><a href="#三月份要做的事情" class="headerlink" title="三月份要做的事情"></a>三月份要做的事情</h2><h3 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h3><ul><li>无，完成之前二月份的任务就算成功</li></ul><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><ul><li>在不下雨的天气每天跑至少1.2km，同时保持良好的作息习惯</li><li>饮食上一个礼拜只吃一次非常规饮食，同时定期吃水果，改掉只吃维生素药片的习惯</li></ul><p>这几天玩游戏的时候一直觉得这个月做的事情太少了，心里很不舒服。看到知乎一些“焦虑推送文”的时候也总觉得自己不务正业。造成这种情况的主要原因还是对玩艾尔登法环的时候一心想着开荒，对时间分配及其不合理导致状态的失衡，不过就取舍来说，作为几年难得一遇的优质游戏，和好兄弟一起联机攻克boss和开荒的快感不知下次得等几年，并不觉得这一个礼拜的时间有所亏欠，只是需要在这个月加把劲，把二月欠的任务完成！</p>]]></content>
    
    
    
    <tags>
      
      <tag>conclusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启TCP BBR算法</title>
    <link href="/2022/02/08/Update_BBR_in_Ubuntu/"/>
    <url>/2022/02/08/Update_BBR_in_Ubuntu/</url>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="https://wiki.crowncloud.net/?How_to_enable_BBR_on_Ubuntu_20_04">How to enable BBR on Ubuntu 20.04</a></p><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h2><p>默认情况下Linux 使用 Reno 和 CUBIC 拥塞控制算法，Linux kernal 4.9以上版本的内核已经自带该功能，由于Ubuntu 20.04的为5.4.0 kernel，我们可以直接启用</p><p>通过以下指令检查目前可选择的拥塞控制算法：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_available_congestion_control<br></code></pre></td></tr></table></figure><p>输出大致为（可用的算法有reno和cubic两种）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_available_congestion_control<br>net.ipv4.tcp_available_congestion_control = reno cubic<br></code></pre></td></tr></table></figure><p>通过以下指令检查目前的拥塞控制算法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_congestion_control<br></code></pre></td></tr></table></figure><p>输出大致为（目前是cubic)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_congestion_control<br>net.ipv4.tcp_congestion_control = cubic<br></code></pre></td></tr></table></figure><h2 id="在Ubuntu中启用TCP-BBR"><a href="#在Ubuntu中启用TCP-BBR" class="headerlink" title="在Ubuntu中启用TCP BBR"></a>在Ubuntu中启用TCP BBR</h2><ol><li><p>在文件<code>etc/sysctl.conf</code>中写入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.core.default_qdisc=fq<br>net.ipv4.tcp_congestion_control=bbr<br></code></pre></td></tr></table></figure><p>保存并退出</p></li><li><p>重置<code>sysctl</code>设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sysctl -p<br></code></pre></td></tr></table></figure><p>此时会有大致输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl -p<br>net.core.default_qdisc = fq<br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure></li><li><p>检查BBR是否在系统中正确启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_congestion_control<br></code></pre></td></tr></table></figure><p>大致输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_congestion_control<br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure></li></ol><p>完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结：折腾了Homelab的一个月</title>
    <link href="/2022/02/06/January/"/>
    <url>/2022/02/06/January/</url>
    
    <content type="html"><![CDATA[<p>一月大部分时间都在准备期末考试的时间上了，在期末考试之后就开始松懈停滞不前了起来，又开始进入了拖延的老毛病当中。新年快结束了，但是对于之前给自己定下的目标和计划目前还依旧没有什么努力的意思，这篇总结大体是要写成一个流水帐了，但也还是权当个人记录（反正没人看hhh）</p><h2 id="做了的事情"><a href="#做了的事情" class="headerlink" title="做了的事情"></a>做了的事情</h2><p>虽然说是说这个月没有为本来的计划和目标努力，但还算是折腾了一些有意思的东西：</p><ul><li>学习了Rust的初级语法，在期末考试前完成了<a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Microsoft Learning上入门Rust</a>的40%内容，考完试后完全松懈没有进度。</li><li>把家里的Homelab更换迁移成了EXSi基础的虚拟机，并在此之上将之前服务器上的服务器重新分开部署</li><li>第一次尝试自己<a href="https://www.gcores.com/articles/146815">投稿文章</a>，在机核的反馈感觉有希望继续写下去</li></ul><p>在之外就是通宵熬夜生死存亡的期末考试复习了。</p><h2 id="二月份要做的事情"><a href="#二月份要做的事情" class="headerlink" title="二月份要做的事情"></a>二月份要做的事情</h2><h3 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h3><ul><li>学习一下Python对于网页抓包数据的一些模拟，和对于Appium的使用</li><li>完成Rust整个的入门课程</li><li>CS144的6个lab至少完成2个（考虑拖延的情况下），有时间充裕就完成3-4个</li><li>力扣每天题库非困难题打卡</li></ul><h3 id="折腾着自己玩玩"><a href="#折腾着自己玩玩" class="headerlink" title="折腾着自己玩玩"></a>折腾着自己玩玩</h3><ul><li>完成家里面Homelab关于流媒体服务器的部署</li><li>通过Python+Appium的组合，看看能不能全自动化学校企业微信打卡内容</li></ul><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><ul><li>找2-3部电影看完，内容随意</li><li>开学前每天锻炼半小时，睡眠作息开始调整为十一点睡觉，六点到七点起床</li></ul><p>整个流程下来还是感觉和记流水帐一样吧，不过这样记录了以后感觉负罪感也强了一些，也算是最自己的一个监督。希望能离年初的目标越来越近。</p>]]></content>
    
    
    
    <tags>
      
      <tag>conclusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alternatives切换环境</title>
    <link href="/2022/01/29/update-alternatives/"/>
    <url>/2022/01/29/update-alternatives/</url>
    
    <content type="html"><![CDATA[<h2 id="参考帖子"><a href="#参考帖子" class="headerlink" title="参考帖子"></a>参考帖子</h2><ol><li><a href="https://medium.com/analytics-vidhya/how-to-install-and-switch-between-different-python-versions-in-ubuntu-16-04-dc1726796b9b">How to install and switch between different python versions in ubuntu 16.04</a></li></ol><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>在切换Java版本的时候，通过<code>update-alternatives</code>可以很方便的进行版本之间的切换，而在Python里面，如果用<code>Ubuntu</code>自己的<code>apt</code>包管理器同时下载了多个版本的<code>Python</code>的话，则需要自己手动对<code>Python</code>的版本进行切换设定（切换版本还有alias等方法，这里不提及）。指令如下：</p><ol><li><p>在安装了多个版本的Python之后（其他语言同理），通过类似以下指令的格式添加对应的程序优先级：</p> <figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2<br></code></pre></td></tr></table></figure></li><li><p>由上面设置的程序指令为<code>python</code>，接下来通过以下指令对<code>python</code>的版本进行切换：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --config python<br></code></pre></td></tr></table></figure><p> 输入之后可以见到类似如下的选择：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">There are 2 choices for the alternative python (providing /usr/bin/python).<br><br>Selection    Path                Priority   Status<br>------------------------------------------------------------<br>* 0            /usr/bin/python3.8   2         auto mode<br>1            /usr/bin/python2.7   1         manual mode<br>2            /usr/bin/python3.8   2         manual mode<br><br>Press &lt;enter&gt; to keep the current choice[*], or type selection number:<br></code></pre></td></tr></table></figure><p> 只需要在number后面输入对应需要的优先级，即可对<code>python</code>的版本进行切换。</p></li></ol><blockquote><p>每次都会忘记是<code>update alternatives</code>还是<code>alternatives-update</code>，所以写一篇博客记录一下…自己还是太Native了。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021总结</title>
    <link href="/2022/01/07/Yearly-conclusion/"/>
    <url>/2022/01/07/Yearly-conclusion/</url>
    
    <content type="html"><![CDATA[<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>往年本来都没有在年初或者年末的时候写一个一年总结的习惯，今年也算是突发奇想，打算写一篇博客稍微记录下自己的学习和生活。希望能在2022年里面养成时不时记录一下自己生活的习惯，养成正视自己的一个态度。</p><h2 id="性格变化"><a href="#性格变化" class="headerlink" title="性格变化"></a>性格变化</h2><p>从2020年高三高考结束，到2021年大一升大二，也算是对大学生活有了一些认知和了解。整个大一的时间不能说浑浑噩噩，但总觉得自己心里缺了点什么。</p><p>现在仔细想想感觉就是缺少对自己的一个自视，总觉得心里空空的，不自在。刚上大学的时候就对“信息差”这个词很敏感，整个大一的过程也感觉一直在忙忙碌碌的处理各种各样的“信息”。无论是平时上课、考试还是处理一些生活中的问题，也总是把能搜罗到的各种信息的优先级置于自己“能力”的优先级之上，对外界环境的信任远高于对自己的信任。</p><p>这种自己信任上的缺乏感在最近听<code>Daniel Sloss</code>的<code>Jigsaw(拼图)</code>的<a href="https://www.bilibili.com/video/BV1Qi4y1s72w?p=1">Live Show</a>之后，感觉悟到自己经常总是忽视自己，一直感觉空虚因而不断的向外界索取信息，大抵也就是自己尚且不能适应孤独的感觉。上了大学以后本来觉得能聊的人多了，孤独的感觉应该弱化了，但现在想想过去一年里面反而应该是越来越强了。想过也许是不是谈恋爱就能让自己生活不那么孤独，但现在想想，问题应该还是出在自己对自己的不信任上。</p><blockquote><p><em><strong>连自己都不能做到100%爱自己的话，也很难爱其他人</strong></em></p></blockquote><p>总之，希望在将来到的2022年里面，能增加自己正视自己的态度。争取每个月写一个总结，来达到”给自己泼一盆冷水醒一醒“的作用。</p><p><em><strong>有的话，说出来了才有力量警醒自己</strong></em></p><h2 id="能力技能"><a href="#能力技能" class="headerlink" title="能力技能"></a>能力技能</h2><p>这个学期除了学校本身的内容，学习密度最大的时候应该是年初倒腾软路由的时候开始的。从最初依赖带有GUI界面的<code>openwrt</code>的<code>luci</code>界面，到现在已经习惯了<code>terminal</code>的方式进行各种操作，这种对<code>Linux</code>一类命令行态度的转变有一种拿到了普罗米修斯的火把的感觉，一切原来觉得”麻烦“或者难以折腾的东西，突然都明朗了起来，即使遇到了问题，相比原来无脑cp各路解决方案的脚本指令，现在会下意识的思考和提前验证其中的原理和造成的影响了。</p><p>对于项目而言，去年算是或多或少接触或者熟悉了Nginx、Docker、MySQL等等零零碎碎的知识和技术，也搭建了一台以家里电脑为处理服务器，香港云服务器作为跳板的公网服务器，在上门也尝试部署过许多不同的demo或者项目，其中也通过对<code>ZeroTier</code>一类的工具的深入研究，也算是对计算机网络的学习和经验埋下了兴趣。</p><p>不过去年一年中，也和性格相关，大部分时候只是在通过搜刮各种”信息“，来搭建各种别人的项目然后进行一些很小的改动，一直在重复着<code>”遇到问题“-&gt;”寻找别人的解决方案“-&gt;”不断选择最优解并且排错“-&gt;”解决问题“</code>的过程，而总是不会把**”自己创造解决方案“排在首要位置。今年的博客内容也能体现我目前”知识密度“低下的严重不足，大部分时候只是写个机械性的总结草草了事，缺少很多思考和加工的过程。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>平时在学校一个人虽然自在，但也还是和在家里一样一直倾向于变化越少越好，很少出门，出门吃饭也都只是找平时能难得线下面对面聊的比较多的同学，线上聊的比较多的同学和学长就经常”社恐“了。</p><p>在今年年末的时候，高考那会的储蓄也算是消耗殆尽了，钱的概念也越来越深刻了。不过还算幸运的是有需要的东西基本上也都备齐了，之后需要的东西开销应该也不会很大，目前的电子产品和设备就足够我把玩好一阵子了。</p><p>今年上半年的时候一直在忙忙碌碌的在不同的互联网上”冲浪”，一直在到处寻找已有的工具和服务然后不断上手和试验。看上去很忙但实际上也都学的是一些花时间，而不用花精力就能学会的“三脚猫”功夫。下半年的话反而玩了好几款3A大作而觉得整一年都充实了不少（手柄玩游戏是真的闲适），总的效率上虽然没做什么事情，但情绪要比上半年积极快乐多了。</p><h2 id="目标和计划"><a href="#目标和计划" class="headerlink" title="目标和计划"></a>目标和计划</h2><p>2022年也到了，之前也没做过啥新年计划，今年也算是第一年尝试看看了，姑且列出以下几个目标，看看年末的时候能实现多少吧：</p><ul><li>每个月写一篇总结，大致总结一下这个月发生了什么，就当是自己对自己态度的一个正视，也算是自己和自己对话了。</li><li>减肥，希望能减到<code>BMI</code>标准的水平。</li><li>接触至少三种不同的编程语言，了解相关的项目，并提交出自己的第一个PR</li><li>游戏开发入门，制作自己的一个游戏demo</li><li>学习一门额外的技能，目前的计划包括但不限于：<ul><li>日语入门（问就是二次元）</li><li>拾回Adobe全家桶</li><li>系统性学习建模软件</li></ul></li><li>争取能参加一次GameJam</li></ul><p>以上应该算是对2021年的一个缺胳膊少腿的总结吧，其中也发生了很多值得纪念和回味的细节事情，包括和不同的人相识又或者和第一次和同学去旅游，在旅游的时候又和曾经的同学见面……写博客的目的还是希望能把那些原来不会对别人，也不会对自己说的话记录下来，也是对自己的一个警示了。</p><p>2022年1月7号 - 凌晨3:14</p><p>（感冒还没好全 &amp; 期末预习备战中… 希望这学期别挂XD)</p>]]></content>
    
    
    
    <tags>
      
      <tag>conclusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快慢指针</title>
    <link href="/2021/12/02/Fast_and_Slow_Cur/"/>
    <url>/2021/12/02/Fast_and_Slow_Cur/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容仅为刷题总结，只记录目前遇到过的情况，如果后面遇到了更多可能性再做记录。</p></blockquote><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>快慢指针的主要思想有点类似追击问题，通过让两个不同的小人以不同的速度在线性路径上行进，来招到某个特殊的相对位置。通常可以用来解决大致一下两类问题：</p><ol><li>线性路径上某特殊点的位置和对应的操作</li><li>判断链表中是否存在循环（以及循环的点位置）</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一般的思路是让两个不同的小人先以某一个相对的路径进行移动，之后再以一定倍率的相对速度进行继续移动，如果发生了『追击』、『相遇』或者『触底』等特殊事件的时候，就可以作为解题需要的特殊位置来进行处理。</p><h3 id="举例一：回文链表"><a href="#举例一：回文链表" class="headerlink" title="举例一：回文链表"></a>举例一：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h3><p>如何判断出链表的中点位置？</p><p>答：通过两个速度分别为<code>v</code>和<code>2v</code>的指针同时从表头开始出发，当<code>2v</code>速度的指针『触底』的时候，以速度<code>v</code>前进的指针指向的位置理应为中点。</p><blockquote><p>如果链表的长度为偶数的话，具体是停留在中间位置的左边还是右边要结合具体情况进行判断</p></blockquote><h3 id="举例二：环形链表"><a href="#举例二：环形链表" class="headerlink" title="举例二：环形链表"></a>举例二：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jbex5/">环形链表</a></h3><p>如何判断链表内是否有循环？</p><p>答：让两个不同速度的指针分别出发，如果有环存在的话，则必然会有两个指针在环内相遇。</p><h3 id="举例三：环形链表-II"><a href="#举例三：环形链表-II" class="headerlink" title="举例三：环形链表 II"></a>举例三：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jjhf6/">环形链表 II</a></h3><p>如何判断链表内开始进入环的位置？</p><p>答：让两个指针分别以速度<code>v</code>和<code>2v</code>出发，相遇则说明环存在。这个时候假入环前的长度为D，设环的长度为C，入环点到相遇点的距离为S1，相遇点重新回到入环点的距离则为S2。</p><ul><li>此时快指针比慢指针多走n圈，所以走的距离必然为<code>D+S1+nC</code></li><li>慢指针走一圈的时候，快指针能走两圈。所以相遇必然发声在第一个环内，所以慢指针走的距离为<code>D+S1</code></li><li>由于<code>2 * (D + S1) == D + S1 + nC</code>和<code>C = S1 + S2</code>，所以不难得出<code>D = (n - 1)(S1 + S2) + S2</code>，即<code>D = (n - 1)C + S2</code>的结论，翻译一下则为，入环点前面的长度D即为<strong>慢指针再走S2，到达入环点之后，再走n-1圈的长度</strong>。</li><li>所以这个时候只需要再设定一个指针，让它从头开始走，当走到入环点D的时候，理论上来说慢指针也将走完第<code>n-1</code>圈，所以他们会相遇，同时慢指针的步数即为进入环的长度！</li></ul><h2 id="举例四：倒数第N个节点"><a href="#举例四：倒数第N个节点" class="headerlink" title="举例四：倒数第N个节点"></a>举例四：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jf1cc/">倒数第N个节点</a></h2><p>如何删除链表中的倒数第N个节点？</p><p>答：让两个起始位置相差n的指针以同样的速度运动，当前面的指针『触底』的时候，后面的指针自己就是「倒数第n个」节点了。</p><blockquote><p>实际操作的时候，由于单向链表需要知道前一个节点才能对后一个节点进行操作，所以通常会让走的快的节点比自己先走一步。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2021/12/02/LinkList/"/>
    <url>/2021/12/02/LinkList/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容仅为刷题总结，只记录目前遇到过的情况，如果后面遇到了更多可能性再总结</p></blockquote><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><p>在链式存储当中，对于节点是使用指针指向的方式进行数据的存储，其结点定义类似如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    LinkNode *next;<br>    <span class="hljs-built_in">LinkNode</span>() &#123;&#125;<br>    <span class="hljs-built_in">LinkNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>链表的好处是在添加或者删除特定节点的时候时间复杂度比顺序存储要小。在经常需要删除和添加操作节点的时候，通过直接修改节点的指针，可以快捷的对节点进行对应操作。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>链表划分为三个部分，头+中间的数据节点+尾。</p><h3 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h3><p>其中头节点有两种常见的处理方式，一种是通过一个虚拟的<code>dummyhead</code>来当作头结点，之后才是真实的数据节点。这样的好处是可以在对实际含有意义的头节点进行操作的时候，不需要有额外的特判就可以完成，通过增加一个头结点在部分题目中有的时候可以有很好的效果。</p><h3 id="尾节点"><a href="#尾节点" class="headerlink" title="尾节点"></a>尾节点</h3><p>尾节点和头结点一样，也有实际意义上存在的数据节点和最后指向的一个尾巴节点，不过根据节点的定义来看，可以知道尾节点后面通常都跟有一个无意义的<code>nullptr</code>。在有的时候需要对尾节点进行处理的时候，增加一个虚拟的<code>dummytail</code>也许也能起到很好的效果。*(p.s. 比如在写双向链表的时候)*</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>创建链表的时候，通常会创建一个指针节点来表示整个链表的头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LinkNode *ListA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();<br></code></pre></td></tr></table></figure><p>以上代码的含义即为创建一个LinkNode的节点，同时创建一个叫做<code>List</code></p><p><code>A</code>的指针，指向的是这个节点的内存。</p><p>而在对单向链表的进行操作的时候，如果我们移动了链头，很多时候意味着操作都是不可逆的。因此如果需要对链表中某个特定节点进行操作的时候，往往都会创建一个指向需要节点的指针来进行单独操作，操作完毕后将指针释放即可。</p><p>以下举例，阐明节点和节点指针之间的关系：*(感觉有点废话)*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LinkNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();  <span class="hljs-comment">// 创建一个cur指针</span><br>LinkNode *A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>(<span class="hljs-number">114</span>);  <span class="hljs-comment">// 创建节点A</span><br>LinkNode *B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>(<span class="hljs-number">115</span>);  <span class="hljs-comment">// 创建节点B</span><br>cout&lt;&lt;<span class="hljs-string">&quot;cur addr:&quot;</span>&lt;&lt;cur&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;A addr:&quot;</span>&lt;&lt;A&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;B addr:&quot;</span>&lt;&lt;B&lt;&lt;endl;<br><span class="hljs-comment">// 此时cur、A和B表示的内存地址</span><br>cur = A;<br>LinkNode *tmp = A;<br>cout&lt;&lt;tmp&lt;&lt;endl;<br><span class="hljs-comment">// 让cur指向A之后cur的内存地址</span><br>A = B;  <span class="hljs-comment">// 让A指向B</span><br><span class="hljs-comment">// delete tmp;  // 是否删除原本A代表的节点对应内存</span><br>cout&lt;&lt;<span class="hljs-string">&quot;cur addr:&quot;</span>&lt;&lt;cur&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;A addr:&quot;</span>&lt;&lt;A&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;B addr:&quot;</span>&lt;&lt;B&lt;&lt;endl;<br>cout&lt;&lt;cur-&gt;val&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在注释了<code>delete tmp</code>的时候，最后输出的<code>cur-&gt;val</code>会依旧是114这个A曾经的值，而如果执行了对应的<code>delete</code>操作，由于原本A对应内存上的结构体被释放了，所以这个时候<code>cur</code>就没有指向一个有效的节点。</p><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="链表的终止条件"><a href="#链表的终止条件" class="headerlink" title="链表的终止条件"></a>链表的终止条件</h3><p>常用的终止条件有三种：</p><ol><li><code>cur != nullptr</code> 指针会停留在<code>nullptr</code>的尾节点上</li><li><code>cur-&gt;next != nullptr</code> 指针会停留在最后一个有效节点上</li><li><code>cur != nullptr &amp;&amp; cur-&gt;next != nullptr</code>多用于快慢指针，用于判断快指针是否到队尾。之所以两种情况都判断为循环跳出的条件原因：由于<code>nullptr</code>本身相当于最后一个有效节点的附加尾巴。类比于线段上有区间(a, b)和区间[a,b]，快指针的目的是为了判断长度，而这两种区间长度都是<code>b - a</code>，只是对于第一种情况(a, b)如果不将b节点本身纳入有效节点则会出现区间长度变为<code>a -&gt; (b - 1)</code>的情况。</li></ol><p>对于第三种终止条件，还可以类比为：</p><ul><li><code>cur == nullptr</code>终止的情况就是区间(a, b)，此时cur在走到b的时候快指针已经越界，刚好碰壁</li><li><code>cur-&gt;next == nullptr</code>终止的情况就是区间[a, b]，此时cur在走到b时，刚好到达边界，也同样碰壁。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL代理-尝试二</title>
    <link href="/2021/11/15/WSL_Windows_DNS/"/>
    <url>/2021/11/15/WSL_Windows_DNS/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这算是被WSL折腾代理的第三次了。前两次解决代理的方案分别是通过脚本获取到Windows的IP之后再设置proxy，当时因为防火墙的问题不知道为什么总是不能生效。之后采取的是通过Clash开启网卡代理，让所有流量都能经过Clash处理，自然也就能处理WSL2中的流量了。但这样处理的致命缺点就是所有的流量都由Clash代理，其中的性能使用不可小觑，所以最后还是采取了WSL+Zsh的Proxy插件的方式来实现常见需求的代理。</p><p>在进行操作之前首先要有的操作：</p><ul><li>安装好<code>zsh</code>，并安装<code>zsh-proxy</code></li></ul><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ul><li>在Windows开机的时候自动启动WSL内的脚本，同时修改该进程下的WSL的Host</li><li>添加一个脚本，在每次WSL开机的时候自动将宿主机的IP映射到<code>win.lan</code>这个DNS上</li><li>设置Zsh的Proxy为宿主机的Clash代理地址</li><li>Clash设置并开启了代理服务</li></ul><h2 id="在Windows内开机自启动WSL"><a href="#在Windows内开机自启动WSL" class="headerlink" title="在Windows内开机自启动WSL"></a>在Windows内开机自启动WSL</h2><p>由于Host文件在每次WSL重新启动的时候都会自动刷新（手动禁止Host的更新感觉不太优雅），加上WSL本身也比较轻量化，所以最后方案考虑为开机自启动WSL，同时更新WSL的Host文件。以下为创建WSL开机自启动的教程：</p><ol><li><p>在Windows下按<code>win+R</code>，输入<code>shell:startup</code>回车打开开机启动目录</p></li><li><p>创建脚本文件<code>wsl.vbs</code>，并写入以下内容来让WSL持续运行：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">Set</span> ws = WScript.<span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>)        <br>ws.run <span class="hljs-string">&quot;wsl -d Ubuntu-20.04 -u root /etc/init.wsl&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>同时在WSL中创建&#x2F;etc&#x2F;init.wsl文件，写入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/sh</span><br>/etc/init.d/ssh start<br>/etc/init.d/cron start<br>/etc/init.d/windns.sh  ## 用于更改windows的DNS的脚本<br></code></pre></td></tr></table></figure><p>以上在Windows的操作结束，下面的内容都在WSL中进行：</p></li></ol><h2 id="脚本添加"><a href="#脚本添加" class="headerlink" title="脚本添加"></a>脚本添加</h2><ol><li><p>创建一个脚本文件，写入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>winip=$(&lt; /etc/resolv.conf  grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)<br>echo &quot;Windows Current IP:&quot;&quot;$&#123;winip&#125;&quot;<br>currentIP=$(&lt; /etc/hosts  grep &quot;win.lan&quot; | awk &#x27;&#123; print $1 &#125;&#x27;)<br>echo &quot;Current Host IP:&quot;&quot;$&#123;currentIP&#125;&quot;<br><br>if [ &quot;$&#123;currentIP&#125;&quot; = &quot;&quot; ]; then<br>    echo &quot;$&#123;winip&#125; win.lan&quot; &gt;&gt; /etc/hosts<br>    echo &quot;添加host完成&quot;<br>    exit 0<br>fi<br><br>if [ &quot;$&#123;winip&#125;&quot; = &quot;$&#123;currentIP&#125;&quot; ]; then<br>    echo &quot;No need to change host&quot;<br>    exit 0;<br>else<br>    echo &quot;Start to change host&quot;<br><br>    old=$(&lt; /etc/hosts grep &quot;win.lan&quot;)<br>    new=$&#123;winip&#125;&quot; win.lan&quot;<br>    sudo sed -i &quot;s/$&#123;old&#125;/$&#123;new&#125;/g&quot; /etc/hosts<br>    echo &quot;修改host完成&quot;<br>    check=$(&lt; /etc/hosts grep &quot;win.lan&quot;)<br>    echo &quot;$&#123;check&#125;&quot;<br>    exit 0<br>fi<br></code></pre></td></tr></table></figure></li><li><p>保存后，假设文件名字为<code>windns.sh</code>，输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x windns.sh<br>sudo mv windns.sh /etc/init.d/<br>sudo update-rc.d windns.sh defaults 100<br></code></pre></td></tr></table></figure></li><li><p>后续如果要删除这个脚本，只需要执行以下指令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d windns.sh remove<br>sudo rm /etc/init.d/windns.sh<br></code></pre></td></tr></table></figure></li></ol><h2 id="WSL开机自启"><a href="#WSL开机自启" class="headerlink" title="WSL开机自启"></a>WSL开机自启</h2><h2 id="Zsh设置Proxy"><a href="#Zsh设置Proxy" class="headerlink" title="Zsh设置Proxy"></a>Zsh设置Proxy</h2><p>首先输入<code>init_proxy</code>初始化代理，然后输入<code>config_proxy</code>对代理进行配置，在配置完毕最后，输入<code>proxy</code>应用代理</p><blockquote><p>Tips:如果不想继续使用代理了，可以使用<code>noproxy</code>来关闭代理，<code>zsh-proxy</code>代理了大部分，包括<code>git</code>、<code>npm</code>和<code>apt</code>等常用的工具。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行参数</title>
    <link href="/2021/10/29/main_argc_argv/"/>
    <url>/2021/10/29/main_argc_argv/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/LYJ_viviani/article/details/51873961">关于int main( int argc, char* argv[] ) 中arg和argv参数的解析及调试</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看一些代码的时候偶然看到自己刚开始学C的时候，<code>main()</code>函数中都会有一个<code>(int argc,char* argv[],char **env)</code>的传参。但是到现在依旧不理解这几个参数的意义和它们代表的作用，在稍微查阅了一下以后，浅显的总结一下。</p><h2 id="具体意义"><a href="#具体意义" class="headerlink" title="具体意义"></a>具体意义</h2><p>如果要使用<code>argc</code>和<code>argv</code>的话（<code>char **env</code>暂时没遇到，不做记录），只需要在<code>main</code>函数当中添加这两个参数即可，大致参考写法类似如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><code>argc</code>是一个整形的参数，代表了程序运行的时候发送给<code>main()</code>函数的参数个数。</p><p><code>argv</code>则是一个字符串的数组，用来指向存放对应参数的字符串。</p><p>其中，<code>argv[]</code>数组中的元素有<code>argc</code>个，并且有：</p><ul><li><code>argv[0]</code>包含的是程序运行的路径名字</li><li><code>argv[1]</code>包含的是程序命名后的第一个字符串</li><li><code>argv[2]</code>包含的是程序命名后的第二个字符串</li><li>….</li><li><code>argv[argc]</code>为NULL</li></ul><h2 id="演示方法"><a href="#演示方法" class="headerlink" title="演示方法"></a>演示方法</h2><p>为让以上解释更加形象，这里引入示例代码进行解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Argument&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; is &quot;</span>&lt;&lt;argv[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设代码文件存放于<code>./b.cpp</code>文件当中，通过编译器编译后的可执行文件为<code>b</code>。在执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./b<br></code></pre></td></tr></table></figure><p>返回的内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Argument0 is ./b<br></code></pre></td></tr></table></figure><p>在执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./b oneString twoString threeString<br></code></pre></td></tr></table></figure><p>返回的内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Argument0 is ./b<br>Argument1 is oneString<br>Argument2 is twoString<br>Argument3 is threeString<br></code></pre></td></tr></table></figure><p>对应了上文中的<code>argc</code>的元素个数和<code>argv</code>的字符串内容，即<code>./b</code>后面的<code>oneString</code>、<code>twoString</code>和<code>threeString</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oh My Zsh安装手册</title>
    <link href="/2021/10/22/Ubuntu-zsh/"/>
    <url>/2021/10/22/Ubuntu-zsh/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://segmentfault.com/a/1190000015283092">Ubuntu 下 Oh My Zsh 的最佳实践「安装及配置」 - SegmentFault 思否</a></li><li><a href="https://www.mokeyjay.com/archives/2685">用 zsh-proxy 一键配置常用代理</a></li></ul><h2 id="安装Oh-My-Zsh"><a href="#安装Oh-My-Zsh" class="headerlink" title="安装Oh My Zsh"></a>安装Oh My Zsh</h2><h3 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt install zsh -y<br>chsh -s /bin/zsh<br>echo $SHELL  ## 如果输出bash则需要重启SHELL<br></code></pre></td></tr></table></figure><h3 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh<br></code></pre></td></tr></table></figure><h2 id="Zsh的配置"><a href="#Zsh的配置" class="headerlink" title="Zsh的配置"></a>Zsh的配置</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体安装（Hack NF）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install fonts-hack<br></code></pre></td></tr></table></figure><p>其他字体：<a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis&#x2F;nerd-fonts</a></p><h3 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h3><ol><li><p>编辑zsh配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>修改主题（以agnoster为例）</p><p>将<code>ZSH_THEME=&quot;xxx&quot;</code>改为<code>ZSH_THEME=&quot;agnoster&quot;</code></p></li></ol><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><ol><li><p>安装<code>zsh-autosuggestions</code>、<code>zsh-syntax-highlighting</code>、<code>zsh-proxy</code>和<code>autojump</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br>git clone https://github.com/sukkaw/zsh-proxy.git ~/.oh-my-zsh/custom/plugins/zsh-proxy<br>sudo apt install autojump<br></code></pre></td></tr></table></figure></li><li><p>配置插件，编辑<code>.zshrc</code>文件，在<code>plugins</code>处添加，类似效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 根据官方文档，zsh-syntax-highlighting 插件需放在最后</span></span><br>plugins=(<br>  git extract autojump zsh-autosuggestions zsh-proxy zsh-syntax-highlighting <br>)<br></code></pre></td></tr></table></figure></li><li><p><code>zshrc</code>完整文件配置帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 以下内容去掉注释即可生效：</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 启动错误命令自动更正</span></span><br>ENABLE_CORRECTION=&quot;true&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br>COMPLETION_WAITING_DOTS=&quot;true&quot;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const限定符</title>
    <link href="/2021/10/21/const-cpp/"/>
    <url>/2021/10/21/const-cpp/</url>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><blockquote><p>总结自C++ Primer，仅供自己学习参考</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li><p>引用本身只是目标对象的一个别名，自己本身并不是对象</p></li><li><p>变量引用可以间接对变量进行修改</p></li><li><p>常量别名代表的<strong>只能是常量</strong>，如果常量别名一个变量，也是先通过创建一个<em>临时量</em>，然后对这个<em>临时量</em>创建别名</p></li><li><p>变量别名不能指向一个<strong>常量</strong>，也不能指向<em>运算后的值</em>后的结果，e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> pi = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PI = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">//当对象为变量时</span><br><span class="hljs-type">int</span> &amp;revPI = pi;  <span class="hljs-comment">//正确，变量的别名代表的是一个变量</span><br><span class="hljs-type">int</span> &amp;revPIt = pi *<span class="hljs-number">2</span>; <span class="hljs-comment">//错误，不能指向变量运算后的结果（即返回的是一个常量值）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cRevPI = pi; <span class="hljs-comment">//正确，常量别名可以指向一个变量，通过临时量代替</span><br><br><span class="hljs-comment">//当对象为常量时</span><br><span class="hljs-type">int</span> &amp;cstRevPI = PI; <span class="hljs-comment">//错误,变量别名必须指向一个变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cstcRevPI = PI;<span class="hljs-comment">//正确，常量别名可以指向一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>引用在<code>decltype</code>出并非是对象的同义词，而表示的是对应类型的引用</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">//x的类型是const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">//y的类型是const int&amp;，必须要设定为一个const int的引用</span><br><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">//错误，缺少引用代表的对象</span><br></code></pre></td></tr></table></figure><p> 而对于表达式，在使用<code>decltype</code>关键词的时候，由于表达式本身可以返回一个值，所以会被识别为一个引用类型</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">//错误，d是一个int&amp;，需要初始化</span><br><span class="hljs-keyword">decltype</span>(i) e; <span class="hljs-comment">//正确，e是一个int，没有初始化</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ol><li>指针本身是一个对象，其含义为指向目标对象的地址</li><li><code>void</code>指针可以指向任意一种变量代表的地址</li><li>常量指针<strong>必须初始化</strong>，其中通过const关键词有两种表达意思：<ul><li><code>int *const ptr</code>指的是<strong>常量指针，地址不可改变，指向一个<code>int</code>类型的变量</strong></li><li><code>const int *ptr</code>指的是<strong>常量的指针是常量类型，地址可改变，指向的是<code>const int</code>类型的常量</strong></li></ul></li><li>对于<code>*const</code>关键词修改的指针，虽然地址不能改变，但是依旧可以<strong>通过这个指针修改对应变量的值</strong>。</li></ol><h2 id="对于const限定符"><a href="#对于const限定符" class="headerlink" title="对于const限定符"></a>对于const限定符</h2><blockquote><p>顶层const：指针本身是一个常量</p><p>底层const：指针所指的对象是一个常量</p></blockquote><ul><li><p>对于顶层const中，在常量对象中的拷贝操作几乎不受什么影响</p></li><li><p>对于底层const中，只有两个对象有相同的底层const才能进行拷贝操作，举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> ci = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> cptr = &amp;i;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cptr2 = cptr <span class="hljs-comment">//正确，因为*cptr2和*cptr指向的都是常量的指针</span><br><span class="hljs-type">int</span> *p = p3; <span class="hljs-comment">//错误，因为*p不是指向常量的指针，所以不能拷贝p3</span><br></code></pre></td></tr></table></figure><p>其中对于引用也同样成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>;<br><br><span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">//由于ci本身是常量，和&amp;r代表的底层const不同，所以错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = ci; <span class="hljs-comment">//正确，底层const相同</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤Clash中Steam登入域名[无效]</title>
    <link href="/2021/10/05/Steam-forgepw-cfw/"/>
    <url>/2021/10/05/Steam-forgepw-cfw/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试后发现Steam会有几个固定的纯IP来次测试链接位置，只过滤域名并没有什么用</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>字太多可不看。</p></blockquote><p>在开启了Clash之后，经常会每次登入Steam都出现无法保存密码，需要重新输入密码的情况。出现这种情况的原因是因为Steam根据<code>store.steampowered.com</code>确定自己的位置，在开了加速器&#x2F;Clash之后，由于加速的原因经常出现大范围的IP变动，所以导致Steam需要重新输入密码来验证。解决问题的办法也很简单，只需要在Clash中添加规则让对应域名不走加速即可。</p><p>添加规则可以在自己手动订阅配置文件后一次一次添加，也可以通过<code>Clash For Windows</code>下的<code>parsers</code>配置修改来让每次配置文件更新的时候进行一个预处理，按自己的需求进行添加，具体操作可以参考：<a href="https://docs.cfw.lbyczf.com/contents/parser.html#%E7%89%88%E6%9C%AC%E8%A6%81%E6%B1%82">配置文件预处理 Clash for Windows</a></p><p>在<code>Clash For Windows</code>下的<code>Settings</code>当中的<code>System Proxy</code>里面有一个<code>Bypass Domain/IPNet</code>，但是我单纯设置成类似如下配置文件的时候发现无法生效，加上<code>Parsers</code>很简单就成功了，遂没有仔细研究，作罢。以下为<code>Parsers</code>的配置</p><h2 id="添加预处理规则"><a href="#添加预处理规则" class="headerlink" title="添加预处理规则"></a>添加预处理规则</h2><p>这篇博客主要只针对Steam登入的问题进行解决，不过同样可以举一反三适用于其他类似的需要预处理配置文件的场景。</p><h3 id="使用URL订阅"><a href="#使用URL订阅" class="headerlink" title="使用URL订阅"></a>使用URL订阅</h3><ol><li><p>打开<code>Clash For Windows</code>，打开<code>Settings</code>，找到<code>Profiles</code>的选项，其中有一条<code>Parsers</code>，右侧可以点击<code>Edit</code>进行编辑。</p></li><li><p>在<code>Edit</code>中参考如下配置进行编辑  <em><strong>注意缩进</strong></em></p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">parsers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-comment">#这里填入需要预处理的配置文件的URL订阅链接。</span><br>    <span class="hljs-attr">yaml:</span><br>      <span class="hljs-attr">prepend-rules:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">DOMAIN-SUFFIX,store.steampowered.com,🎯</span> <span class="hljs-string">全球直连</span><br></code></pre></td></tr></table></figure></li><li><p>重新启动Clash即可</p></li></ol><h3 id="使用本地配置文件"><a href="#使用本地配置文件" class="headerlink" title="使用本地配置文件"></a>使用本地配置文件</h3><ol><li><p>只需要在配置文件的<code>rules</code>下添加如下配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">DOMAIN-SUFFIX,store.steampowered.com,🎯</span> <span class="hljs-string">全球直连</span><br></code></pre></td></tr></table></figure></li><li><p>重启Clash</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scoop安装手册</title>
    <link href="/2021/10/04/Scoop-Install/"/>
    <url>/2021/10/04/Scoop-Install/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://sspai.com/post/52496">「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件</a></li><li><a href="https://p3terx.com/archives/scoop-the-best-windows-package-manager.html">Scoop - 最好用的 Windows 包管理器 - P3TERX ZONE</a></li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在知道并安装Scoop的时候只是稍微听说过<code>winget-cli</code>一类的工具，不过由于一直对Windows系统的软件管理早就绝望，下意识的认为对Windows来说，这种终端的程序管理应该几乎没什么用。但在前几天偶然希望在<code>Windows Terminal</code>上寻找一个类似<code>Linux</code>的<code>sudo</code>的程序，发现了Scoop这个神器，并且在使用了一两天尝到甜头后，决定写一篇博客把大概的使用功能都记录一下。</p><h2 id="Scoop的安装"><a href="#Scoop的安装" class="headerlink" title="Scoop的安装"></a>Scoop的安装</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>安装在联网的情况下有直接的指令，但是安装之前需要保证环境满足以下要求：</p><ul><li>Windows 的版本不低于 Windows 7</li><li>Windows 的 PowerShell 版本不低于 PowerShell 3</li><li>拥有能自由前往Github，保证传输稳定的网络环境</li><li>Windows的用户名为<strong>英文或者数字（非中文）用户名</strong></li></ul><h3 id="装前须知"><a href="#装前须知" class="headerlink" title="装前须知"></a>装前须知</h3><h4 id="默认安装路径"><a href="#默认安装路径" class="headerlink" title="默认安装路径"></a>默认安装路径</h4><p>Scoop默认情况下和Linux中一样，只有普通用户的权限，其中Scoop本身和他默认安装的软件，会安装在<code>%USERPROFILE\scoop</code>目录下，使用管理员权限进行全局安装的软件会在<code>C:\ProgramData\scoop</code>目录下。</p><h4 id="修改路径"><a href="#修改路径" class="headerlink" title="修改路径"></a>修改路径</h4><ol><li><p>打开<code>PowerShell</code></p></li><li><p>设置用户的安装路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP</span>=<span class="hljs-string">&#x27;\PathTo\&#x27;</span>  <span class="hljs-comment">## 这里填需要设置的路径</span><br>[<span class="hljs-type">Environment</span>]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env:SCOOP</span>, <span class="hljs-string">&#x27;User&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>设置全局安装的路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP_GLOBAL</span>=<span class="hljs-string">&#x27;\PathToGlobal\&#x27;</span>  <span class="hljs-comment">## 这里填需要设置的全局安装路径</span><br>[<span class="hljs-type">Environment</span>]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP_GLOBAL&#x27;</span>, <span class="hljs-variable">$env:SCOOP_GLOBAL</span>, <span class="hljs-string">&#x27;Machine&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>然后就可以开始愉快的安装了。</p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><ol><li><p>在PowerShell中输入以下内容，来保证本地脚本的执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">set-executionpolicy</span> remotesigned <span class="hljs-literal">-scope</span> currentuser<br></code></pre></td></tr></table></figure></li><li><p>用下面的命令来安装<code>Scoop</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">iex</span> (<span class="hljs-built_in">new-object</span> net.webclient).downloadstring(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>安装完成，可以通过以下指令来查询帮助</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop help<br></code></pre></td></tr></table></figure></li></ol><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>由于网络可能有的时候不稳定，大部分Scoop的软件在安装的时候可能会出现安装失败的情况，就需要我们自己手动进行代理的设置，设置代理的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop config proxy [<span class="hljs-type">IP</span>/<span class="hljs-type">DNS</span>]:[端口]<br></code></pre></td></tr></table></figure><h2 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h2><h3 id="常用需安装软件"><a href="#常用需安装软件" class="headerlink" title="常用需安装软件"></a>常用需安装软件</h3><ol><li><p>aria2</p><p>常用的强力下载工具，设置好<code>aria2</code>的<code>conf</code>文件并创建<code>session</code>文件，配合以下vbs脚本，创建快捷方式以后，在Win+R后运行<code>Shell:Common Startup</code>,将快捷方式放于其中，就可以当日用的下载工具了。</p><p>VBScript:</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>).Run <span class="hljs-string">&quot;aria2c.exe --conf-path=aria2.conf&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在安装完毕aria2后，scoop会默认用aria2来下载所有其他的软件，如果有的时候发现aria2下载不好使了，可以通过下面的指令来禁用aria2下载</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop config aria2<span class="hljs-literal">-enabled</span> false<br></code></pre></td></tr></table></figure><p>另外参考<code>P3TERX</code>大佬的博客中，其他选项可以按如下设置：</p><blockquote><p>单任务最大连接数设置为 <code>32</code>，单服务器最大连接数设置为 <code>16</code>，最小文件分片大小设置为 <code>1M</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;scoop config aria2<span class="hljs-operator">-split</span> <span class="hljs-number">32</span><br>&gt;scoop config aria2<span class="hljs-literal">-max-connection-per-server</span> <span class="hljs-number">16</span><br>&gt;scoop config aria2<span class="hljs-literal">-min-split-size</span> <span class="hljs-number">1</span>M<br></code></pre></td></tr></table></figure></blockquote></li><li><p>sudo</p><p>一个提权工具，可以让Windows下实现和Linux类似的提权效果</p></li><li><p>git</p><p>应该没啥好说的，必备安装。</p></li><li><p>nerd-fonts字体</p><p>在终端美化中常见的一种Powerline字体，使用以下指令添加库然后就能安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop bucket add nerd<span class="hljs-literal">-fonts</span><br></code></pre></td></tr></table></figure><p> 查询可以用的所有字体</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop search <span class="hljs-string">&quot;-NF&quot;</span><br></code></pre></td></tr></table></figure><p>因为安装字体需要管理员权限，所以需要添加sudo，指令如下（以Hack NF为例）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sudo scoop install Hack<span class="hljs-literal">-NF</span><br></code></pre></td></tr></table></figure></li><li><p>LANDrop 局域网文件分享</p><p>一个很好用的局域网文件共享工具，可以高速在不同系统平台之间分享文件。</p></li></ol><h3 id="查阅手册"><a href="#查阅手册" class="headerlink" title="查阅手册"></a>查阅手册</h3><p>大部分的使用帮助通过<code>scoop help</code>命令都可以直接列出并查看，常见的<code>search</code>、<code>install</code>、<code>update</code>和<code>uninstall</code>等指令不多做赘述。这里提供一些常见自己需要查阅的指令，以供日后使用参考。</p><blockquote><h4 id="清理安装包缓存"><a href="#清理安装包缓存" class="headerlink" title="清理安装包缓存"></a>清理安装包缓存</h4><p>Scoop 会保留下载的安装包，对于卸载后又想再安装的情况，不需要重复下载。但长期累积会占用大量的磁盘空间，如果用不到就成了垃圾。这时可以使用 <code>scoop cache</code> 命令来清理。</p><ul><li><code>scoop cache show</code> - 显示安装包缓存</li><li><code>scoop cache rm &lt;app&gt;</code> - 删除指定应用的安装包缓存</li><li><code>scoop cache rm *</code> - 删除所有的安装包缓存</li></ul><p>如果你不希望安装和更新软件时保留安装包缓存，可以加上 <code>-k</code> 或 <code>--no-cache</code> 选项来禁用缓存：</p><ul><li><code>scoop install -k &lt;app&gt;</code></li><li><code>scoop update -k *</code></li></ul><h4 id="删除旧版本软件"><a href="#删除旧版本软件" class="headerlink" title="删除旧版本软件"></a>删除旧版本软件</h4><p>当软件被更新后 Scoop 还会保留软件的旧版本，更新软件后可以通过 <code>scoop cleanup</code> 命令进行删除。</p><ul><li><code>scoop cleanup &lt;app&gt;</code> - 删除指定软件的旧版本</li><li><code>scoop cleanup *</code> - 删除所有软件的旧版本</li></ul><p>与安装软件一样，删除旧版本软件的同时也可以清理安装包缓存，同样是加上 <code>-k</code> 选项。</p><ul><li><code>scoop cleanup -k &lt;app&gt;</code> - 删除指定软件的旧版本并清除安装包缓存</li><li><code>scoop cleanup -k *</code> - 删除所有软件的旧版本并清除安装包缓存</li></ul><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><p>全局安装就是给系统中的所有用户都安装，且环境变量是系统变量，对于需要设置系统变量的一些软件就需要全局安装，比如 Node.js、Python ，否则某些情况会出现无法找到命令的问题。</p><p>使用 <code>scoop install &lt;app&gt;</code> 命令加上 <code>-g</code> 或 <code>--global</code> 选项可对软件进行全局安装，全局安装需要管理员权限，所以需要提前以管理员权限运行的 Pow­er­Shell 。更简单的方式是先安装 <code>sudo</code>，然后用 <code>sudo</code> 命令来提权执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">scoop install sudo<br>sudo scoop install -g &lt;app&gt;<br></code></pre></td></tr></table></figure><blockquote><p>达成在 Win­dows 上使用<code>sudo</code>的成就</p></blockquote><p>使用 <code>scoop list</code> 命令查看已装软件时，全局安装的软件末尾会有 <code>*global*</code> 标志。</p><p>此外对于全局软件的更新和卸载等其它操作，都需要加上 <code>-g</code> 选项：</p><ul><li><code>sudo scoop update -g *</code> - 更新所有软件（且包含全局软件）</li><li><code>sudo scoop uninstall -g &lt;app&gt;</code> - 卸载全局软件</li><li><code>sudo scoop uninstall -gp &lt;app&gt;</code> - 卸载全局软件（并删除配置文件）</li><li><code>sudo scoop cleanup -g *</code> - 删除所有全局软件的旧版本</li><li><code>sudo scoop cleanup -gk *</code> - 删除所有全局软件的旧版本（并清除安装包包缓存）</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows字体切换</title>
    <link href="/2021/10/03/Change-Font-Windows/"/>
    <url>/2021/10/03/Change-Font-Windows/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/Tatsu-syo/noMeiryoUI">Tatsu-syo&#x2F;noMeiryoUI</a></li><li><a href="https://www.zhihu.com/question/263863102/answer/1999360871">如何更换win10系统的字体</a></li></ol><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="通过noMeiryoUI进行修改（推荐）"><a href="#通过noMeiryoUI进行修改（推荐）" class="headerlink" title="通过noMeiryoUI进行修改（推荐）"></a>通过<code>noMeiryoUI</code>进行修改（推荐）</h3><ol><li>在网站上找到自己喜欢的字体，通常为<code>ttf</code>、<code>otf</code>或<code>fnt</code>等文件。</li><li>在<code>noMeiryoUI</code>的repo中下载该工具：<a href="https://github.com/Tatsu-syo/noMeiryoUI/releases">Tatsu-syo&#x2F;noMeiryoUI</a></li><li>解压后启动其中的<code>noMeiryoUI.exe</code>程序</li><li>选择自己想要的字体并更改，应用的时候可能会较为卡顿，耐心等待生效即可。</li></ol><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="通过命令行替换Windows官方字体达到应用自己字体的效果"><a href="#通过命令行替换Windows官方字体达到应用自己字体的效果" class="headerlink" title="通过命令行替换Windows官方字体达到应用自己字体的效果"></a>通过命令行替换Windows官方字体达到应用自己字体的效果</h3><p><em><strong>该方法存在一定风险，在替换Windows原本字体之前，请务必备份</strong></em></p><ol><li><p>下载自己想要用于替换的日用字体，并根据类型分别命名为<code>msyh.ttc</code>、<code>msyhbd.ttc</code>和<code>msyhl.ttc</code></p></li><li><p>在C盘根目录新建文件夹<code>TempFonts</code>用于临时存放需要替换的字体</p></li><li><p>打开Windows的设置，找到”更新与安全”-&gt;”恢复”-&gt;”高级启动”，在高级启动之后，选择”高级选项”，选择”命令提示符”，选择自己的帐号登入</p></li><li><p>输入以下指令，将C盘下<code>TempFonts</code>文件夹内的字体替换为系统默认字体。</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell">xcopy C:\TempFonts\* C:\Windows\Fonts\<br></code></pre></td></tr></table></figure><p>回车后按下A来全部覆盖替换（<em><strong>一定要备份好之前的系统文件再执行这一步</strong></em>）</p></li><li><p>输入<code>exit</code>回车后进入Windows系统，即可看到自己的字体应用生效，同理，如果想要将字体恢复，只需要用备份的字体文件进行覆盖操作即可。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Terminal个性化配置</title>
    <link href="/2021/09/18/Modify-Windows-Terminal/"/>
    <url>/2021/09/18/Modify-Windows-Terminal/</url>
    
    <content type="html"><![CDATA[<!-- markdownlint-disable MD033--><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://techcommunity.microsoft.com/t5/windows-powershell/how-to-install-and-update-powershell-6-one-liner/m-p/364948">[How to Install and Update PowerShell 6 - Thomas Maurer]</a></li><li><a href="https://blog.csdn.net/weixin_44490152/article/details/113854767">Windows Terminal + oh-my-posh模块美化官方教程集锦以及常见问题_想追头头の疾风的博客</a></li></ul><h2 id="更新PowerShell"><a href="#更新PowerShell" class="headerlink" title="更新PowerShell"></a>更新PowerShell</h2><p>​    更新PowerShell本身和Windows Terminal没啥直接关系，单纯做个提醒放一个一键更新指令在这里：</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">iex</span> <span class="hljs-string">&quot;&amp; &#123; <span class="hljs-variable">$</span>(irm https://aka.ms/install-powershell.ps1) &#125; -UseMSI&quot;</span><br></code></pre></td></tr></table></figure><p>这条命令的作用是安装最新版本的PowerShell，截至发博客为止可用于安装<code>PowerShell 7</code></p><h2 id="Windows-Terminal的安装-amp-美化"><a href="#Windows-Terminal的安装-amp-美化" class="headerlink" title="Windows Terminal的安装&amp;美化"></a>Windows Terminal的安装&amp;美化</h2><h3 id="Windows-Terminal安装"><a href="#Windows-Terminal安装" class="headerlink" title="Windows Terminal安装"></a>Windows Terminal安装</h3><ol><li>打开Microsoft Store</li><li>搜索<code>Windows Terminal</code></li><li>安装</li></ol><h2 id="Windows-Terminal的配置和使用"><a href="#Windows-Terminal的配置和使用" class="headerlink" title="Windows Terminal的配置和使用"></a>Windows Terminal的配置和使用</h2><h3 id="Windows-Terminal的使用"><a href="#Windows-Terminal的使用" class="headerlink" title="Windows Terminal的使用"></a>Windows Terminal的使用</h3><ul><li>在<code>Win+R</code>中输入<code>wt</code>回车即可呼出<code>Windows Terminal</code></li><li><code>Windows Terminal</code>中链接了一些Linux下可用的指令，诸如<code>ls</code>等</li><li>如果要在<code>Windows Terminal</code>下使用<code>vim</code>编辑器，只需要在安装了<code>Git</code>的前提下将<code>C:\Program Files\Git\usr\bin</code>设置为环境变量即可。(如果<code>Git</code>安装在其他目录下进行相对应的调整就好，设置好了以后重启一次<code>Windows Terminal</code>即可)</li></ul><h3 id="Windows-Terminal的个性化配置"><a href="#Windows-Terminal的个性化配置" class="headerlink" title="Windows Terminal的个性化配置"></a>Windows Terminal的个性化配置</h3><blockquote><p>如未特别说明，接下来将用<code>wt</code>作为<code>Windows Terminal</code>的简写</p></blockquote><p>注：本文个性化配置包括：</p><ul><li><p>修改<code>Windows Terminal</code>的配色</p></li><li><p>安装<code>posh-git</code>和<code>oh-my-posh</code></p></li><li><p>安装<code>Nerd Font</code>字体</p></li><li><p>配置<code>oh-my-posh</code>来修改<code>wt</code>的配色和样式</p></li></ul><p>不包括（以下设置在最新版的<code>wt</code>设置中已经包含）：</p><ul><li>毛玻璃和背景设置</li><li>光标形状、大小修改等</li></ul><h4 id="配色修改"><a href="#配色修改" class="headerlink" title="配色修改"></a>配色修改</h4><ol><li><p>在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes">mbadolato&#x2F;iTerm2-Color-Schemes</a>下滑，找到自己喜欢的配色的截图，在截图的左上方会有该配色的代号。</p></li><li><p>在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal">iTerm2-Color-Schemes&#x2F;windowsterminal</a>上找到配色对应的json文件并复制所有的内容。</p></li><li><p>在<code>wt</code>中打开设置，以下图为例：</p><img src="https://lsky.halc.top/usBZUT.png" alt="打开设置.png" style="zoom: 33%;" /></li><li><p>打开JSON设置，以图下为例：</p><img src="https://lsky.halc.top/2wqSOw.png" alt="打开JSON文件.png" style="zoom: 25%;" /></li><li><p>将刚刚复制的代码粘贴到有<code>scheme</code>字样的配置目录下，以下图为例：</p><img src="https://lsky.halc.top/N5CHPI.png" alt="添加主题.png" style="zoom: 33%;" /></li><li><p>保存后，回到<code>wt</code>的设置，选择平时主要使用的窗口界面（e.g.<code>PowerShell</code>）然后选择外观，然后选择自己添加的主题，以下图为例：</p><img src="https://lsky.halc.top/oCFtvM.png" alt="修改config" style="zoom: 25%;" /></li></ol><h4 id="安装-Nerd-Fonts-字体"><a href="#安装-Nerd-Fonts-字体" class="headerlink" title="安装 Nerd-Fonts 字体"></a>安装 Nerd-Fonts 字体</h4><blockquote><p>教程以<code>Hack NF</code>字体为例，如果需要使用其他字体请自行选择。</p></blockquote><ol><li><p>在这个页面下载的<code>Hack.zip</code>：</p><p><a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis&#x2F;nerd-fonts</a></p></li><li><p>解压<code>Hack.zip</code>，然后全选所有文件，右键点击安装</p></li><li><p>在<code>wt</code>中需要的终端，按<strong>配色修改</strong>第6步修改字体为<code>Hack NF</code>即可。</p></li></ol><h4 id="安装post-git和oh-my-posh"><a href="#安装post-git和oh-my-posh" class="headerlink" title="安装post-git和oh-my-posh"></a>安装post-git和oh-my-posh</h4><blockquote><p>以下教程需要电脑上安装了Git才能使用</p></blockquote><ol><li><p>使用<code>PowerShell</code>安装<code>post-git</code>和<code>oh-my-posh</code></p><p>指给当前用户(非Administrator)安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> CurrentUser<br><span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure><p>给所有用户安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> AllUsers<br><span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> <span class="hljs-literal">-Scope</span> AllUsers<br></code></pre></td></tr></table></figure></li><li><p>列出所有可用主题</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-PoshThemes</span><br></code></pre></td></tr></table></figure></li><li><p>找到自己喜欢的主题，然后使用指令预览（这里以spaceship为例）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-PoshPrompt</span> <span class="hljs-literal">-Theme</span> spaceship<br></code></pre></td></tr></table></figure></li><li><p>在预览结束以后，为了让主题每次启动都生效，需要创建一个脚本。</p><ol><li><p>输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>vim $profile<br></code></pre></td></tr></table></figure></li><li><p>按下按键i，进入插入模式，然后填入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Import-Module posh-git<br>Import-Module oh-my-posh<br>Set-PoshPrompt -Theme spaceship #[这里填你选的主题名字，用spaceship做示范]<br></code></pre></td></tr></table></figure></li><li><p>键盘键入<code>:wq</code>然后回车，代表保存并退出。</p></li></ol></li><li><p>重新启动<code>wt</code>即可看到自己个性化配置的<code>Windows Terminal</code>界面了。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL代理-尝试一</title>
    <link href="/2021/09/16/FireWall-WSL/"/>
    <url>/2021/09/16/FireWall-WSL/</url>
    
    <content type="html"><![CDATA[<h2 id="摘抄文章"><a href="#摘抄文章" class="headerlink" title="摘抄文章"></a>摘抄文章</h2><ul><li><a href="https://lengthmin.me/posts/wsl2-network-tricks/">WSL2 的一些网络访问问题</a></li></ul><h2 id="前置知识补充"><a href="#前置知识补充" class="headerlink" title="前置知识补充"></a>前置知识补充</h2><blockquote><ol><li>Windows 和 WSL2 算是在同一个局域网内，这个局域网是由 Hyper-V 创建的。</li><li>WSL2 使用的网络适配器是 ‘Default Hyper-V Switch’，这个适配器每次重启都会被删除重建，这就是 WSL2 为什么 IP 不固定的原因。</li><li>WSL2 内有些微软特意做的东西：</li></ol></blockquote><ol><li>向 <strong>WSL2 的 IP</strong> 发送的请求都会被转发到 <strong>Windows 的 IP</strong> 上，但是这个时灵时不灵。</li></ol><h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><h4 id="主机设置代理端口，WSL通过端口代理"><a href="#主机设置代理端口，WSL通过端口代理" class="headerlink" title="主机设置代理端口，WSL通过端口代理"></a>主机设置代理端口，WSL通过端口代理</h4><ol><li><p>首先需要获取到主机的IP，用以下指令可以达到获取ip的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">ip route | grep default | awk &#x27;&#123;print $3&#125;&#x27;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 或者</span></span><br>cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;<br></code></pre></td></tr></table></figure></li><li><p>通过上面的指令获取到主机的ip后，然后通过<code>shell</code>脚本手动设置代理即可。以下为在临时ssh中设置的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>host_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)<br>export ALL_PROXY=&quot;http://$host_ip:7890&quot;<br>echo $ALL_PROXY<br></code></pre></td></tr></table></figure><p>由于$host_ip是由<code>Hyper-V</code>的网卡自动分配的，每次可能会不一样，所以如果需要永久方案可以将以上脚本设置为wsl启时自启。</p></li></ol><h5 id="WSL防火墙配置"><a href="#WSL防火墙配置" class="headerlink" title="WSL防火墙配置"></a>WSL防火墙配置</h5><p>​    在部分时候可能会出现由于防火墙问题，代理设置无法生效，WSL无法访问主机的问题，这个时候可以通过以下指令来开放<code>vEthernet(WSL)</code>网卡的防火墙：</p><blockquote><p>感谢评论区 <a href="https://disqus.com/by/xing_fang/">Xing Fang</a> 以及 <a href="https://disqus.com/by/twinmegami/">twinmegami</a> 给的开放防火墙的命令。</p><p>命令来源：<a href="https://github.com/microsoft/WSL/issues/4585">https://github.com/microsoft/WSL/issues/4585</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;<span class="hljs-comment">## 直接放开 `vEthernet (WSL)` 这张网卡的防火墙</span><br>&gt;<span class="hljs-built_in">New-NetFirewallRule</span> <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;WSL&quot;</span> <span class="hljs-literal">-Direction</span> Inbound <span class="hljs-literal">-InterfaceAlias</span> <span class="hljs-string">&quot;vEthernet (WSL)&quot;</span> <span class="hljs-literal">-Action</span> Allow<br></code></pre></td></tr></table></figure></blockquote><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><blockquote><p>2021.12.6为止，CFW自己的0.19.0版本已经自带TUN的切换，无需使用mixin</p></blockquote><h4 id="通过Clash的TUN模式接管电脑所有软件的网络"><a href="#通过Clash的TUN模式接管电脑所有软件的网络" class="headerlink" title="通过Clash的TUN模式接管电脑所有软件的网络"></a>通过Clash的TUN模式接管电脑所有软件的网络</h4><blockquote><p>博客记录的是最新版本的Clash下通过mixin模式开启TUN模式的简单办法，具体操作仅供参考。</p></blockquote><ol><li><p>进入网站<a href="https://www.wintun.net/">Wintun</a>，点击界面中<code>Download Wintun xxx</code>下载压缩包，根据系统版本将对应目录中<code>wintun.dll</code>复制至<code>Home Directory</code>目录中。基于<code>x64</code>的处理器的<code>64</code>位操作系统请使用<code>amd64</code>版本，<code>32</code>位操作系统请使用<code>x86</code>版本</p></li><li><p>点击<code>General</code>中<code>Service Mode</code>右边<code>Manage</code>，在打开窗口中安装服务模式，安装完成应用会自动重启，Service Mode 右边地球图标变为<code>绿色</code>即安装成功</p><blockquote><p>以上两点来自于<a href="https://docs.cfw.lbyczf.com/contents/tun.html#windows">TUN 模式 Clash for Windows</a></p></blockquote></li><li><p>启用Clash中的<code>Mixin选项</code></p></li><li><p>在<code>Settings</code>中找到<code>Profile Mixin</code>，点击<code>YAML</code>边上的<code>Edit</code>，编辑为以下内容(<em><strong>注意缩进</strong></em>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">mixin: ## object<br>  dns:<br>    enable: true<br>    enhanced-mode: redir-host<br>    nameserver:<br>      - 1.1.1.1 ## 真实请求DNS，可多设置几个<br>      - 114.114.114.114<br>      - 8.8.8.8 <br><span class="hljs-meta prompt_">  #</span><span class="language-bash"><span class="hljs-comment"># interface-name: WLAN ## 出口网卡名称，或者使用下方的自动检测</span></span><br>  tun:<br>    enable: true<br>    stack: gvisor ## 使用 system 需要 Clash Premium 2021.05.08 及更高版本<br>    dns-hijack:<br>      - 198.18.0.2:53 ## 请勿更改<br>    auto-route: true<br>    auto-detect-interface: true ## 自动检测出口网卡<br></code></pre></td></tr></table></figure></li><li><p>保存后重启电脑，启动<code>System Proxy</code>以后在网络适配器能发现多了一个<code>Clash Tunnel</code>的网卡，并且<code>WSL</code>也不需要任何配置即可正常学习使用。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM学习手册</title>
    <link href="/2021/09/16/vimtutor/"/>
    <url>/2021/09/16/vimtutor/</url>
    
    <content type="html"><![CDATA[<!-- markdownlint-disable MD033--><h2 id="基础指导"><a href="#基础指导" class="headerlink" title="基础指导"></a>基础指导</h2><h3 id="第一讲小节"><a href="#第一讲小节" class="headerlink" title="第一讲小节"></a>第一讲小节</h3><ol><li><p>光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。<br>h (左移)       j (下行)       k (上行)     l (右移)</p></li><li><p>欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt;</p></li><li><p>欲退出 Vim 编辑器，请输入 <ESC>   :q!   &lt;回车&gt; 放弃所有改动。<br>             或者输入 <ESC>   :wq   &lt;回车&gt; 保存改动。</p></li><li><p>在正常模式下删除光标所在位置的字符，请按： x</p></li><li><p>欲插入或添加文本，请输入：</p><div class="code-wrapper"><pre><code class="hljs">i   输入欲插入文本   &lt;ESC&gt;             在光标前插入文本A   输入欲添加文本   &lt;ESC&gt;             在一行后添加文本</code></pre></div></li></ol><p>特别提示：按下 <ESC> 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。</p><h3 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h3><ol><li>欲从当前光标删除至下一个单词，请输入：<code>dw</code></li><li>欲从当前光标删除至当前行末尾，请输入：<code>d$</code></li><li>欲删除整行，请输入：<code>dd</code></li><li>欲重复一个动作，请在它前面加上一个数字：<code>2w</code></li><li>在正常模式下修改命令的格式是：<br>      operator   [number]   motion<br>其中：<br>  operator - 操作符，代表要做的事情，比如 d 代表删除<br>  [number] - 可以附加的数字，代表动作重复的次数<br>  motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，<br>         $ 代表行末等等。<ol start="6"><li>欲移动光标到行首，请按数字0键：0</li></ol></li><li>欲撤消以前的操作，请输入：u (小写的u)<br>欲撤消在一行中所做的改动，请输入：U (大写的U)<br>欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R</li></ol><h3 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h3><ol><li><p>要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除<br>的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置<br>于当前光标所在行的下一行。</p></li><li><p>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字<br>符即可。</p></li><li><p>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。<br>比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当<br>前光标到行末的内容。</p></li><li><p>更改类命令的格式是：</p><div class="code-wrapper"><pre><code class="hljs">c   [number]   motion</code></pre></div></li></ol><h3 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h3><ol><li>CTRL-G 用于显示当前光标所在位置和文件状态信息。<br>G 用于将光标跳转至文件最后一行。<br>先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。<br>gg 用于将光标跳转至文件第一行。</li><li>输入 &#x2F; 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查<br>找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br>CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。<ol start="3"><li>如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。</li></ol></li><li>在一行内替换头一个字符串 old 为新的字符串 new，请输入  :s&#x2F;old&#x2F;new<br>在一行内替换所有的字符串 old 为新的字符串 new，请输入  :s&#x2F;old&#x2F;new&#x2F;g<br>在两行内替换所有的字符串 old 为新的字符串 new，请输入  :#,#s&#x2F;old&#x2F;new&#x2F;g<br>在文件内替换所有的字符串 old 为新的字符串 new，请输入  :%s&#x2F;old&#x2F;new&#x2F;g<br>进行全文替换时询问用户确认每个替换需添加 c 标志        :%s&#x2F;old&#x2F;new&#x2F;gc</li></ol><h3 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h3><ol><li><p>:!command 用于执行一个外部命令 command。</p><p>请看一些实际例子：</p><div class="code-wrapper"><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">(MS-DOS)         (Unix)<br>:!dir            :!ls            -  用于显示当前目录的内容。<br>:!del FILENAME   :!rm FILENAME   -  用于删除名为 FILENAME 的文件。<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>:w FILENAME</code>  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文<br>件中。</p></li><li><p><code>v motion :w FILENAME</code> 可将当前编辑文件中可视模式下选中的内容保存到文件<br>FILENAME 中。</p></li><li><p><code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置<br>后面。</p></li><li><p><code>:r !dir</code> 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</p></li></ol><h3 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h3><ol><li><p>输入小写的 o 可以在光标下方打开新的一行并进入插入模式。<br>输入大写的 O 可以在光标上方打开新的一行。</p></li><li><p>输入小写的 a 可以在光标所在位置之后插入文本。<br>输入大写的 A 可以在光标所在行的行末之后插入文本。</p><ol start="3"><li>e 命令可以使光标移动到单词末尾。</li><li>操作符 y 复制文本，p 粘贴先前复制的文本。</li><li>输入大写的 R 将进入替换模式，直至按 <ESC> 键回到正常模式。</li><li>输入 :help 或者按 <F1> 键或 <Help> 键可以打开帮助窗口。</li></ol></li><li><p>输入 :help cmd 可以找到关于 cmd 命令的帮助。</p></li><li><p>输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。</p></li><li><p>输入 :q 以关闭帮助窗口</p></li><li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p></li><li><p>当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。<br>按 <TAB> 可以使用一个补全。输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：<br>‘ic’ ‘ignorecase’       查找时忽略字母大小写<br>‘is’ ‘incsearch’        查找短语时显示部分匹配<br>‘hls’ ‘hlsearch’        高亮显示所有的匹配短语<br>选项名可以用完整版本，也可以用缩略版本。</p><ol start="12"><li>在选项前加上 no 可以关闭选项：  :set noic</li></ol></li></ol><h3 id="第七讲小结"><a href="#第七讲小结" class="headerlink" title="第七讲小结"></a>第七讲小结</h3><ol><li><p>输入 :help 或者按 <F1> 键或 <Help> 键可以打开帮助窗口。</p></li><li><p>输入 :help cmd 可以找到关于 cmd 命令的帮助。</p></li><li><p>输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。</p></li><li><p>输入 :q 以关闭帮助窗口</p></li><li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p></li><li><p>当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。<br>按 <TAB> 可以使用一个补全。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroNSD搭建引导</title>
    <link href="/2021/09/09/ZeroNSD-Setup/"/>
    <url>/2021/09/09/ZeroNSD-Setup/</url>
    
    <content type="html"><![CDATA[<h2 id="翻译来源"><a href="#翻译来源" class="headerlink" title="翻译来源"></a>翻译来源</h2><ul><li><a href="https://github.com/zerotier/zeronsd/blob/main/docs/quickstart.md">zeronsd&#x2F;quickstart.md</a></li></ul><blockquote><p>翻译的时间为2021-9-9，其中部分内容有删改，只提取了主观认为有用的信息，仅供参考</p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>这个功能目前还在Beta测试当中</li><li>这个功能将会内嵌在未来将出现的<code>ZeroTier 2.0</code>当中，不过目前它是一个独立的软件</li><li>接下来的步骤将会有一定困难</li></ol><h3 id="概念须知"><a href="#概念须知" class="headerlink" title="概念须知"></a>概念须知</h3><ol><li>当<code>ZeroTier</code>加入了一个网络后，它将会创建一个虚拟网口</li><li>当<code>ZeroTier</code>加入了多个网络后，也会有多个虚拟网口</li><li>当<code>ZeroNSD</code>启动了之后，它将绑定在某一个特定的网口上</li><li>如果你需要对多个网络都使用<code>ZeroNSD</code>，那你也需要创建多个<code>ZeroNSD</code>服务绑定在它对应的网口上</li></ol><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>​    该教程使用了两台不同的机器，一台是在云上的Ubuntu虚拟机，另外一台为Windows笔记本，如果要跟着来完成这个快速上手，最好使用相同的平台，如果使用了不同的平台，你最好要有能力弄清楚自己要做什么。</p><h2 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h2><h3 id="ZeroTier-网络创建"><a href="#ZeroTier-网络创建" class="headerlink" title="ZeroTier 网络创建"></a>ZeroTier 网络创建</h3><ol><li><p>按正常流程创建、链接并授权一个以在<a href="my.zerotier.com">ZeroTier官网</a>创建的<code>network</code></p></li><li><p>在自己的帐号的<code>Account</code>页面下创见一个新的<code>API Token</code>，<code>ZeroNSD</code>将会利用这个<code>token</code>来获取对应网络下设备的不同名字，来达到自动分配dns的效果。</p></li><li><p>创建一个文件来让<code>ZeroNSD</code>能够以文件的方式读取<code>token</code>，参考指令如下 <strong>需要修改token为自己的token</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo bash -c &quot;echo ZEROTIER_CENTRAL_TOKEN &gt; /var/lib/zerotier-one/token&quot;<br>sudo chown zerotier-one:zerotier-one /var/lib/zerotier-one/token<br>sudo chmod 600 /var/lib/zerotier-one/token<br></code></pre></td></tr></table></figure></li><li><p>安装<code>ZeroTier</code>的进程管理应用</p><p><code>zerotier-systemd-manager</code>的<code>rpm</code>和<code>deb</code>安装包发布在这个网站：<a href="https://github.com/zerotier/zerotier-systemd-manager/releases">https://github.com/zerotier/zerotier-systemd-manager/releases</a>，请自行替换下面指令为最新的安装包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/zerotier/zerotier-systemd-manager/releases/download/v0.2.1/zerotier-systemd-manager_0.2.1_linux_amd64.deb<br>sudo dpkg -i zerotier-systemd-manager_0.2.1_linux_amd64.deb<br></code></pre></td></tr></table></figure></li><li><p>重启所有的ZeroTier服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart zerotier-one<br>sudo systemctl enable zerotier-systemd-manager.timer<br>sudo systemctl start zerotier-systemd-manager.timer<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装ZeroNSD"><a href="#安装ZeroNSD" class="headerlink" title="安装ZeroNSD"></a>安装ZeroNSD</h3><blockquote><p>ZeroNSD针对每一个网络需要都创建一个独立的服务，对DNS来说延迟是很敏感的，所以最好让客户端和服务端尽可能接近</p></blockquote><ol><li><p>安装<code>ZeroNSD</code>，它的安装包发布在<a href="https://github.com/zerotier/zeronsd/releases">这里</a>，请自行替换下面指令为最新的安装包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/zerotier/zeronsd/releases/download/v0.1.7/zeronsd_0.1.7_amd64.deb<br>sudo dpkg -i zeronsd_0.1.7_amd64.deb<br></code></pre></td></tr></table></figure><blockquote><p>如果默认发布的地方没有对应平台的安装包，可以通过Cargo自行编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo /usr/bin/apt-get -y install net-tools librust-openssl-dev pkg-config cargo</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo /usr/bin/cargo install zeronsd --root /usr/local</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>对于你希望启用DNS服务的网络，执行类似以下的命令：</p><blockquote><p><code>/var/lib/zerotier-one/token</code>为token文件所在路径 （在上文设置token中有提及）</p><p><code>beyond.corp</code>为你希望的域名后缀</p><p><code>af78bf94364e2035</code>为你自己的网络ID</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zeronsd supervise -t /var/lib/zerotier-one/token -w -d beyond.corp af78bf94364e2035<br>sudo systemctl start zeronsd-af78bf94364e2035<br>sudo systemctl enable zeronsd-af78bf94364e2035<br></code></pre></td></tr></table></figure></li></ol><h3 id="检查可用性"><a href="#检查可用性" class="headerlink" title="检查可用性"></a>检查可用性</h3><h4 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h4><ul><li>服务器需要开放53端口，让客户端可以请求到DNS</li><li>客户端需要启用<code>Allow DNS</code>的选项（安卓等平台默认启用，可以无视）</li></ul><h4 id="连通性检查"><a href="#连通性检查" class="headerlink" title="连通性检查"></a>连通性检查</h4><p>​    假设笔记本的设备名为<code>laptop</code>，那么此时就可以通过设备名和dns后缀<code>ping</code>通设备了（不考虑防火墙）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">PS C:\Users\AzureBird&gt; ping laptop.beyond.corp<br><br>正在 Ping zephy.sak [172.28.120.138] 具有 32 字节的数据:<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br></code></pre></td></tr></table></figure><h4 id="指令更新"><a href="#指令更新" class="headerlink" title="指令更新"></a>指令更新</h4><p>​    如果后续需要更新配置（比如TLD），使用类似如下指令即可。（记得修改为自己设置的ID等参数）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zeronsd supervise -t /var/lib/zerotier-one/token -w -d beyond.corp af78bf94364e2035<br>sudo systemctl daemon-reload<br>sudo systemctl enable zeronsd-af78bf94364e2035<br></code></pre></td></tr></table></figure><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>​    <code>ZeroNSD</code>还可以添加本地的<code>hosts</code>作为私有的DNS服务，不过由于该部分内容并不复杂，且属于进阶内容，故不做教程，此贴仅作入门参考使用的快速手册。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier广播局域网游戏</title>
    <link href="/2021/08/30/VLan-ZeroTier-Gaming/"/>
    <url>/2021/08/30/VLan-ZeroTier-Gaming/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    经常能遇到需要和朋友联机玩一些P2P的联机游戏，但游戏服务器总是因为各种原因延迟很高或者连不上的情况。在使用诸如<code>ZeroTier</code>等一类软件进行组网的时候，在此给出能够让<code>Windows</code>提高虚拟网卡的优先级，让游戏能够在一些无法输入IP的游戏中扫描到同一虚拟局域网下用户的方法。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="创建ZeroTier网络"><a href="#创建ZeroTier网络" class="headerlink" title="创建ZeroTier网络"></a>创建ZeroTier网络</h3><blockquote><p>在谷歌搜索“创建<code>ZeroTier</code>网络”关键词即可找到许多对应教程，在此不多赘述</p><p>在有条件的情况下，可以自己搭建<code>Moon中转</code>节点来加速（非必须），教程：<a href="https://halc.top/2021/03/24/Moon-Server-of-ZeroTier.html">ZeroTier下Moon服务器的搭建</a></p></blockquote><h3 id="修改Windows设置"><a href="#修改Windows设置" class="headerlink" title="修改Windows设置"></a>修改Windows设置</h3><blockquote><p>该教程以Windows10为例，其他版本的Windows可参考设置</p></blockquote><ol><li><p>在电脑右下角打开“<strong>网络和Internet</strong>”选项</p><p><img src="https://lsky.halc.top/ugjV37.png" alt="网络和Internet"></p></li><li><p>打开”<strong>更改适配器选项</strong>“</p><p><img src="https://lsky.halc.top/YWTNFt.png" alt="更改适配器选项"></p></li><li><p>打开对应ZeroTier的ID的网络属性</p><p><img src="https://lsky.halc.top/g5rAT1.png" alt="网络属性"></p></li><li><p>打开”<strong>Internet 协议版本 4</strong>“下的”<strong>属性</strong>“</p><p><img src="https://lsky.halc.top/IzcDwA.png" alt="IPv4的属性"></p></li><li><p>打开属性中的“<strong>高级</strong>”</p><p><img src="https://lsky.halc.top/LTDPHO.png" alt="高级"></p></li><li><p>修改自动跃点</p><blockquote><p>​    自动跃点的修改就笔者目前看来对日常使用影响不大，介意的可以在和好友联机结束以后重新勾选即可。并且由测试来看，只要重新连接了网络，Windows都会设置回为“自动跃点”</p></blockquote><p>   <img src="https://lsky.halc.top/wE5fPt.png" alt="自动跃点"></p><blockquote><p>将优先级设置为1如果不放心的话可以设置为小一点的数字，不过也许有概率无法自动扫描局域网内其他游戏玩家。</p></blockquote></li></ol><h2 id="游戏内"><a href="#游戏内" class="headerlink" title="游戏内"></a>游戏内</h2><p>   ​     在进行了上面的操作，并且两个用户都处于同一ZeroTier的网络下之后，直接打开游戏存档并进入，应该就能在局域网联机中自动扫描到对方。目前已经测试的游戏有：无主之地3、GTFO等，理论上所有可以使用局域网加入的游戏应该都能用相同的方法进行操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AdGuardHome与OpenClash兼容配置</title>
    <link href="/2021/08/06/AdGuardHome_Openclash/"/>
    <url>/2021/08/06/AdGuardHome_Openclash/</url>
    
    <content type="html"><![CDATA[<h2 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h2><blockquote><p>参考<a href="https://github.com/vernesong/OpenClash/issues/99">结合adguard home 使用 DNS 设置求教 · Issue #99</a>中hankclc和icyleaf的回答，总结一下设置步骤作为参考</p></blockquote><ol><li><p>将AdGuard Home的上游DNS设置为OpenClash的DNS地址</p><blockquote><p>OpenClash的DNS地址可以在全局设置中看到，一般为<code>127.0.0.1:7874</code></p></blockquote></li><li><p>关闭OpenClash的本地DNS劫持</p></li><li><p>AdGuard Home的重定向模式选择使用53端口替换dnsmasq</p></li></ol><p><em><strong>OpenClash不要用TUN或TUN混合模式（还未自己测试）</strong></em></p>]]></content>
    
    
    
    <tags>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rclone同步脚本[作废]</title>
    <link href="/2021/08/05/Shell_Study_Backup/"/>
    <url>/2021/08/05/Shell_Study_Backup/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大半年回头看发现好多需求都是自己太无知了…文件校验这种东西在Rclone或者Rsync都已经有了，而且Rclone本身也有sync的功能。</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>​    在家中自己搭建了一个<code>Seafile</code>同步服务器后，总是不太放心里面的数据安全。在发现了<code>Github</code>上有人写了最新不限速的阿里云盘的<code>WebDav</code>实现之后，就萌生了用<code>WebDav</code>配合<code>Shell脚本</code>以及<code>Sync</code>、<code>Rclone</code>三个工具实现“本地一份”和“云端一份”的备份方式。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><ul><li>存储了<code>Seafile</code>服务的主硬盘A</li><li>家中闲置的硬盘B</li><li>阿里云盘</li></ul><h3 id="备份方案"><a href="#备份方案" class="headerlink" title="备份方案"></a>备份方案</h3><p>​    通过<code>crontab</code>来实现计划任务，计划每天凌晨的时候通过<code>Sync</code>把主硬盘A中的数据镜像存储在闲置硬盘B中，作为一个本地紧急恢复的拷贝，同时因为<code>Seafile</code>储存了重要的密码信息，为了避免丢失，每个礼拜会将硬盘B中的数据先通过<code>7zip</code>工具进行压缩，压缩后通过自定义脚本上传到云端服务器，并且检查云端的<code>SHA1</code>确保数据完好无误。</p><blockquote><p>最开始的方案其实是通过Rclone的Sync来备份Seafile中的文件的，但是在实战后发现由于Seafile的文件大多是小体量的数据块，在文件太多的时候出于未知原因，无法直接将整个所有的文件夹下载下来用于备份，考虑到云端备份用到的概率较低，也不太需要实时读取，所以采用了先压缩后上传的方式备份。</p></blockquote><h2 id="主要难点"><a href="#主要难点" class="headerlink" title="主要难点"></a>主要难点</h2><ul><li><strong>对于<code>Shell</code>语法生疏</strong></li><li><code>Rclone</code>不熟悉</li><li>远端文件的<code>SHA1</code>获取</li><li><del>移动突然这几天把家里300M上行的网络限速到稳定30M不到，每次想测试大文件备份就要等半天</del></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>安装<code>Rsync</code>和<code>Rclone</code></p><blockquote><p>直接通过包管理器直接安装即可</p></blockquote></li><li><p>通过<code>crontab</code>设置<code>Rsync</code>的同步脚本，在每天凌晨的时候将硬盘A的数据备份至硬盘B中，其中忽略不重要的<code>.log</code>等文件，类似指令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete --exclude=&#x27;*.log*&#x27; /opt/seafile-data /opt/seafile-mysql /opt/seafile-elasticsearch /mnt/files/Seafile<br></code></pre></td></tr></table></figure><blockquote><p>关于如何使用<code>Rsync</code>在之前的博客有发：<a href="https://halc.top/2021/08/04/Rsync_Manual.html">Rsync学习记录</a></p></blockquote></li><li><p>通过<code>Docker</code>部署阿里云盘的<code>WebDav</code>，使用的库来源于：<a href="https://github.com/zxbu/webdav-aliyundriver">zxbu&#x2F;webdav-aliyundriver：的webdav协议开源实现</a></p><blockquote><p><code>Docker</code>的使用之前的博客有发：<a href="https://halc.top/2021/07/22/Docker-Command.html">Docker使用手册</a></p></blockquote></li><li><p>通过指令配置Rclone，对文件进行直接上传、下载、检查等操作</p><blockquote><p><code>Rclone</code>的学习使用还未出炉，先TODO，这里跳过具体操作，直接假设已经配置好了一个config为Aliyun</p></blockquote></li><li><p>编写对应的<code>Shell</code>脚本来做到上传和校对的工作，同样通过<code>crontab</code>定时执行，脚本如下：</p><p><strong>如果要使用脚本，先确定自己<code>Rclone</code>已经挂载，并且脚本内的<code>Rclone的信息</code>正确配置为自己需要的内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 忽略echo和printf的提醒</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># shellcheck disable=SC3000-SC4000</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">######################################################################</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  作者: HalcyonAzure</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  时间: 2021-8-5</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  将自定义目录下的文件夹打包，并上传到Rclone配置服务器中，并在上传完成后校验SHA1值</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  成功：本地打包文件删除，只保留远端文件</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  失败：删除远端文件，并重试三次，没有成功将保留本地文件，删除远端错误文件</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">######################################################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 彩色字体</span></span><br>Green_font_prefix=&quot;\033[32m&quot; &amp;&amp; Red_font_prefix=&quot;\033[31m&quot; &amp;&amp; Font_color_suffix=&quot;\033[0m&quot;<br>Info=&quot;$&#123;Green_font_prefix&#125;[信息]$&#123;Font_color_suffix&#125;&quot;<br>Error=&quot;$&#123;Red_font_prefix&#125;[错误]$&#123;Font_color_suffix&#125;&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"></span><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Rclone的信息</span></span><br>RcloneConfig=&quot;Aliyun&quot;<br>RemotePath=&quot;/Backup/Test&quot;<br>BackupPath=&quot;/mnt/files&quot;<br>BackupFolder=&quot;backup_test&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 备份的压缩包名字</span></span><br>BackupZip=&quot;$&#123;BackupFolder&#125;-$(date +%F-%H-%M).7z&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 压缩备份路径</span></span><br>7za a -t7z -r &quot;$BackupPath&quot;/&quot;$BackupZip&quot; &quot;$BackupPath&quot;/&quot;$BackupFolder&quot;<br>echo -e &quot;$&#123;Info&#125;文件压缩完毕&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 生成文件的sha1文件</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># sha1sum &quot;$BackupZip&quot; &gt;&quot;$BackupZip&quot;.sha1</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 将文件转移到Rclone中</span></span><br>Upload_Bak() &#123;<br>    echo -e &quot;$&#123;Info&#125;开始上传...&quot;<br>    ## retries是指上传失败以后重试的次数，Buffer-size是缓存，这里可以调小一点，512M为示例<br>    if ! rclone copy --retries=1 --buffer-size=512M &quot;$BackupPath&quot;/&quot;$BackupZip&quot; &quot;$RcloneConfig:$RemotePath&quot;; then<br>        echo -e &quot;$&#123;Error&#125;上传失败!&quot;<br>        exit 1<br>    fi<br>    echo -e &quot;$&#123;Info&#125;上传文件成功，3s后开始校验信息&quot;<br>    ## 停止3s，避免因为频繁使用io被禁用<br>    sleep 3s<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 尝试次数初始化</span></span><br>TryCounters=1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">校验转移后文件的sha1值是否符合，只会尝试三次，否则退出脚本（zxbu的库中WebDav不校验文件）</span><br>Check_Sha1() &#123;<br>    ## 生成校验信息<br>    echo -e &quot;$&#123;Info&#125;开始校验信息...&quot;<br>    LocalSHA1=&quot;$(sha1sum &quot;$BackupPath&quot;/&quot;$BackupZip&quot;)&quot;<br>    LocalSHA1=&quot;$&#123;LocalSHA1:0:39&#125;&quot;<br>    echo -e &quot;$&#123;Info&#125;本地校验信息：$LocalSHA1&quot;<br>    RemoteSHA1=&quot;$(rclone sha1sum &quot;$RcloneConfig&quot;:&quot;$RemotePath&quot;/&quot;$BackupZip&quot; --download)&quot;<br>    RemoteSHA1=&quot;$&#123;RemoteSHA1:0:39&#125;&quot;<br>    echo -e &quot;$&#123;Info&#125;远端校验信息：$RemoteSHA1&quot;<br>    ## 对比校验信息<br>    if [ &quot;$LocalSHA1&quot; = &quot;$RemoteSHA1&quot; ]; then<br>        #删除本地的备份文件<br>        rm &quot;$BackupPath&quot;/&quot;$BackupZip&quot;<br>        echo -e &quot;$&#123;Info&#125;校验成功！删除本地备份&quot;<br>    else<br>        echo -e &quot;$&#123;Error&#125;上传校验失败，删除远端文件并重新上传&quot;<br>        echo -e &quot;$&#123;Info&#125;开始删除文件&quot;<br>        rclone delete &quot;$RcloneConfig&quot;:&quot;$RemotePath&quot;/&quot;$BackupZip&quot;<br>        echo -e &quot;$&#123;Info&#125;删除完毕，3s后开始进行重新上传&quot;<br>        sleep 3s<br>        #删除远端的备份文件，并且重新上传后检查sha1<br>        TryCounters=$((TryCounters + 1))<br>        if [ $TryCounters -gt 3 ]; then<br>            echo -e &quot;$&#123;Error&#125;上传三次均失败，请检查网络环境&quot;<br>            exit 3<br>        else<br>            echo -e &quot;$&#123;Info&#125;开始第$&#123;TryCounters&#125;次上传&quot;<br>            Upload_Bak<br>            Check_Sha1<br>        fi<br>    fi<br>&#125;<br><br>Upload_Bak<br>Check_Sha1<br><br>echo -e &quot;$&#123;Info&#125;备份脚本完成&quot;<br>exit 0<br></code></pre></td></tr></table></figure><blockquote><p>Shell大概看了两三天的时间，里面有些格式和规范还需要调整，日后再对脚本进行优化一下</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rsync手册</title>
    <link href="/2021/08/04/Rsync_Manual/"/>
    <url>/2021/08/04/Rsync_Manual/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程</a></li><li><a href="https://www.jianshu.com/p/b0157e4ab801">RSYNC备份服务</a></li></ol><h2 id="Rsync介绍"><a href="#Rsync介绍" class="headerlink" title="Rsync介绍"></a>Rsync介绍</h2><p>​    Remote-Sync，意味远程动态同步，可以在不同的主机之间进行同步操作，相比一般将文件一次性全部备份而不同的好处是，Rsync可以做到每次增量同步，只对部分文件进行修改，目前个人主要用来和<code>WebDAV</code>挂载的本地目录进行配合使用，对服务器进行备份处理</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><ul><li><p>增量同步</p>  <figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">rsync -avz [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># [SRC]为源目录</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># [DEST]为目标目录</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -a：优于-r的递归参数，会同步文件的元信息（时间和权限等，在增量更新中有重要作用）</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -v：将结果或过程打印在控制台内</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -z 同步时压缩数据</span></span><br></code></pre></td></tr></table></figure></li><li><p>镜像同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># --delete：当检测到源文件中某个文件被删除的同时，将删除操作也同样进行同步，变成目标镜像</span></span><br></code></pre></td></tr></table></figure></li><li><p>排除文件</p><blockquote><p>这里以排除掉所有带<code>.log</code>字样的文件为例</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete --exclude &#x27;*.log&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># --exclude为字符过滤，其中这个过滤也包括了隐藏文件</span></span><br></code></pre></td></tr></table></figure><p>当有多个排除模式的时候，可以使用多个<code>--exclude</code>参数，也可以使用<code>Bash</code>的大括号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用多个--exclude参数</span></span><br>rsync -avz --delete --exclude &#x27;*.log&#x27; &#x27;*.txt&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用Bash</span></span><br>rsync -avz --delete --exclude=&#123;&#x27;*.log&#x27;,&#x27;*.txt&#x27;&#125; [SRC] [DEST]<br></code></pre></td></tr></table></figure><p>排除隐藏文件，以及排除目录中所有文件的同时保存目录本身</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 排除隐藏文件，在Linux中即类似`.ssh`一类以&#x27;.&#x27;开头的文件，这个时候忽略&#x27;.*&#x27;即可</span></span><br>rsync -avz --delete --exclude &#x27;.*&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 排除目录中所有文件的同时保存目录本身</span></span><br>rsync -avz --delete --exclude &#x27;dir/*&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 可以做到保存dir目录的同时，不保存dir下的所有文件</span></span><br></code></pre></td></tr></table></figure><p>排除的同时又强制锁定</p><blockquote><p>如果需要排除所有”*.log”的同时，又希望保存所有demo.log的文件，则可以配合<code>--include</code>参数一起使用，以下为例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete --include=&quot;demo.log&quot; --exclude=&quot;*.log&quot; [SRC] [DEST]<br></code></pre></td></tr></table></figure></li></ul><h3 id="远程使用"><a href="#远程使用" class="headerlink" title="远程使用"></a>远程使用</h3><p>TODO</p><h2 id="基准目录备份"><a href="#基准目录备份" class="headerlink" title="基准目录备份"></a>基准目录备份</h2><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置init.d开机自启</title>
    <link href="/2021/08/04/Ubuntu_Startup/"/>
    <url>/2021/08/04/Ubuntu_Startup/</url>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>创建脚本文件，这里以<code>startup.sh</code>示例</p></li><li><p>给脚本添加可执行权限，并移动脚本位置</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">chmod +x startup.sh<br>sudo mv startup.sh /etc/init.d/<br></code></pre></td></tr></table></figure></li><li><p>设置为开机脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d /etc/init.d/startup.sh defaults 100<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 这里的100指的是脚本的优先级，数字越大执行越晚，可以为0</span></span><br></code></pre></td></tr></table></figure><p>如果需要删除脚本，用<code>remove</code>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d /etc/init.d/startup.sh remove<br>sudo rm /etc/init.d/startup.sh<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器内操作</title>
    <link href="/2021/08/02/Docker_Insert/"/>
    <url>/2021/08/02/Docker_Insert/</url>
    
    <content type="html"><![CDATA[<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><ol><li><p>使用<code>docker exec -it</code>命令进入容器（推荐）</p><p>假设操作的容器ID为<code>icontainer</code>，如果想要进入<code>icontainer</code>执行指令，只需要输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker exec -it icontainer /bin/bash<br></code></pre></td></tr></table></figure><p>如果需要退出容器，输入<code>exit</code>或者<code>Ctrl+C</code>即可</p></li><li><p>使用<code>docker attach</code>命令进入</p><p>同样以<code>icontainer</code>举例，则需要输入以下指令来进入容器终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach icontainer<br></code></pre></td></tr></table></figure><p><em><strong>但这样有缺点，即退出终端的同时，该容器也会同样退出，所以推荐使用<code>exec</code>的方法进入容器</strong></em></p></li></ol><h2 id="文件传递"><a href="#文件传递" class="headerlink" title="文件传递"></a>文件传递</h2><p>​    先直接上指令，以容器<code>icontainer</code>为例，我需要将该容器下的<code>/opt/demo/demo.zip</code>拷贝到宿主机的<code>/opt/Backup/</code>下，那么我的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp icontainer:/opt/demo/demo.zip /opt/Backup/<br></code></pre></td></tr></table></figure><p>​    同理，如果我需要将<code>Backup</code>下的<code>demo.zip</code>传递到容器内，我也可以使用如下指令传输到容器的<code>recover</code>文件夹内：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /opt/Backup/demo.zip icontainer:/opt/recover/<br></code></pre></td></tr></table></figure><blockquote><p>备注：文件传递和容器是否启动无关，都会直接对文件进行修改</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Samba共享手册</title>
    <link href="/2021/07/31/SMB_on_Ubuntu/"/>
    <url>/2021/07/31/SMB_on_Ubuntu/</url>
    
    <content type="html"><![CDATA[<h2 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h2><ol><li><p>更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt-get upgrade <br>sudo apt-get update <br>sudo apt-get dist-upgrade<br></code></pre></td></tr></table></figure></li><li><p>安装samba服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install  samba  samba-common<br></code></pre></td></tr></table></figure></li><li><p>创建一个用于分享的samba文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /mnt/Files<br></code></pre></td></tr></table></figure></li><li><p>给这个文件夹设置权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod 777 /mnt/Files<br></code></pre></td></tr></table></figure></li><li><p>给需要连接的用户设置密码(非root)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo smbpasswd -a [username]<br></code></pre></td></tr></table></figure></li><li><p>配置smb文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/samba/smb.conf<br></code></pre></td></tr></table></figure><p>在配置文件最后添加类似以下模板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[shareFolderName]<br>comment = Commit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">是否能浏览</span><br>browseable = yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">路径</span><br>path = /path<br>create mask = 0777<br>directory mask = 0777<br>valid users = [username]<br>force user = root <br><span class="hljs-meta prompt_">#</span><span class="language-bash">确保有root文件修改权限</span><br>force group = root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">是否公开</span><br>public = yes<br>available = yes<br>writable = yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 不允许guest</span></span><br>guest ok = no<br></code></pre></td></tr></table></figure></li><li><p>(可选)关闭Ubuntu 防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw disable <br>sudo ufw status //查看ufw状态<br></code></pre></td></tr></table></figure></li><li><p>重启smb服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service smbd restart<br></code></pre></td></tr></table></figure></li><li><p>安装完毕，在Windows+R下连接</p><p><code>按Windows+R，然后输入&quot;\\IP地址&quot;检查是否能连接</code></p></li></ol><h2 id="补充说明-Q-amp-A"><a href="#补充说明-Q-amp-A" class="headerlink" title="补充说明 Q&amp;A"></a>补充说明 Q&amp;A</h2><ul><li><p>Samba无法访问软链接，提示没有权限</p><ul><li><p>和权限没有关系，需要修改的是<code>[global]</code>当中的设置，添加以下三行代码即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wide links = yes<br>symlinks = yes<br>unix extensions = no<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简单入门</title>
    <link href="/2021/07/22/Docker_Command/"/>
    <url>/2021/07/22/Docker_Command/</url>
    
    <content type="html"><![CDATA[<p>参考链接:</p><ol><li><a href="https://blog.csdn.net/weixin_44070676/article/details/106942848">CSDN-Ubuntu 18.04 DOCKER的安装</a></li><li><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images">停止、删除所有的docker容器和镜像</a></li><li><a href="https://docs.docker.com/">Docker官网文档</a></li></ol><h2 id="Docker用户组配置"><a href="#Docker用户组配置" class="headerlink" title="Docker用户组配置"></a>Docker用户组配置</h2><p>设置用户组<code>docker</code>，让用户不需要sudo也可以使用docker相关命令</p>   <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br>sudo gpasswd -a <span class="hljs-variable">$USER</span> docker<br>newgrp docker<br>docker ps<br></code></pre></td></tr></table></figure><ul><li><p>查看当前所有在运行的Docker容器</p><p><code>docker ps -a</code></p></li><li><p>在库内搜索需要的docker容器运行</p><p><code>docker search [name]</code></p></li><li><p>获取需要的容器</p><p><code>docker pull [name]</code></p></li><li><p>停止所有的容器</p><p><code>docker stop $(docker ps -aq)</code></p></li><li><p>删除所有的容器</p><p><code>docker rm $(docker ps -aq)</code></p><ul><li><p>删除所有目前没有在运行的容器</p><p><code>docker container prune</code></p></li></ul></li><li><p>删除所有的镜像</p><p><code>docker rmi $(docker images -q)</code></p><ul><li><p>删除所有未被使用的镜像</p><p><code>docker image prune</code></p></li></ul></li><li><p>删除所有未被引用的容器，镜像和各种cache</p><p><code>docker system prune</code></p></li><li><p>重命名容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rename [Docker的Name] [修改后的Name]<br></code></pre></td></tr></table></figure></li></ul><h2 id="运行Docker的指令"><a href="#运行Docker的指令" class="headerlink" title="运行Docker的指令"></a>运行Docker的指令</h2><blockquote><p>Docker在运行的过程中有许多额外设置，其中包括不同的网络结构，不同的运行模式，交互方法等，目前在这里只记录一些简单用得上的，后续如果还有比较常用的指令再进行补充添加。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><code>docker run -d --restart=always --network host --name CloudMusic nondanee/unblockneteasemusic</code></p><ol><li><p><code>docker run</code></p><p>运行docker容器</p></li><li><p><code>-d</code></p><p>以后台模式运行</p></li><li><p><code>--restart-always</code></p><p>每次docker如果重启了的话也总是自动运行</p></li><li><p><code>--network host</code></p><p>以<code>host</code>网络模式运行docker容器，而不是以默认的NAT分布</p></li><li><p><code>--name CloudMusic</code></p><p>给这个容器命名为CloudMusic</p></li></ol><ul><li>进入容器<ol><li><code>docker attach &lt;ID&gt;</code></li><li><code>docker -it &lt;ID&gt; /bin/bash</code>或者<code>docker -it &lt;ID&gt; /bin/sh</code></li></ol></li></ul><h2 id="Docker设置开机自启动"><a href="#Docker设置开机自启动" class="headerlink" title="Docker设置开机自启动"></a>Docker设置开机自启动</h2><ol><li><p>通过systemctl设置docker开机自启动</p><p><code>systemctl enable docker.service</code></p></li><li><p>docker容器使用<code>--restart=always</code>参数启动</p><ul><li>如果已经启动了可以通过<code>docker update --restart=always &lt;ID&gt;</code>添加参数</li></ul></li><li><p>重启系统以后通过<code>docker ps -a</code>可以看到服务已经在正常运行了</p></li></ol><h2 id="Docker容器参数配置"><a href="#Docker容器参数配置" class="headerlink" title="Docker容器参数配置"></a>Docker容器参数配置</h2><ol><li><p>用命令修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container update --help<br></code></pre></td></tr></table></figure><blockquote><p>使用这个指令可以在不停止容器的情况下更新部分内容，比如容器的启动方式</p></blockquote></li><li><p>配置文件修改</p><ul><li><em><strong>首先要停止容器，才能对容器的配置文件进行修改</strong></em></li><li>配置路径为<code>/var/lib/docker/containers/容器ID</code>下的<code>hostconfig.json</code>就是配置文件</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件权限</title>
    <link href="/2021/07/22/Linux_User_and_Group/"/>
    <url>/2021/07/22/Linux_User_and_Group/</url>
    
    <content type="html"><![CDATA[<p>参考文章</p><p>1.<a href="https://segmentfault.com/a/1190000024532631">Ubuntu群组管理</a></p><h2 id="Linux用户和群组"><a href="#Linux用户和群组" class="headerlink" title="Linux用户和群组"></a>Linux用户和群组</h2><p>​        Linux下拥有着不同的用户和群组，群组可以是一个用户的集群，通过修改Linux的用户和对应的群的权限可以较为安全的对文件进行操作。</p><h2 id="群组管理"><a href="#群组管理" class="headerlink" title="群组管理"></a>群组管理</h2><p><em><strong>接下来所有的内容都是基于<code>Ubuntu 20.04 LTS</code></strong></em></p><h3 id="新增群组"><a href="#新增群组" class="headerlink" title="新增群组"></a>新增群组</h3><p>在我们需要对多个用户进行相同的权限管理的时候，可以通过创建对应群组来进行管理，这里以<code>demog</code>为例</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">addgroup demog<br></code></pre></td></tr></table></figure><h4 id="用户和组的关系"><a href="#用户和组的关系" class="headerlink" title="用户和组的关系"></a>用户和组的关系</h4><h5 id="修改用户账户"><a href="#修改用户账户" class="headerlink" title="修改用户账户"></a>修改用户账户</h5><p>以<code>demo</code>用户为例，在有<code>root</code>权限的情况下输入以下指令来设置<code>demo</code>的初始组为<code>demog</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g demog demo<br></code></pre></td></tr></table></figure><p><strong>首先是<code>组</code>然后才是<code>用户</code></strong></p><h5 id="查看用户当前的组"><a href="#查看用户当前的组" class="headerlink" title="查看用户当前的组"></a>查看用户当前的组</h5><p>要查询当前用户所在的组信息，可以使用类似如下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groups demo<br></code></pre></td></tr></table></figure><p>如果要把一个用户添加到多个群组可以用如下指令（先去除后添加，请勿直接尝试指令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groups -G demog1 demog2 demog3 demo<br></code></pre></td></tr></table></figure><blockquote><p>配合<code>-g</code>或者<code>-G</code>参数的时候，会把用户从原本的组里面剔除，然后加入到新的组里面，如果需要的是<code>-a</code>的参数，表示的是“追加”</p></blockquote><h4 id="删除群组"><a href="#删除群组" class="headerlink" title="删除群组"></a>删除群组</h4><p>指令很简单，如下格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">delgroup demog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux挂载WebDav</title>
    <link href="/2021/06/13/Ubuntu_WebDav/"/>
    <url>/2021/06/13/Ubuntu_WebDav/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：已改用rclone作为较优方案</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/u013401853/article/details/113094734">davfs挂载与使用缺陷</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>输入以下指令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt install davfs2<br></code></pre></td></tr></table></figure></li></ol><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><ol><li><p>创建需要挂载的硬盘，这里以<code>/opt/Backup</code>为例，挂载网址为<code>http://localhost:8080/dav/</code>，账号为<code>admin</code>，密码为<code>123456</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /opt/Backup/<br></code></pre></td></tr></table></figure></li><li><p>将硬盘挂载到对应路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount.davfs http://locaohost:8080/dav/ /opt/Backup/<br></code></pre></td></tr></table></figure></li><li><p>输入账号密码并手动连接</p></li></ol><h2 id="保存密码"><a href="#保存密码" class="headerlink" title="保存密码"></a>保存密码</h2><ol><li><p>编辑<code>/etc/davfs2/davfs2.conf</code>，找到其中的<code>use_lock</code>取消注释，并修改值为<code>0</code></p></li><li><p>修改<code>/etc/davfs2/secrets</code>，在末尾添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://localhost:8080/dav/ admin 123456<br></code></pre></td></tr></table></figure></li></ol><h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><ol><li><p>编辑<code>/etc/fstab</code>，在最后一行添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://localhost:8080/dav/ /opt/Backup/ davfs defaults 0 0<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>以上的<a href="http://localhost:8080/dav/%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E8%AF%B7%E5%9C%A8%E4%BA%86%E8%A7%A3WebDav">http://localhost:8080/dav/和用户名密码均为示例，请在了解WebDav</a>之后替换为自己需要的值</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Aegis二步验证</title>
    <link href="/2021/06/12/SteamAgeis/"/>
    <url>/2021/06/12/SteamAgeis/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    偶然发现了<code>Aegis</code>这类手机上的二步验证软件，并且找到了添加<code>Steam</code>令牌的方法。由于<code>Aegis</code>并不自带互联网连接（在issues#630中有提及），所以需要自己想办法备份。自己刚好在研究<code>WebDav</code>的一些功能拓展，也找到了一个安卓上的拥有<code>WebDav</code>备份功能的软件<code>AutoSync</code>，于是结合一下就有了这篇博客。</p><h2 id="有关链接"><a href="#有关链接" class="headerlink" title="有关链接"></a>有关链接</h2><ol><li><a href="https://github.com/beemdevelopment/Aegis">Aegis: A free, secure and open source app for Android to manage your 2-step verification tokens</a></li><li><a href="https://www.coolapk.com/feed/12046283?shareKey=OTU2OWIxY2QwMTJiNjBjNDhlYjM~&shareUid=2384839&shareFrom=com.coolapk.market_11.2.3">如何通过第三方验证软件使用Steam令牌</a></li><li><a href="https://metactrl.com/">AutoSync 官网地址</a></li></ol><h2 id="获取Steam口令"><a href="#获取Steam口令" class="headerlink" title="获取Steam口令"></a>获取Steam口令</h2><ul><li>有ROOT的情况：<ol><li>直接使用<code>Aegis</code>自带的导入<code>Steam</code>数据即可</li></ol></li><li>无ROOT的情况：<ol><li>首先获取系统较高的权限</li><li>安装MT管理器或者其他高级文件管理器</li><li>找到<code>/data/data/com.valvesoftware.android.steam.community/files</code>目录</li><li>以文本的形式打开该目录下的<code>Steamguard-xxxxxxx</code>文件</li><li>找到<code>otpauth</code>后的内容，并找到最近的<code>secert</code>字样，复制<code>&amp;issuer</code>前面的内容（不包括<code>&amp;issuer</code>）</li><li>打开<code>Aegis</code>，添加新的配置，<code>Digits</code>设置<code>5</code>，时间设置<code>30s</code>，<code>secret</code>填入复制内容即可</li></ol></li></ul><h2 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h2><blockquote><p>博客使用的AutoSync下载地址来源于<a href="https://www.yxssp.com/">异星软件空间</a>，仅供学习使用，请在24小时内删除。继续使用请购入正版。</p></blockquote><ol><li>在<code>CloudReve</code>中创建一个<code>WebDav</code>连接（<code>CloudReve</code>的搭建教程在前期博客中有写）</li><li>根据<code>AutoSync</code>中的引导进行文件配置，并且设置好定时更新的时间。</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>​    这篇博客本身没什么技术含量，主要是节约寻找对应需求软件的时间，安卓上轻量并且好用的WebDav自动同步软件并不多，此贴仅做记录，方便后续参考。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UUID挂载硬盘</title>
    <link href="/2021/05/22/Mount_Disk_with_UUID/"/>
    <url>/2021/05/22/Mount_Disk_with_UUID/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://support.huaweicloud.com/ecs_faq/ecs_faq_1125.html">重启后盘符发生变化解决办法</a></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>将硬盘接入系统</p></li><li><p>使用以下指令查询目前磁盘分区的盘符</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure></li><li><p>使用以下指令查询特定盘符的UUID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">blkid /dev/sda1  ## 这里的sda1要看具体情况填<br></code></pre></td></tr></table></figure></li><li><p>在<code>/etc/fstab/</code>内编辑类似以下内容挂载磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">UUID=c26cfce4-xxxx-xxxx-xxxx-403439946c8c    /opt    ext4    defaults 0 0  ## /opt为具体挂载的目录,ext4为磁盘格式<br></code></pre></td></tr></table></figure></li><li><p>使用以下指令检查是否设置成功，如果成功则不会返回任何异常信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -a<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置域名SRV记录</title>
    <link href="/2021/05/11/SRV_of_Minecraft/"/>
    <url>/2021/05/11/SRV_of_Minecraft/</url>
    
    <content type="html"><![CDATA[<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>​    目前对于SRV记录了解还不清楚，没有查询具体可以使用的服务等。目前需要的也只是达到转发MC的端口，达到隐藏端口的目的，所以只是一个无脑式记录。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>拥有一个域名，并且指向了一个带有端口的MC服务器，比如<code>rpg.vastl.icu:25566</code></p></li><li><p>在DNS控制台添加解析记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs plain">主机记录：_minecraft._tcp.xx  ## xx为子域名<br>记录类型：SRV<br>记录值：5 0 端口号 域名  ## 举例：5 0 25566 rpg2.vastl.icu.<br></code></pre></td></tr></table></figure></li><li><p>最后应用即可。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier搭建Planet服务器</title>
    <link href="/2021/05/10/Setup_Planet_ZeroTier_Server/"/>
    <url>/2021/05/10/Setup_Planet_ZeroTier_Server/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://gotz.co/2019/02/17/mpls-over-zerotier-pt-1/">Running MPLS over ZeroTier Part 1 · Gotz Networks</a></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>把ZeroTier的项目在本地克隆一份</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zerotier/ZeroTierOne.git<br></code></pre></td></tr></table></figure></li><li><p>打开在<code>attic</code>文件夹下的<code>world</code>文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ZeroTierOne/attic/world<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>mkworld.cpp</code>文件，把<code>ZeroTier Controller默认的IP删除，添加自己的IP上去。</code></p></li><li><p>编译文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ./build.sh<br></code></pre></td></tr></table></figure></li><li><p>运行<code>mkworld</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mkworld<br></code></pre></td></tr></table></figure></li><li><p>应该会产生一个新的<code>world.bin</code>文件，这个文件需要在所有自己的客户端添加</p></li><li><p>将这个<code>world.bin</code>文件复制到<code>ZeroTier</code>的文件夹下，在Linux中的指令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp world.bin /var/lib/zerotier-one/planet<br></code></pre></td></tr></table></figure></li><li><p>重启<code>ZeroTier</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart zerotier-one.service<br></code></pre></td></tr></table></figure></li><li><p>重复第七步和第八步，在所有希望使用自己<code>Planet</code>服务器的客户端中添加这个节点</p></li></ol><h2 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h2><p>​    完全使用自己的服务器，数据等不通过ZeroTier自己的官网。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置多ssh密钥</title>
    <link href="/2021/05/09/Add_More_RSA_Keys/"/>
    <url>/2021/05/09/Add_More_RSA_Keys/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/xie_zhongyong/article/details/51994389">多个id_rsa 配置</a></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>在<code>/.ssh/</code>目录下新建<code>config</code>文件</p></li><li><p>写入格式类似如下的文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Host</span> <span class="hljs-string">github.com</span><br>    <span class="hljs-string">HostName</span> <span class="hljs-string">github.com</span><br>    <span class="hljs-string">User</span> <span class="hljs-string">root</span><br>    <span class="hljs-string">IdentityFile</span> <span class="hljs-string">/.ssh/id_rsa_git</span><br><br><span class="hljs-string">Host</span> <span class="hljs-string">test.com</span><br>    <span class="hljs-string">HostName</span> <span class="hljs-string">test.com</span><br>    <span class="hljs-string">User</span> <span class="hljs-string">test</span><br>    <span class="hljs-string">IdentityFile</span> <span class="hljs-string">/.ssh/id_rsa_test</span><br></code></pre></td></tr></table></figure></li><li><p>对于不配置的<code>Host</code>，系统会默认使用<code>id_rsa</code>文件</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu禁用Sleep</title>
    <link href="/2021/05/07/Ubuntu_Server_prohibit_Sleep/"/>
    <url>/2021/05/07/Ubuntu_Server_prohibit_Sleep/</url>
    
    <content type="html"><![CDATA[<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ol><li><a href="https://www.unixtutorial.org/disable-sleep-on-ubuntu-server/">How To: Disable Sleep on Ubuntu Server (unixtutorial.org)</a></li></ol><h2 id="查看系统休眠的记录"><a href="#查看系统休眠的记录" class="headerlink" title="查看系统休眠的记录"></a>查看系统休眠的记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo systemctl status sleep.target<br></code></pre></td></tr></table></figure><blockquote><p>理论上会返回类似如下的内容，里面会注明系统休眠的时间等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## systemctl status sleep.target<br>● sleep.target - Sleep<br>     Loaded: loaded (/lib/systemd/system/sleep.target; static; vendor preset: enabled)<br>     Active: inactive (dead)<br>       Docs: man:systemd.special(7)<br><br>May 07 18:54:58 azhal systemd[1]: Reached target Sleep.<br>May 07 20:19:14 azhal systemd[1]: Stopped target Sleep.<br>May 07 20:39:14 azhal systemd[1]: Reached target Sleep.<br>May 07 20:52:35 azhal systemd[1]: Stopped target Sleep.<br></code></pre></td></tr></table></figure></blockquote><h2 id="关闭系统休眠"><a href="#关闭系统休眠" class="headerlink" title="关闭系统休眠"></a>关闭系统休眠</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target<br></code></pre></td></tr></table></figure><blockquote><p>[引用文章原话] This is obviously a very simple way of disabling power management, but I like it because it’s standard and logical enough – there’s no need to edit config files or create cronjobs manually controlling sleep functionality.</p><p>大概翻译过来就是指这样的操作标准且合理，因为这样省去了编辑任何文件的麻烦，并且也达到了禁用休眠的目的。</p><p>禁用以后大致会变成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## systemctl status sleep.target<br>● sleep.target<br>     Loaded: masked (Reason: Unit sleep.target is masked.)<br>     Active: inactive (dead)<br><br>May 07 18:54:58 azhal systemd[1]: Reached target Sleep.<br>May 07 20:19:14 azhal systemd[1]: Stopped target Sleep.<br>May 07 20:39:14 azhal systemd[1]: Reached target Sleep.<br>May 07 20:52:35 azhal systemd[1]: Stopped target Sleep.<br></code></pre></td></tr></table></figure></blockquote><h2 id="恢复系统休眠服务器"><a href="#恢复系统休眠服务器" class="headerlink" title="恢复系统休眠服务器"></a>恢复系统休眠服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu切换显卡</title>
    <link href="/2021/05/07/Ubuntu_Switch_Graphic_Card/"/>
    <url>/2021/05/07/Ubuntu_Switch_Graphic_Card/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://rayleizhu.com/?p=156">在Ubuntu 18.04上切换独显&#x2F;集显 – VOID (rayleizhu.com)</a></li></ol><h2 id="脚本切换"><a href="#脚本切换" class="headerlink" title="脚本切换"></a>脚本切换</h2><ol><li><p>使用Nvidia独显</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo prime-select nvidia<br></code></pre></td></tr></table></figure></li><li><p>使用Intel集显</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo prime-select intel<br></code></pre></td></tr></table></figure></li><li><p>查询当前用的显卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">prime-select query<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apt垃圾清理</title>
    <link href="/2021/05/07/Ubuntu_Uninstall/"/>
    <url>/2021/05/07/Ubuntu_Uninstall/</url>
    
    <content type="html"><![CDATA[<h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ol><li><a href="https://blog.csdn.net/yanzi1225627/article/details/9269279">Ubuntu删除无用缓存及垃圾文件</a></li></ol><h2 id="常用的清理指令"><a href="#常用的清理指令" class="headerlink" title="常用的清理指令"></a>常用的清理指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt-get autoclean  ## 清理旧版本的软件缓存<br>sudo apt-get clean  ## 清理所有软件缓存<br>sudo apt-get autoremove  ## 删除系统不再使用的孤立软件<br></code></pre></td></tr></table></figure><p>这三个指令主要是用于清理升级时候产生的缓存和无用的包</p><h2 id="包管理的临时文件目录"><a href="#包管理的临时文件目录" class="headerlink" title="包管理的临时文件目录"></a>包管理的临时文件目录</h2><ul><li>包在<code>/var/cache/apt/archives</code></li><li>没有下载完毕的在<code>/var/cache/apt/archives/partial</code></li></ul><h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove --purge [软件名字]  ## 卸载某个软件<br>dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P  ## 删除系统上多余的配置文件<br></code></pre></td></tr></table></figure><h2 id="删除内核"><a href="#删除内核" class="headerlink" title="删除内核"></a>删除内核</h2><p>​    见博客：<a href="https://halc.top/2021/04/24/Ubuntu%E5%88%A0%E9%99%A4Grub%E5%86%85%E5%A4%9A%E4%BD%99%E5%86%85%E6%A0%B8.html">删除多余的Ubuntu内核,解决因grub无法正常启动的问题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang镜像设置</title>
    <link href="/2021/05/06/Golang_Change_Source/"/>
    <url>/2021/05/06/Golang_Change_Source/</url>
    
    <content type="html"><![CDATA[<h2 id="切换镜像指向"><a href="#切换镜像指向" class="headerlink" title="切换镜像指向"></a>切换镜像指向</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">export GOPROXY=https://mirrors.cloud.tencent.com/go/  ## 腾讯云<br>export GOPROXY=https://goproxy.io  ## 官方<br>export GOPROXY=https://mirrors.aliyun.com/goproxy/  ## 阿里云<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7zip手册</title>
    <link href="/2021/04/30/Linux_7zip/"/>
    <url>/2021/04/30/Linux_7zip/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>直接使用<code>apt</code>安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo apt install p7zip<br></code></pre></td></tr></table></figure></li></ol><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ol><li><p>压缩文件&#x2F;文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">7za a -t7z -r MyTest.7z FolderToZip/*<br></code></pre></td></tr></table></figure><p>将<code>FolderToZip</code>文件夹下所有文件压缩到当前目录的<code>MyTest.7z</code>文件中</p><blockquote><p>a 代表添加文件&#x2F;文件夹到压缩包<br>-t(7z) -t参数是指定压缩类型，这里是7z，也可以不指定，因为7za默认的压缩类型就是7z<br>-r 表示递归所有的子文件夹</p></blockquote></li><li><p>解压缩文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">7za x MyTest.7z -r -o./<br></code></pre></td></tr></table></figure><p>将<code>MyTest.7z</code>解压到当前目录</p><blockquote><p>x 代表解压缩文件，并且是以原本文件夹的方式解压（还有一个参数是e，会直接把所有文件从根目录解压）<br>-r 递归解压缩的所有子文件夹<br>-o 指定解压缩的目录，并且-o后面是没有空格的，这一点需要注意。</p></blockquote></li></ol><p>参考文章:</p><ol><li><a href="https://blog.csdn.net/whatday/article/details/50157273">linux下安装7z命令及7z命令的使用</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloudflare Partner配置</title>
    <link href="/2021/04/27/CloudFlare_Partner_CDN/"/>
    <url>/2021/04/27/CloudFlare_Partner_CDN/</url>
    
    <content type="html"><![CDATA[<h2 id="通过Dnspod解析域名"><a href="#通过Dnspod解析域名" class="headerlink" title="通过Dnspod解析域名"></a>通过Dnspod解析域名</h2><p>​    由于服务器本身搭建使用的是香港的服务器，建站不需要域名备案。为了不使用Cloudflare默认的海外CDN，而使用我们需求的自定义CDN，需要把域名托管到一个非Cloudflare的平台下，这里直接托管到腾讯云Dnspod的解析下。</p><ol><li><p>备份Cloudflare下的解析信息</p></li><li><p>在控制台下修改Name Server为Dnspod控制台提供的NS服务器</p></li><li><p>将之前备份的解析信息再次添入</p><p>（这里没找到Dnspod的导入域名信息，所以手动添入）</p></li><li><p>开启”域名设置”下的CNAME加速，减少CNAME的解析次数</p></li></ol><h2 id="设置CloudFlare-CNAME"><a href="#设置CloudFlare-CNAME" class="headerlink" title="设置CloudFlare CNAME"></a>设置CloudFlare CNAME</h2><ol><li><p>注册Cloudflare邮箱，这里不做解释</p></li><li><p>在 <a href="https://cdn.ink/">楠格</a>(或者类似Cloudflare Partner网站) 登入自己的Cloudflare账号</p></li><li><p>将自己需要使用CDN的域名添加到控制台下，TTL设置两分钟，CDN设置为开启</p><p><img src="/%5C2021%5C04%5Cimages%5CCDN_1.png" alt="域名添加"></p></li><li><p>添加完毕以后在CNAME接入处可以看到主机名对应的CNAME信息，在Dnspod设置对应的解析就可以使用CDN的解析服务。</p><p><img src="/%5C2021%5C04%5Cimages%5CCDN_2.png" alt="域名添加"></p><!-- markdownlint-disable MD033 --><div align=center>CNAME信息 </div><p><img src="/%5C2021%5C04%5Cimages%5CCDN_3.png" alt="Dnspod设置"></p><div align=center>Dnspod设置 </div></li></ol><h2 id="自定义CDN节点"><a href="#自定义CDN节点" class="headerlink" title="自定义CDN节点"></a>自定义CDN节点</h2><p>​    通过参考网上的IP表，在Dnspod的控制台中再次添加域名对应的A记录解析，可以设置不同的运营商解析不同的IP，来达到让流量走自定义加速的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><pre><code class="hljs plain">172.64.32.1/24 （推荐移动，走香港）<br>104.28.14.0/24 （推荐移动，走新加坡）<br>104.23.240.0-104.23.243.254 （推荐联通、移动，线路未知）<br>108.162.236.1/24 （推荐联通，走美国）<br>104.20.157.0/24 （推荐联通，走日本）<br>104.16.160.1/24 （推荐电信，走洛杉矶）<br>172.64.0.0/24 （推荐电信，走旧金山）<br>172.64.32.* （走欧洲）<br> <br>108.162.236.1/24 联通 走美国<br>172.64.32.1/24 移动 走香港<br>104.16.160.1/24 电信 走美国洛杉矶<br>172.64.0.0/24 电信 美国旧金山<br>104.20.157.0/24 联通 走日本<br>104.28.14.0/24 移动 走新加坡<br> <br>104.18.62.1/24 香港hkix.net<br>104.16.35.1/24 香港hkix.net<br>104.16.36.1/24 香港hkix.net<br>104.18.35.1/24 香港hkix.net<br>104.18.36.1/24 香港hkix.net<br>104.16.54.1/24 香港<br>104.16.55.1/24 香港<br>104.18.128.1/24 香港<br>104.18.129.1/24 香港<br>104.18.130.1/24 香港<br>104.18.131.1/24 香港<br>104.18.132.1/24 香港<br>104.19.195.1/24 香港<br>104.19.196.1/24 香港<br>104.19.197.1/24 香港<br>104.19.198.1/24 香港<br>104.19.199.1/24 香港<br>#适合电信的节点<br>104.23.240.*<br>#走欧洲各国出口 英国德国荷兰等 延迟比美国高一些 适合源站在欧洲的网站<br>172.64.32.*<br>#虽然去程走新加坡，但是回程线路的绕路的，实际效果不好，不推荐<br>104.16.160.*<br>#圣何塞的线路，比洛杉矶要快一点，推荐<br>108.162.236.*<br>#亚特兰大线路，延迟稳定，但是延迟较高<br>#适合移动的节点<br>162.158.133.* <br>#走的丹麦，这一段ip只有部分能用，可以自己试一下，绕美国<br>198.41.214.*<br>198.41.212.*<br>198.41.208.*<br>198.41.209.*<br>172.64.32.*<br>141.101.115.*<br>#移动走香港的IP段有很多，以上并不是全部。CF移动走香港的分直连和走ntt的效果都挺不错的，不过部分地区晚上还是会丢包。<br>172.64.0. *<br>#这是走圣何塞的，一般用香港的就行<br>172.64.16.* <br>#欧洲线路.绕<br>#1.0.0.1效果较好<br>电信部分<br>大多数省直接使用1.0.0.0即可，延迟低，丢包少，<br>## 移动部分<br>#新加坡<br>104.18.48.0-104.18.63.255<br>104.24.112.0-104.24.127.255<br>104.27.128.0-104.27.143.255<br>104.28.0.0-104.28.15.255<br>## 移动部分<br>#圣何塞 <br>104.28.16.0-31.255<br>104.27.144.0-243.254<br>104.23.240.0-243.254<br>#香港cloudflare1-100g.hkix.net<br>1.0.0.0-254<br>1.1.1.0-254<br>#香港直连<br>104.16.0.0-79.255<br>104.16.96.0-175.254<br>104.16.192.0-207.255<br></code></pre></td></tr></table></figure><p>设置了对应的A记录后保存退出，可通过<code>ping example.com</code>来测试是否设置成功。</p><p>参考网站:</p><ol><li><a href="https://www.wbolt.com/optimization-for-cn-websites-using-cloudflare.html">针对使用Cloudflare CDN国内网站的速度优化方案 - 闪电博 (wbolt.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核管理</title>
    <link href="/2021/04/24/Redundant_Kernel_Delete_in_Ubuntu/"/>
    <url>/2021/04/24/Redundant_Kernel_Delete_in_Ubuntu/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu删除多余的内核"><a href="#Ubuntu删除多余的内核" class="headerlink" title="Ubuntu删除多余的内核"></a>Ubuntu删除多余的内核</h2><ol><li><p>查看当前的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">root@azhal:~## uname -a<br>Linux azhal 5.11.16-xanmod1-cacule #0~git20210421.d9591de SMP PREEMPT Wed Apr 21 17:44:04 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure></li><li><p>查看当前系统中所有的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## dpkg --get-selections |grep linux<br>binutils-x86-64-linux-gnu                       install<br>console-setup-linux                             install<br>libselinux1:amd64                               install<br>libselinux1-dev:amd64                           install<br>linux-base                                      install<br>linux-firmware                                  install<br>linux-headers-5.11.16-xanmod1-cacule            install<br>linux-image-5.11.16-xanmod1-cacule              install<br>linux-image-5.4.0-72-generic                    install<br>linux-image-generic                             install<br>linux-libc-dev:amd64                            install<br>linux-modules-5.4.0-72-generic                  install<br>linux-modules-extra-5.4.0-72-generic            install<br>linux-xanmod-cacule                             install<br>util-linux                                      install<br></code></pre></td></tr></table></figure></li><li><p>移除多余的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove &lt;name of kernel&gt;<br></code></pre></td></tr></table></figure></li><li><p>再次检查内核是否为<code>deinstall</code>状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg --get-selections |grep linux<br></code></pre></td></tr></table></figure></li><li><p>更新系统引导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-grub<br></code></pre></td></tr></table></figure></li></ol><p>参考文章</p><ol><li><a href="https://www.cnblogs.com/yangzhaon/p/12911716.html">Ubuntu删除多余的内核 - 阳光与叶子 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx报错502</title>
    <link href="/2021/04/21/502_Error_in_CloudFlare_with_nginx/"/>
    <url>/2021/04/21/502_Error_in_CloudFlare_with_nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><ul><li>设置了Nginx防火墙，禁止了国外IP访问网站或者有类似的协议导致CDN无法连接上站点。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>关闭Nginx防火墙内的”禁止国外访问”，或者添加<a href="https://www.cloudflare.com/zh-cn/ips/">CloudFlare的CDN的IP列表</a>到防火墙的白名单就行。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置CDN回源重定向解决</title>
    <link href="/2021/04/20/Network_Error_in_CloudFlare_with_HTTPS_and_nginx/"/>
    <url>/2021/04/20/Network_Error_in_CloudFlare_with_HTTPS_and_nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在部署好了CloudReve和Nginx以后，想通过Cloudflare的免费的CDN服务来达到一个节省流量的目的，但是在直接开启CDN代理之后发现原本的网站一直出现Network Error的问题，在此记录一下解决方案。</p><p>​    首先记录一下现状：</p><ul><li>CloudReve部署在自己家的服务器上，通过ZeroTier和香港的服务器虚拟局域网相连，并且通过Nginx反代</li><li>Nginx配置好了SSL证书，开启了强制使用HTTPS链接</li></ul><p>​    测试的现状：</p><ul><li>在开启强制HTTPS链接的时候使用CDN加速，连接CloudReve的时候会出现Network Error，网页控制台报错重定向次数过多。</li><li>关闭强制HTTPS链接使用CDN加速并且通过HTTPS进行链接的时候正常。</li></ul><blockquote><p>参考了的可能有帮助的解决方案</p><ol><li><a href="https://www.dyxmq.cn/uncategorized/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%9Acdn%E5%BC%80%E5%90%AF%E5%BC%BA%E5%88%B6https%E4%B9%8B%E5%90%8E%E8%BF%94%E5%9B%9E%E9%87%8D%E5%AE%9A%E5%90%91%E6%AC%A1%E6%95%B0%E8%BF%87%E5%A4%9A%E7%9A%84.html">踩坑记录：CDN开启强制https之后返回重定向次数过多的问题</a></li></ol></blockquote><h2 id="尝试了的解决办法"><a href="#尝试了的解决办法" class="headerlink" title="尝试了的解决办法"></a>尝试了的解决办法</h2><ol><li><p>由于CDN是先到香港的服务器，是https访问，然后香港的服务器到自己的网盘是http访问，根据上方参考的”踩坑记录”方案一，给家里的服务器的cloudreve加了一个ssl证书再次尝试代理，问题依旧。</p></li><li><p>同根据“踩坑记录”，在nginx的配置文件中添加以下配置</p><p><code>proxy_set_header X-Forwarded-Proto $scheme;</code></p><p>附上解释原因：</p><blockquote><p>设置http头部<code>X-Forwarded-Proto</code>，这个头部的作用是用于识别协议（HTTP 或 HTTPS），主要针对内部访问重定向时的协议。因此，只要在反向代理时添加以上配置就好了</p><p><code>$scheme</code>是nginx的内部变量，表明当前访问的协议，当前如果是https，那么转发到后台服务的时候就是https。这样问题就解决了。</p></blockquote><p><strong>但是问题依旧</strong></p><p>之后认为问题不出在香港服务器到家中服务器，寻找其他的解决方案。</p></li></ol><h2 id="在非Cloudflare的CDN上的解决方案"><a href="#在非Cloudflare的CDN上的解决方案" class="headerlink" title="在非Cloudflare的CDN上的解决方案"></a>在非Cloudflare的CDN上的解决方案</h2><p>​    在查询和强制HTTPS有关词条的时候查询到这是CDN云加速很容易遇到的一个问题，解决方案主要有三种。</p><ol><li>设置CDN的回源端口为443端口，让CDN回源的时候以HTTPS请求源站，这样就不会触发源站的强制跳转的逻辑了。</li><li>在CDN的控制台中设置回源设置为“跟随”（一般会有三个选项，分别是“回源”，“HTTP”和“HTTPS”。）</li><li>放弃强制跳转HTTPS，在Nginx关闭强制。</li></ol><h2 id="最后在Cloudflare上的解决方案"><a href="#最后在Cloudflare上的解决方案" class="headerlink" title="最后在Cloudflare上的解决方案"></a>最后在Cloudflare上的解决方案</h2><p>​    由于没有找到Cloudflare上有类似CDN控制台的地方（感觉毕竟是免费的，没有正常。不过也可能是我太菜了不知道在哪里），于是上面的三种办法都不得不作罢，只能另寻其他办法。</p><ol><li>香港的服务器上关闭Nginx的强制https</li><li>在cloudflare的”Rules”里面添加Page Rules，设置里面添加对应的域名，然后开启始终使用HTTPS</li></ol><blockquote><p>有一说一，结果是启用了免费的CDN以后速度还是比较慢，而且多线程下载也没有缓存很多文件，后期还是试试Cloudflare Partner或者其他的项目比较好。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google镜像站创建引导</title>
    <link href="/2021/04/20/Nginx_Modules_in_bt_config/"/>
    <url>/2021/04/20/Nginx_Modules_in_bt_config/</url>
    
    <content type="html"><![CDATA[<p>步骤如下:</p><ol><li><p>在宝塔面板中创建Google的Nginx反代<code>www.google.com.hk</code></p></li><li><p>配置SSL证书并保存，启用HTTPS</p></li><li><p>配置upstream设置</p><ul><li><p>通过如下方式获取google的不同ip</p><p><code>dig www.google.com @8.8.8.8 +short</code></p></li><li><p>将类似如下配置文件配置好</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> www.google.com.hk &#123;<br>     ip_hash;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">108.177.125.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">64.233.189.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">74.125.23.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">172.217.24.35:443</span>;<br>     &#125;<br><br><span class="hljs-section">server</span><br>&#123;...&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在server中配置防爬虫和禁止IP访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span><br>&#123;<br><br>    ...<br><br>    <span class="hljs-comment"># 防止网络爬虫</span><br>    <span class="hljs-comment">#forbid spider</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_user_agent</span> <span class="hljs-regexp">~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo!</span> Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot<span class="hljs-string">&quot;) </span><br><span class="hljs-string">    &#123; </span><br><span class="hljs-string">        return 403; </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # 禁止用其他域名或直接用IP访问，只允许指定的域名访问</span><br><span class="hljs-string">    #forbid illegal domain</span><br><span class="hljs-string">    if ( <span class="hljs-variable">$host</span> != &quot;</span>yourdomain.com<span class="hljs-string">&quot; ) &#123;</span><br><span class="hljs-string">        return 403; </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">     </span><br><span class="hljs-string">    ...</span><br><span class="hljs-string">    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>检查并重启配置文件</p><p><code>nginx -t &amp;&amp; nginx -s reload</code></p></li><li><p>在宝塔防火墙中关闭’GET’过滤，否则会导致搜索某些关键词的时候被误判封锁IP</p></li></ol><p>参考文章:</p><ol><li><a href="https://blog.oyi.me/619">(<em>´∇｀</em>) 被你发现啦~ 搭建google镜像网站(适用最新版nginx)Module for Google Mirror – 深海 (oyi.me)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置ssh密钥验证</title>
    <link href="/2021/04/19/RSA_Key_login_Linux_without_password/"/>
    <url>/2021/04/19/RSA_Key_login_Linux_without_password/</url>
    
    <content type="html"><![CDATA[<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><ol><li><p>在客户端电脑上输入以下指令生成rsa私钥和公钥</p><p><code>ssh-keygen -t rsa -C &quot;your@email.com&quot;</code></p><p>生成一对以你的邮箱为标签的密钥</p></li><li><p>在<code>/.ssh/</code>文件夹下的<code>id_rsa</code>为密钥文件，<code>id_rsa.pub</code>为公钥文件</p></li></ol><h2 id="在Linux服务器下添加密钥"><a href="#在Linux服务器下添加密钥" class="headerlink" title="在Linux服务器下添加密钥"></a>在Linux服务器下添加密钥</h2><ol><li>在当前用户的主目录中的<code>/.ssh/</code>中添加或者修改<code>authorized_keys</code>文件，将刚刚客户端的<code>id_rsa.pub</code>内容复制到<code>authorized_keys</code>中</li></ol><h2 id="关闭密码登入，并且只用RSA登入"><a href="#关闭密码登入，并且只用RSA登入" class="headerlink" title="关闭密码登入，并且只用RSA登入"></a>关闭密码登入，并且只用RSA登入</h2><ol><li><p>编辑<code>sshd_config</code>文件</p><p><code>vi /etc/ssh/sshd_config</code></p></li><li><p>禁用密码验证</p><p>将<code>PasswordAuthentication</code>的注释取消，并修改为</p><p><code>PasswordAuthentication no</code></p></li><li><p>启用RSA登入</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">RSAAuthentication yes<br>PubkeyAuthentication yes<br></code></pre></td></tr></table></figure></li><li><p>重启SSH服务</p><p>​    <strong>注意，重启SSH服务之前建议保留一个会话，以免出现密码登入失败的情况</strong></p><ul><li><p>RHEL&#x2F;CentOS系统</p><p><code>sudo service sshd restart</code></p></li><li><p>Ubuntu系统</p><p><code>sudo service ssh restart</code></p></li><li><p>Debain系统</p><p><code>/etc/init.d/ssh restart</code></p></li></ul></li></ol><p>参考文章:</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2015-07/119608.htm">SSH使用密钥登入并禁止口令登入实践</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/04/12/C++Binary_search/"/>
    <url>/2021/04/12/C++Binary_search/</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsl</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回左边界</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) <span class="hljs-comment">//每次正确右边界都向左缩小</span><br>            r = mid;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//mid不正确，弃用mid并且缩小区间</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsr</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回右边界</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) <span class="hljs-comment">//每次左边界都向右缩小，由于存在向下取整，避免死循环mid需要l+r+1</span><br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//mid不正确，弃用mid并缩小区间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><h3 id="以bsl为例"><a href="#以bsl为例" class="headerlink" title="以bsl为例"></a>以<code>bsl</code>为例</h3><p>​    二分的主要的作用，是取得一个“分界点”。采取的思路为<strong>测试中间点是否符合条件，如果不符合则对区间进行缩小操作，重新测试区间，直到区间为一个数字。</strong>在模板一中，首先确定中间点<code>mid</code>，然后测试中间点mid是否符合条件，如果符合条件，则每次都会<strong>将区间的右端点进行左移的操作，直到不能左移为止</strong>，所以返回的最后位置为<strong>最接近答案的最左边的端点</strong>。如果不符合条件，由于<strong>确定了<code>mid</code>的位置为无效位置，所以下一次刷新区间的时候将mid剔除掉。</strong>剔除的操作可以达到防止死循环的效果</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>​    由于二分是每次都将一个区间一分为二，并且对整个区间进行一次操作，所以最后的时间复杂度为<code>O(logN)</code></p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol><li>在<code>bsr</code>中，由于在每次正确的时候修改的都是左边界<code>l</code>，但是在<code>计算除2</code>的时候会存在<code>mid/2取整为l</code>的情况，这样会导致最后结果的死循环。所以需要定义mid为<code>mid = l+r+1&gt;&gt;1</code>来避免死循环。<del>可以记为 <strong>返回右边界的时候需要+1，因为右边比左边大（bushi</strong></del></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CloudReve搭建引导</title>
    <link href="/2021/04/06/CloudReve_Setup/"/>
    <url>/2021/04/06/CloudReve_Setup/</url>
    
    <content type="html"><![CDATA[<h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><ol><li>安装好宝塔面板，并且预先安装好LNMP环境</li><li>Aria2离线下载配置</li><li>在<a href="https://freessl.cn/">FreeSSL</a>上获取SSL证书和密钥</li></ol><h2 id="CloudReve部署"><a href="#CloudReve部署" class="headerlink" title="CloudReve部署"></a>CloudReve部署</h2><h3 id="安装CloudReve"><a href="#安装CloudReve" class="headerlink" title="安装CloudReve"></a>安装CloudReve</h3><ol><li><p>前往<a href="https://github.com/cloudreve/Cloudreve/releases">官方库</a>下载最新版的对应系统的可执行文件</p></li><li><p>在BT面板内添加网站CloudReve，并且设置对应的域名和根目录（下图为示例）</p><p><img src="/2021/04/images/BT_1.png" alt="BT面板创建新网站"></p></li><li><p>将可执行文件上传到在宝塔面板设置的根目录中，并<code>cd</code>到当前目录</p></li><li><p>运行CloudReve，并记录初始的账号密码</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">chmod +x ./cloudreve<br>./cloudreve<br></code></pre></td></tr></table></figure></li><li><p>登入<code>http://ip:5212</code>，在控制面板中修改默认的管理员账号和密码</p></li></ol><h3 id="修改数据库为MySql"><a href="#修改数据库为MySql" class="headerlink" title="修改数据库为MySql"></a>修改数据库为MySql</h3><blockquote><p>自带的数据库是SQLite，这里需要修改为MySql</p></blockquote><ol><li><p>在宝塔面板创建一个MySql数据库</p></li><li><p>在运行一次CloudReve后，根目录会有一个<code>conf.ini</code>的文件，根据自己情况加入以下配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">; 数据库相关，如果你只想使用内置的 SQLite数据库，这一部分直接删去即可<br>[Database]<br>; 数据库类型，目前支持 sqlite | mysql<br>Type = mysql<br>; MySQL 端口<br>Port = 3306<br>; 用户名<br>User = root<br>; 密码<br>Password = root<br>; 数据库地址<br>Host = 127.0.0.1<br>; 数据库名称<br>Name = v3<br>; 数据表前缀<br>TablePrefix = cd_<br>; SQLite 数据库文件路径<br>DBFile = cloudreve.db<br></code></pre></td></tr></table></figure></li></ol><h3 id="添加进程守护"><a href="#添加进程守护" class="headerlink" title="添加进程守护"></a>添加进程守护</h3><blockquote><p>这里使用Ubuntu自带的systemd进行进程守护</p></blockquote><ol><li><p>编辑配置文件</p><p><code>vim /usr/lib/systemd/system/cloudreve.service</code></p></li><li><p>将下文的<code>PATH_TO_CLOUDREVE</code>更改为宝塔面板中设置的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Cloudreve<br>Documentation=https://docs.cloudreve.org<br>After=network.target<br>After=mysqld.service<br>Wants=network.target<br><br>[Service]<br>WorkingDirectory=/PATH_TO_CLOUDREVE<br>ExecStart=/PATH_TO_CLOUDREVE/cloudreve<br>Restart=on-abnormal<br>RestartSec=5s<br>KillMode=mixed<br><br>StandardOutput=null<br>StandardError=syslog<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>载入进程守护并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl start cloudreve<br>systemctl enable cloudreve<br></code></pre></td></tr></table></figure></li></ol><h3 id="设置Nginx反代"><a href="#设置Nginx反代" class="headerlink" title="设置Nginx反代"></a>设置Nginx反代</h3><ol><li><p>在宝塔面板的站点设置中，添加反向代理，配置按下图类比设置(主要还是第二步)</p><p><img src="/2021/04/images/BT_2.png" alt="BT设置反向代理"></p></li><li><p>点击配置文件，将原本的<code>location /&#123;&#125;</code>的内容替换如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">location / &#123;<br>    proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>    proxy_redirect off;<br>    proxy_pass http://127.0.0.1:5212;<br><br>    <span class="hljs-comment">## 如果您要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸</span><br>    <span class="hljs-comment">## client_max_body_size 20000m;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>保存配置文件，通过宝塔中设置的网站域名即可直接访问网盘地址</p></li></ol><h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><ol><li>在FreeSSL获取证书以后，在<code>KeyManager</code>中导出证书和私钥，分别为<code>.crt</code>和<code>.key</code>文件</li><li>在站点设置中找到SSL，使用<code>其他证书</code>，然后通过编辑器打开<code>crt</code>证书文件和<code>key</code>文件，分别将其中的内容复制到<code>密钥(KEY)</code>和<code>证书(PEM格式)</code>中</li><li>保存并开启强制HTTPS，即可通过SSL访问云盘并且进行配置了。</li></ol><p>参考网站：</p><ol><li><a href="https://blog.lanhui.co/1623.html">Cloudreve对接onedrive搭建属于自己的网盘系统 (lanhui.co)</a></li><li><a href="https://docs.cloudreve.org/">CloudReve官方文档</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux配置网络唤醒</title>
    <link href="/2021/04/04/Ubuntu_WOL/"/>
    <url>/2021/04/04/Ubuntu_WOL/</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装网络管理工具</p><p><code>sudo apt install ethtool</code></p></li><li><p>查询网口信息</p><p><code>ip a</code></p><p>记录需要启动的网口名字</p></li><li><p>通过指令手动启动wol服务</p><p><code>ethtool -s [INTERFACE] wol g</code></p></li><li><p>查询是否成功</p><p><code>ethtool [INTERFACE]</code></p><p>输出信息中如果显示<code>wol:g</code>则代表开启成功</p></li><li><p>创建开机进程</p><p><code>sudo vi /etc/systemd/system/wol.service</code></p></li><li><p>写入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=Configure Wake On LAN<br><br>[Service]<br>Type=oneshot<br>ExecStart=/sbin/ethtool -s [INTERFACE] wol g<br><br>[Install]<br>WantedBy=basic.target<br></code></pre></td></tr></table></figure></li><li><p>载入systemd并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> wol.service<br>sudo systemctl start wol.service<br></code></pre></td></tr></table></figure></li></ol><p>参考博客</p><p>1.<a href="https://my.oschina.net/u/4408675/blog/4450878">WOL持久化设置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆序对</title>
    <link href="/2021/04/02/C++Merge_Sort_Check/"/>
    <url>/2021/04/02/C++Merge_Sort_Check/</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL</span><br><span class="hljs-function">LL <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    LL ans = <span class="hljs-built_in">merge</span>(l,mid)+<span class="hljs-built_in">merge</span>(mid+<span class="hljs-number">1</span>,r);<br>    <br>    <span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i]&lt;=q[j]) tmp[cnt++]=q[i++];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tmp[cnt++]=q[j++];<br>            ans+=mid-i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<span class="hljs-comment">//统计</span><br>    <span class="hljs-comment">//扫尾</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[cnt++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[cnt++]=q[j++];<br>    <span class="hljs-comment">//扫描完毕</span><br>    <span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>​    逆序需要的是判断前面数字比后面大的时候组成一个<code>逆序对</code>，而为了扫描的过程中只扫描一部分，不全部扫描即可得出答案，达到优化的目的，这里采用归并排序的思路，在分为A和B两组数组的同时，如果判断到了A中有一个数字比B中另外一个数字大的话，就可以很肯定的判断A之后的数字和该小的B数字都可以组成逆序对，因此可以达到简化运算量的效果。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>对于结束的情况返回<code>return 0</code></li><li><strong>由于分治的过程中十分有可能出现代码规模超过<code>int</code>的情况，所以这里会使用<code>long long</code>进行数据的定义。</strong></li><li>由于等于的情况并不算逆序对，所以在判断<code>if</code>的时候要把等于号带上</li><li>通过先对最原始的”大片段“进行计算逆序对的数量，然后逐渐细化扫描更小的逆序对的数量，在扫描到return之后加起来返回的就是整个数列全部情况的逆序对的总数了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/03/31/C++Merge_Sort/"/>
    <url>/2021/03/31/C++Merge_Sort/</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归终止条件</span><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//取中间值</span><br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r); <span class="hljs-comment">//递归分治 </span><br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>,<span class="hljs-title">i</span><span class="hljs-params">(l)</span>,<span class="hljs-title">j</span><span class="hljs-params">(mid+<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//cnt为tmp数组中的指针，i和j为需要归并的两个范围指针</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;j&lt;=r)<br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) tmp[cnt++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[cnt++]=q[j++];<span class="hljs-comment">//指针对比，将更小的数值移入临时数组tmp当中</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[cnt++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[cnt++]=q[j++];<span class="hljs-comment">//确保所有数字全部被扫描，强制移动并填入数据</span><br>     <br>    <span class="hljs-keyword">for</span>(i = l,j = <span class="hljs-number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];<span class="hljs-comment">//由于是从第l个开始排序，所以i=l而不是=0&#125;</span><br></code></pre></td></tr></table></figure><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><blockquote><p>归并排序的本质是将一长段数据分为两个部分，然后通过两个指针一起从头开始对比，将更小的数字放入一个临时数组中，在数组一和数组二对比完毕以后，临时数组里面的数据理论上来说就是从小到大（或者按照需求改为从大到小）排好了。</p></blockquote><p>​    首先通过位运算划分中间点<code>mid</code>，其中以最小的数组为单位划分为A和B两个数组，这两个数组在分治的”最小单位“下理论上应该是从小到大依次分布的，只不过A、B两个数组相互独立。这个时候利用两个指针<code>i</code>和<code>j</code>对两个数组进行分别扫描，大致示意图如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">A 1 2 3 4 5 6 7<br>  ↑<br>  i<br>B 2 3 4 5 6 7 8<br>  ↑<br>  j<br>  <br>实际的数组: 1 2 3 4 5 6 7 2 3 4 5 6 7 8<br></code></pre></td></tr></table></figure><h3 id="填入临时数组"><a href="#填入临时数组" class="headerlink" title="填入临时数组"></a>填入临时数组</h3><p>​    定义一个临时数组tmp，在扫描的过程中，以上示例来说，由于<code>A</code>的<code>1</code>要比<code>B</code>的<code>2</code>更小，所以<code>1</code>被采用</p><p>，定义一个计数器<code>cnt</code>，将<code>tmp[cnt++]</code>定义为<code>1(更小的数字)</code>然后依次进行填充，直到两个数组都被扫描并且使用完毕</p><h3 id="写入原数组"><a href="#写入原数组" class="headerlink" title="写入原数组"></a>写入原数组</h3><p>这个时候通过一个简单的<code>for</code>循环将排序好的<code>tmp</code>填入需要排序的<code>q</code>数组对应的位置即可。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><code>O(nlogn)</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装Docker</title>
    <link href="/2021/03/30/Using_of_Docker____Unblocknetease_Music/"/>
    <url>/2021/03/30/Using_of_Docker____Unblocknetease_Music/</url>
    
    <content type="html"><![CDATA[<p>参考资料:<br>1.<a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">Docker-从入门到实践</a></p><blockquote><p>在挂载网易云音乐灰色代理的时候终于还是发现了screen后台运行的坏处，经常会出现不小心重启以后忘记开启服务的情况，由于之前一直听说过docker容器，并且灰色代理有现成的docker容器可以使用，在简单查询和操作了一下以后记录一下docker启动网易云音乐并且进行网易云音乐代理的实战</p></blockquote><h2 id="Docker部署和安装"><a href="#Docker部署和安装" class="headerlink" title="Docker部署和安装"></a>Docker部署和安装</h2><ol><li><p>(可选) 通过一键脚本进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>如果要安装测试版的Docker，则用以下脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL test.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror AzureChinaCloud<br></code></pre></td></tr></table></figure></li><li><p>使用<code>apt</code>进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br><br>sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></figure></li><li><p>替换国内软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure></li><li><p>启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure></li><li><p>检测是否已经设置镜像</p><blockquote><p>请首先执行以下命令，查看是否在 <code>docker.service</code> 文件中配置过镜像地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\-\-registry\-mirror&#x27;</span><br></code></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p></blockquote></li><li><p>设置镜像</p><p>创建并编辑<code>/etc/docker/daemon.json</code></p><p>写入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  &quot;registry-mirrors&quot;: [<br>    &quot;https://hub-mirror.c.163.com&quot;,<br>    &quot;https://mirror.baidubce.com&quot;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>检测是否正常</p><p><code>docker run --rm hello-world</code></p><p>通过检查返回信息检查是否成功安装并且部署Docker环境</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fdisk分区教程</title>
    <link href="/2021/03/25/Openwrt_Manual_Disk_Allocate/"/>
    <url>/2021/03/25/Openwrt_Manual_Disk_Allocate/</url>
    
    <content type="html"><![CDATA[<p>参考地址：<br><a href="https://blog.csdn.net/xjtumengfanbin/article/details/106871591">CSDN-树莓派Openwrt SD卡扩展问题</a></p><p>​    在给自己的R2S使用64G的SD卡的时候，安装完毕系统启动发现内存卡中有将近50多G的空间没有得到合理的使用，记录一下通过网上树莓派磁盘扩展分区的步骤来在R2S上同样对SD卡进行分区拓展</p><h2 id="Openwrt磁盘拓展"><a href="#Openwrt磁盘拓展" class="headerlink" title="Openwrt磁盘拓展"></a>Openwrt磁盘拓展</h2><ol><li><p>磁盘检查</p><p><code>df -h</code>  检查已经使用的磁盘容量</p><p><code>fdisk /dev/mmcblk0</code>  查看磁盘分区，并进行部分操作</p></li><li><p>检查磁盘分区情况并且进行分区</p><p>在<code>fdisk</code>后的<code>Command( m for help):</code>后输入<code>p</code>来查看分区情况</p><p><img src="/2021/03/images/opsd1.png" alt="fdiskp"></p><p>其中可以看到最后分区的<code>End</code>为<code>3817471</code></p></li><li><p>新建磁盘</p><p>输入<code>n</code>进行新建磁盘，之后会有几个询问，分别对应以下几点</p><ul><li>输入磁盘编码，一般按Default的设置即可</li><li>输入扇区的起始位置，这里输入最后一个分区+1的数值大小，比如上图中<code>End</code>后为<code>3817471</code>，那我这里就输入<code>3817472</code></li><li>输入终止扇区，这里可以填入Default设置，就会设置最大可用扇区</li><li>输入<code>w</code>进行保存</li></ul></li><li><p>把新建的分区格式化为ext4格式</p><p><code>mkfs.ext4 /dev/mmcblk0p3</code></p></li><li><p>分区挂载</p><ul><li>方法一<ul><li>在Openwrt的管理界面的挂载点中，直接使用”自动挂载”进行磁盘的挂载</li></ul></li><li>方法二<ul><li><code>mount -v -t ext4 -o rw /dev/mmcblk0p3 [pathToMount]</code></li></ul></li></ul></li><li><p>通过<code>df -h</code>命令查看，可以发现已经挂载成功</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看Ubuntu下设备温度</title>
    <link href="/2021/03/25/laptop_temperature_sensor/"/>
    <url>/2021/03/25/laptop_temperature_sensor/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装lm-sensors</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs html">sudo apt-get install lm-sensors<br></code></pre></td></tr></table></figure></li><li><p>运行</p><p><code>sensors</code><br><del>好水的一篇Blog</del></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建Swap分区</title>
    <link href="/2021/03/25/zram_and_swap_in_Ubunut/"/>
    <url>/2021/03/25/zram_and_swap_in_Ubunut/</url>
    
    <content type="html"><![CDATA[<p>参考网址:<br>1.<a href="https://imhy.zbyzbyzby.com/wordpress/?p=815">Ubuntu开启zram和zswap~</a><br>2.<a href="https://blog.gloriousdays.pw/2018/11/30/memory-compress-using-zram/">使用zram进行内存压缩</a><br>3.<a href="https://www.jianshu.com/p/498858f8d704">Ubuntu添加swap分区</a></p><h2 id="创建Swap分区"><a href="#创建Swap分区" class="headerlink" title="创建Swap分区"></a>创建Swap分区</h2><blockquote><p>Swap分区在系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p><p>Swap分区虽然可以达到扩大内存的作用，但缺点依旧很明显，相比直接使用物理内存，Swap必然速度上会出现一定的取舍。</p></blockquote><ol><li><p>新建一个文件夹来作为swap的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">mkdir swap<br>cd swap<br>sudo dd if=/dev/zero of=sfile bs=1024 count=2000000<br></code></pre></td></tr></table></figure><p>其中<code>sfile</code>是文件的名字，可以自己设置，<code>count=2000000</code>是Swap分区的大小，这里指2G</p></li><li><p>转化为swap文件</p><p><code>sudo mkswap sfile</code></p></li><li><p>激活swap文件</p><p><code>sudo swapon sfile</code></p></li><li><p>查看效果</p><p><code>free -m</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">              total        used        free      shared  buff/cache   available<br>Mem:            478          61         184           3         233         379<br>Swap:          2704           0        2704<br></code></pre></td></tr></table></figure><p>已经成功挂载了</p></li><li><p>添加开机加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/fstab<br></code></pre></td></tr></table></figure><p>修改配置文件，添加Swap文件(Swap文件的路径为<code>/root/swap/sfile</code>)</p><p><code>/root/swap/sfile    none            swap    sw        0 0</code></p><p>类似如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/vda1           /               ext4    defaults  1 1<br>/dev/vda2           swap            swap    defaults  0 0<br>/root/swap/sfile    none            swap    sw        0 0<br>none                /dev/shm        tmpfs   defaults  0 0<br></code></pre></td></tr></table></figure></li></ol><h2 id="使用zram进行内存压缩"><a href="#使用zram进行内存压缩" class="headerlink" title="使用zram进行内存压缩"></a>使用zram进行内存压缩</h2><blockquote><p>对于像 KS-3 这样只有 4GB 内存的小内存服务器，如果想在上面跑一些比较复杂的服务，经常会遇到内存不足的问题。一般说到内存不足，第一反应都是加 swap 空间，但是对于机械硬盘的场景，添加盲目添加 swap 空间并不是一个好的选择，因为这样会显著增加系统整体的 latency。这个时候 zram 就可以派上用场了。</p><p>zram 是在 Linux Kernel 3.2 加入的一个模块，其功能是在内存中开辟一块空间，用来存储压缩后的内存数据，这样可以在牺牲一定的 CPU Cycle 的情况下，在内存中存储尽量多的数据而不需要写入到磁盘。</p></blockquote><ol><li><p>安装zram-config，并重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install zram-config<br>sudo reboot<br></code></pre></td></tr></table></figure></li><li><p>通过zramctl查看zram的情况(默认情况下ALGORITHM为lzo)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME       ALGORITHM DISKSIZE DATA COMPR TOTAL STREAMS MOUNTPOINT<br>/dev/zram0 lz4         239.4M   4K   63B    4K       1 [SWAP]<br></code></pre></td></tr></table></figure><blockquote><p>注意到这里的压缩算法，有两种算法 lzo 和 lz4 可选，默认是 lzo。根据 <a href="https://github.com/lz4/lz4">Benchmark</a>，lz4 的压缩和解压性能在压缩率和 lzo 持平的情况下显著高于后者，因此我们应该采用 lz4 而非 lzo 以获得更高的系统效率。</p></blockquote></li><li><p>修改配置文件来使用lz4算法</p><p><code>usr/bin/init-zram-swapping</code></p><p>将源文件的以下部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># initialize the devices</span></span><br>for i in $(seq $&#123;NRDEVICES&#125;); do<br>  DEVNUMBER=$((i - 1))<br>  echo $mem &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/disksize<br>  mkswap /dev/zram$&#123;DEVNUMBER&#125;<br>  swapon -p 5 /dev/zram$&#123;DEVNUMBER&#125;<br>done<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># initialize the devices</span></span><br>for i in $(seq $&#123;NRDEVICES&#125;); do<br>  DEVNUMBER=$((i - 1))<br>  echo lz4 &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/comp_algorithm<br>  echo $mem &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/disksize<br>  mkswap /dev/zram$&#123;DEVNUMBER&#125;<br>  swapon -p 5 /dev/zram$&#123;DEVNUMBER&#125;<br>done<br></code></pre></td></tr></table></figure></li><li><p>载入新的配置</p><p><code>systemctl restart zram-config</code></p></li></ol><h2 id="开启ZSwap"><a href="#开启ZSwap" class="headerlink" title="开启ZSwap"></a>开启ZSwap</h2><ol><li><p>编辑grub文件</p><p><code>sudo vi /etc/default/grub</code></p></li><li><p>在文件末尾加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GRUB_CMDLINE_LINUX=”zswap.enabled=1″<br></code></pre></td></tr></table></figure><p>保存退出</p></li><li><p>在终端输入命令</p><p><code>sudo update-grub</code></p></li><li><p>重启系统</p></li></ol><blockquote><p>zswap是一种新的轻量化后端构架，将进程中正交换出的页面压缩，并存储在一个基于RAM的内存缓冲池中。除一些为低内存环境预留的一小部分外，zswap缓冲池不预先分配，按需增加，最大尺寸可用户自定义。</p><p>Zswap启动存在于主线程中的一个前端，称为frontswap，zswap&#x2F;frontswap进程在页面真正交换出之前监听正常交换路径，所以现有的交换页面选择机理不变。</p><p>Zswap也引入重要功能，当zswap缓冲池满时自动驱除页面从zswap缓冲池到swap设备。防止陈旧页面填满缓冲池。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier配置Moon服务器</title>
    <link href="/2021/03/24/Moon_Server_of_ZeroTier/"/>
    <url>/2021/03/24/Moon_Server_of_ZeroTier/</url>
    
    <content type="html"><![CDATA[<p>参考链接:<br>1.<a href="https://post.smzdm.com/p/adwrepgk/">什么值得买-ZeroTier配置Moon节点</a></p><p>2.<a href="https://www.zerotier.com/manual/#4_4">ZeroTier官方手册</a></p><h2 id="安装Moon服务器的作用"><a href="#安装Moon服务器的作用" class="headerlink" title="安装Moon服务器的作用"></a>安装Moon服务器的作用</h2><p>​    ZeroTier本身的PLANET服务器位于国外，并且由于免费的性质以至于在一些高峰时期经常出现无法打通隧道的情况，这个时候通过自己搭建国内的Moon节点并且进行配置可以达到国内中转加速的作用。</p><h2 id="Moon服务器在VPS上的搭建"><a href="#Moon服务器在VPS上的搭建" class="headerlink" title="Moon服务器在VPS上的搭建"></a>Moon服务器在VPS上的搭建</h2><ol><li><p>将需要设置moon节点的VPS加入到需要加速的局域网内</p><p><code>zerotier-cli join &lt;network id&gt;</code></p></li><li><p>生成moon模板</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/zerotier-one<br>zerotier-idtool initmoon identity.public &gt; moon.json<br></code></pre></td></tr></table></figure></li><li><p>修改moon.json</p><p><code>vi moon.json</code></p><p>修改<code>stableEndpoints</code>为VPS的公网IP，可以添加ipv6地址，例如：</p><p><code>&quot;stableEndpoints&quot;: [ &quot;10.0.0.2/9993&quot;,&quot;2001:abcd:abcd::1/9993&quot; ]</code></p><p>完整的文件内容示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;deadbeef00&quot;</span>,<br>  <span class="hljs-string">&quot;objtype&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>,<br>  <span class="hljs-string">&quot;roots&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;identity&quot;</span>: <span class="hljs-string">&quot;deadbeef00:0:34031483094...&quot;</span>,<br>      <span class="hljs-string">&quot;stableEndpoints&quot;</span>: [ <span class="hljs-string">&quot;10.0.0.2/9993&quot;</span>,<span class="hljs-string">&quot;2001:abcd:abcd::1/9993&quot;</span> ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;identity&quot;</span>: <span class="hljs-string">&quot;feedbeef11:0:83588158384...&quot;</span>,<br>      <span class="hljs-string">&quot;stableEndpoints&quot;</span>: [ <span class="hljs-string">&quot;10.0.0.3/9993&quot;</span>,<span class="hljs-string">&quot;2001:abcd:abcd::3/9993&quot;</span> ]<br>    &#125;<br>  ],<br>  <span class="hljs-string">&quot;signingKey&quot;</span>: <span class="hljs-string">&quot;b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0&quot;</span>,<br>  <span class="hljs-string">&quot;signingKey_SECRET&quot;</span>: <span class="hljs-string">&quot;ffc5dd0b2baf1c9b220d1c9cb39633f9e2151cf350a6d0e67c913f8952bafaf3671d2226388e1406e7670dc645851bf7d3643da701fd4599fedb9914c3918db3&quot;</span>,<br>  <span class="hljs-string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="hljs-string">&quot;b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0&quot;</span>,<br>  <span class="hljs-string">&quot;worldType&quot;</span>: <span class="hljs-string">&quot;moon&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成moon签名文件</p><p><code>zerotier-idtool genmoon moon.json</code></p></li><li><p>通过winscp等工具将<code>000000xxxx.moon</code>的签名文件拷贝下来，或者记住<code>moon.json</code>中<code>&quot;id&quot;: &quot;idtoremember&quot;</code>的<code>id</code></p></li><li><p>将moon节点加入网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> moons.d<br><span class="hljs-built_in">mv</span> ./*.moon ./moons.d<br></code></pre></td></tr></table></figure></li><li><p>重启ZeroTier，到此Moon服务器的配置结束。</p></li></ol><h2 id="在客户端启用配置好的节点"><a href="#在客户端启用配置好的节点" class="headerlink" title="在客户端启用配置好的节点"></a>在客户端启用配置好的节点</h2><h3 id="方法一：通过ID直接加入"><a href="#方法一：通过ID直接加入" class="headerlink" title="方法一：通过ID直接加入"></a>方法一：通过ID直接加入</h3><ol><li><p>在搭建moon服务器的第五步中，记录下moon节点的id，然后在客户端上运行命令</p><p><code>zerotier-cli orbit idtoremeber idtoremeber</code></p></li></ol><h3 id="方法二：通过添加签名文件加入"><a href="#方法二：通过添加签名文件加入" class="headerlink" title="方法二：通过添加签名文件加入"></a>方法二：通过添加签名文件加入</h3><ol><li><p>在不同设备的ZeroTier根目录下添加moons.d文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">其中，不同系统对应的ZeroTier的位置如下：<br>Windows: C:\ProgramData\ZeroTier\One<br>Macintosh: /Library/Application Support/ZeroTier/One)<br>Linux: /var/lib/zerotier-one<br>FreeBSD/OpenBSD: /var/db/zerotier-one<br></code></pre></td></tr></table></figure></li><li><p>将生成的0000xxx.moon文件放置于moons.d文件夹下</p></li></ol><h4 id="Openwrt下ZeroTier配置Moon服务器"><a href="#Openwrt下ZeroTier配置Moon服务器" class="headerlink" title="Openwrt下ZeroTier配置Moon服务器"></a>Openwrt下ZeroTier配置Moon服务器</h4><blockquote><p>OpenWrt需要修改一个脚本，因为其var目录是一个内存虚拟的临时目录，重启后原有配置不会保留。</p></blockquote><ol><li><p>通过ssh连接到Openwrt并修改zerotier的启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/init.d/zerotier<br></code></pre></td></tr></table></figure></li><li><p>在<code>add_join()&#123;&#125;</code>上方插入两行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$CONFIG_PATH</span>/moons.d<br><span class="hljs-built_in">cp</span> /home/moons.d/* <span class="hljs-variable">$CONFIG_PATH</span>/moons.d/<br></code></pre></td></tr></table></figure><p>如下图所示:</p><p><img src="/2021/03/images/ZeroTier_Moon.png" alt="ZeroTier的Moon节点"></p></li><li><p>在&#x2F;home文件夹下创建moons.d文件夹（修改<code>cp /home/moons.d</code>可以修改需要设置的路径）</p></li><li><p>把moon的签名文件00000xxx.moon放于该文件夹内，并重启ZeroTier即可</p></li></ol><h5 id="补充：解决Openwrt重启后ZeroTier的ID重新分配的问题"><a href="#补充：解决Openwrt重启后ZeroTier的ID重新分配的问题" class="headerlink" title="补充：解决Openwrt重启后ZeroTier的ID重新分配的问题"></a>补充：解决Openwrt重启后ZeroTier的ID重新分配的问题</h5><ol><li><p>启动Openwrt上的ZeroTier</p></li><li><p>输入以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -a /var/lib/zerotier-one /etc/zerotier<br></code></pre></td></tr></table></figure></li><li><p>修改<code>/etc/config/zerotier</code>的配置文件，添加以下内容</p><p><code>option config_path &#39;/etc/zerotier&#39;</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第K个数字</title>
    <link href="/2021/03/22/Cpp_The_K_Number/"/>
    <url>/2021/03/22/Cpp_The_K_Number/</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qchoise</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span> q[l];<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[(l + r) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (q[++i] &lt; x)<br>        &#123;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q[--j] &gt; x)<br>        &#123;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>            <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (pos &lt;= sl)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">qchoise</span>(q, l, j, pos);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qchoise</span>(q, j + <span class="hljs-number">1</span>, r, pos - sl);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><h3 id="扫描-交换"><a href="#扫描-交换" class="headerlink" title="扫描+交换"></a>扫描+交换</h3><p>第一步首先和之前的快速排序算法相同，首先在第一步的时候随机取一个位置，然后将这个位置的数字<code>q[x]</code>记录下来，然后一个指针<code>i</code>从前向后扫描数列，一个指针<code>j</code>从后向前扫描数列，最后一般来说最后<code>i</code>会在<code>x</code>的位置停下，而<code>j</code>会停在x的前一个。这样第一轮的排序就达成了，在<code>q[x]</code>前面的数字都比<code>q[x]</code>小，在<code>q[x]</code>后面的数字都比它大。</p><h3 id="位置排序"><a href="#位置排序" class="headerlink" title="位置排序"></a>位置排序</h3><p>将整个数列分为<code>Left</code>和<code>Right</code>两部分，统计<code>Left</code>和<code>Right</code>的数量，如果<code>pos</code>&lt;<code>Left的数量</code>，则说明需要的数字在<code>Left</code>序列里面，这个时候只需要再次对<code>Left</code>序列进行递归，如果数字在<code>Right</code>序列中，则说明<code>pos</code>的位置变成了第<code>pos-[Left的数量]</code>个，然后只需要对右半边进行递归即可</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>在不断进行递归操作后，将会只剩下<code>pos</code>位置的数字，也就是第<code>pos</code>个数字，这个时候返回的结果就是第<code>pos</code>个数字了。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>第一次扫描的时候时间复杂度为n，第二次扫描的时候由于是扫描一半，所以最多也只有1&#x2F;2n，然后依次下去就是1&#x2F;4n，1&#x2F;8n…..，由数学知识可以得出，n+1&#x2F;2n+… 最多不会超过2n，所以复杂度为<code>O(n)</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ncu-iptv引导</title>
    <link href="/2021/03/21/iptv/"/>
    <url>/2021/03/21/iptv/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于学校（南昌大学）要求每个月必须看满五个小时的iptv，并且iptv直接在浏览器上观看是需要安装flash或者包含flash的浏览器的。而如今flash的末路使得不少人头疼，在github上偶然发现有学长用go语言编写了一个脚本，在这里记录一下在Linux上的使用过程。</p></blockquote><ol><li><p>脚本来源 <a href="https://github.com/shuwenwei/iptv-helper">南昌大学IPTV</a></p></li><li><p>获取脚本并进行编译</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/shuwenwei/iptv-helper.git<br><span class="hljs-built_in">cd</span> iptv-helper/<br></code></pre></td></tr></table></figure></li><li><p>安装编译go的库依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update &amp;&amp; sudo apt install golang-go<br></code></pre></td></tr></table></figure></li><li><p>编译文件并设置权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">go build main.go<br>go build -o iptv<br><span class="hljs-built_in">chmod</span> 777 iptv<br></code></pre></td></tr></table></figure></li><li><p>通过screen在后台运行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install screen<br>screen -R iptv<br></code></pre></td></tr></table></figure></li><li><p>编辑iptv.toml为自己的信息</p><p><code>vi iptv.toml</code></p><p>修改为自己的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">[user]<br><span class="hljs-comment">#用户名</span><br>Username = <span class="hljs-string">&quot;[username]&quot;</span><br><span class="hljs-comment">#密码</span><br>Password = <span class="hljs-string">&quot;[password]&quot;</span><br>[app]<br><span class="hljs-comment">#每个goroutine观看的时间(分钟)</span><br>Tasktime = 10<br><span class="hljs-comment">#同时观看数量(goroutine数), 总播放时间 = Tasknum * Tasktime</span><br>Tasknum = 10<br></code></pre></td></tr></table></figure></li><li><p>保存文件，并在对应的screen下运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./iptv<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ncu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openwrt配置Frpc</title>
    <link href="/2021/03/20/Manual_Frpc_in_Openwrt/"/>
    <url>/2021/03/20/Manual_Frpc_in_Openwrt/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Frpc在Openwrt上的客户端多多少少有点问题，为了方便自己使用，在这里记录一下如果用命令行启动和编辑Frpc的流程</p></blockquote><ol><li><p>首先，在 <a href="https://github.com/fatedier/frp/releases/">fatedier&#x2F;frp</a>中下载最新版的frp打包程序，以下以0.35.1版本为例</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz<br>tar -xvf frp_0.35.1_linux_amd64.tar.gz<br><span class="hljs-built_in">rm</span> frp_0.35.1_linux_amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>首先切换到frp的目录下，把frpc和配置文件放于service对应的目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> frp_0.35.1_linux_amd64<br>sudo <span class="hljs-built_in">mv</span> frpc /usr/bin<br>sudo <span class="hljs-built_in">chmod</span> 755 /usr/bin/frpc <br>sudo <span class="hljs-built_in">mkdir</span> /etc/frp<br>sudo <span class="hljs-built_in">mv</span> frpc.ini /etc/frp <br></code></pre></td></tr></table></figure></li><li><p>之后通过指令编辑frpc.ini</p><p><code>sudo vi /etc/frp/frpc.ini</code></p></li><li><p>之后，编辑&#x2F;etc&#x2F;init.d&#x2F;frpc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh /etc/rc.common</span><br> <br> START=90<br> STOP=90<br> SERVICE=frpc<br> USE_PROCD=1<br> PROC=<span class="hljs-string">&quot;/usr/bin/frpc -c /etc/frp/frpc.ini&quot;</span><br> <br> <span class="hljs-function"><span class="hljs-title">start_service</span></span>()<br> <br> &#123;<br>     procd_open_instance<br>     procd_set_param <span class="hljs-built_in">command</span> <span class="hljs-variable">$PROC</span><br>     procd_set_param respawn<br>     procd_close_instance<br> <br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-title">service_triggers</span></span>()<br> &#123;<br>     procd_add_reload_trigger <span class="hljs-string">&quot;rpcd&quot;</span><br> &#125;<br></code></pre></td></tr></table></figure><blockquote><p>脚本来自<a href="https://juejin.cn/post/6844904014446854158">OpenWRT&#x2F;LEDE下开机脚本</a></p></blockquote></li><li><p>配置文件就结束了之后只需要直接启用和启动frpc即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/init.d/frp start<br>/etc/init.d/frp <span class="hljs-built_in">enable</span> &amp;&amp; <span class="hljs-built_in">echo</span> on<br></code></pre></td></tr></table></figure></li><li><p>另外由于不需要配置frps服务，可以回到上级目录并把下载的文件全部删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">rm</span> -rf frp_0.35.1_linux_amd64<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDNS配置</title>
    <link href="/2021/03/19/DDNS_of_ddns-go/"/>
    <url>/2021/03/19/DDNS_of_ddns-go/</url>
    
    <content type="html"><![CDATA[<p>本文脚本来源：[ddns-go](<a href="https://github.com/jeessy2/ddns-go">jeessy2&#x2F;ddns-go: 简单好用的DDNS。自动更新域名解析到公网IP(支持阿里云、腾讯云dnspod、Cloudflare、华为云) (github.com)</a>)</p><ol><li><p>在脚本来源的<a href="https://github.com/jeessy2/ddns-go/releases">release版本</a>中下载对应版本的ddns-go</p></li><li><p>将脚本上传到服务器内，然后通过以下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bsh">sudo ./ddns-go -s install<br></code></pre></td></tr></table></figure></li><li><p>在<code>http://ip:9876</code>里面进行配置即可</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DDNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows计算文件Hash</title>
    <link href="/2021/03/17/WindowsCheckHash/"/>
    <url>/2021/03/17/WindowsCheckHash/</url>
    
    <content type="html"><![CDATA[<p>​    每次要查询一个文件的hash值的时候总要打开一个hash校验工具，觉得有些麻烦了，加上也不是所有文件都会经常需要校验，就常常并不想单独下载一个工具，查询到Windows有自带的hash校验指令，于是记录一下，以下内容摘自<a href="https://zhuanlan.zhihu.com/p/344545687">知乎</a></p><ol><li><p>使用certutil</p><blockquote><p>Windows从Win7开始，包含了一个CertUtil命令，可以通过这个命令来计算指定文件的杂凑值(Hash Value)</p></blockquote><p>使用的指令为:</p><p><code>certutil -hashfile [fileName] [algorithm]</code></p><p>其中<code>[algorithm]</code>指不同的hash算法，可以取的值有：<strong>MD2、MD4、MD5、SHA1、SHA256、SHA384、SHA512</strong>。</p><p>例子:</p><p><code>certutil -hashfile D:\test.txt MD5</code></p></li><li><p>使用Get-FileHash</p><p><code>Get-FileHash [fileName] -Algorithm [algorithm]</code></p><p>其中，支持的算法有<strong>MACTripleDES、MD5、RIPEMD160、SHA1、SHA256、SHA384、SHA512</strong>。</p><p>显示效果:</p><p><img src="/2021/03/images/HashCheck_1.png" alt="Hash_1"></p><p>其中，为了方便观察可以通过管道使用Format-List</p><p><code>Get-FileHash .\test.txt -Algorithm SHA512 | Format-List</code></p><p>显示效果:</p><p><img src="/2021/03/images/HashCheck_2.png" alt="Hash_2"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展Ubuntu服务器LVM分区</title>
    <link href="/2021/03/17/Ubuntu_Disk/"/>
    <url>/2021/03/17/Ubuntu_Disk/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<a href="https://blog.csdn.net/Fly_1213/article/details/105142427">解决 Linux &#x2F;dev&#x2F;mapper&#x2F;ubuntu–vg-ubuntu–lv 磁盘空间不足的问题</a></p></blockquote><ol><li><p>通过命令查看LVM卷组的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># vgdisplay</span><br>  --- Volume group ---<br>  VG Name               ubuntu-vg<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  2<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                1<br>  Open LV               1<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               &lt;930.01 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238082<br>  Alloc PE / Size       51200 / 200.00 GiB<br>  Free  PE / Size       186882 / &lt;730.01 GiB<br></code></pre></td></tr></table></figure></li><li><p>可以看到可扩容大小</p><p><code>Free  PE / Size       186882 / &lt;730.01 GiB</code></p></li><li><p>使用命令进行扩容</p><p>按不同需求有以下命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">lvextend -L 10G /dev/mapper/ubuntu--vg-ubuntu--lv      //增大或减小至19G<br>lvextend -L +10G /dev/mapper/ubuntu--vg-ubuntu--lv     //增加10G<br>lvreduce -L -10G /dev/mapper/ubuntu--vg-ubuntu--lv     //减小10G<br>lvresize -l  +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv   //按百分比扩容<br><br>resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv            //执行调整<br></code></pre></td></tr></table></figure><p>具体操作:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># lvextend -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv</span><br>  Size of logical volume ubuntu-vg/ubuntu-lv changed from 200.00 GiB (51200 extents) to &lt;930.01 GiB (238082 extents).<br>  Logical volume ubuntu-vg/ubuntu-lv successfully resized.<br>root@azhal:/mnt/Ar2D<span class="hljs-comment"># resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span><br>resize2fs 1.45.5 (07-Jan-2020)<br>Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required<br>old_desc_blocks = 25, new_desc_blocks = 117<br>The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 243795968 (4k) blocks long.<br></code></pre></td></tr></table></figure></li><li><p>检查是否扩容成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># vgdisplay</span><br>  --- Volume group ---<br>  VG Name               ubuntu-vg<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  3<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                1<br>  Open LV               1<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               &lt;930.01 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238082<br>  Alloc PE / Size       238082 / &lt;930.01 GiB<br>  Free  PE / Size       0 / 0<br></code></pre></td></tr></table></figure><p>可以看到Free Size已经变成0，即扩容成功。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建ZeroTier网络控制台</title>
    <link href="/2021/03/16/ZeroTier_Controller/"/>
    <url>/2021/03/16/ZeroTier_Controller/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本来的理解</strong>: 在使用ZeroTier的时候经常会出现穿透失败，或者穿透延迟过大但是中转服务器不好用的情况，之前有参考过网上的教程来通过一台国内的VPS搭建自己的MOON节点来达到加速的目的，但是最后的效果不尽人意，而且还存在安卓端添加mood节点并不轻松的问题，所以在这里采取直接通过<a href="https://github.com/key-networks/ztncui">key-networks&#x2F;ztncui: ZeroTier network controller UI</a>搭建自己的ZeroTier根服务器</p></blockquote><p>​    最近在使用<code>zerotier-cli listpeers</code>指令的时候发现设置的控制器是一个<code>LEAF</code>而不是本来预期的<code>PLANT</code>，在查阅了一部分资料之后发现如果想要加速网络的话目前比较好的方便还是<code>MOON</code>服务器进行中转，详情参考另外一篇<code>ZeroTier下Moon服务器的搭建</code>。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><ol><li><p>准备好一台在国内，至少开放端口3443端口的服务器（暂未测试对其他端口是否有需求）</p></li><li><p>在服务器内安装ZeroTier，以下为一键安装脚本</p><p><code>curl -s https://install.zerotier.com | sudo bash</code></p><p>如果服务器有安装GPG，则需要多几个步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">curl -s <span class="hljs-string">&#x27;https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg&#x27;</span> | gpg --import &amp;&amp; \<br><span class="hljs-keyword">if</span> z=$(curl -s <span class="hljs-string">&#x27;https://install.zerotier.com/&#x27;</span> | gpg); <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$z</span>&quot;</span> | sudo bash; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="部署ztncui"><a href="#部署ztncui" class="headerlink" title="部署ztncui"></a>部署ztncui</h2><h3 id="RPM-installation-on-EL7"><a href="#RPM-installation-on-EL7" class="headerlink" title="RPM installation on EL7"></a>RPM installation on EL7</h3><ol><li><p><code>sudo yum install https://download.key-networks.com/el7/ztncui/1/ztncui-release-1-1.noarch.rpm -y</code></p></li><li><p><code>sudo yum install ztncui -y</code></p></li><li><p>(可选择)：添加服务器自己的TLS&#x2F;SSL证书，或者添加服务器自认证的证书 - <strong>后文有教程</strong></p></li><li><p>开放服务器的3443端口(已开放可忽略)</p></li><li><p><code>sudo sh -c &quot;echo &#39;HTTPS_PORT=3443&#39; &gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo sh -c &quot;echo &#39;NODE_ENV=production&#39; &gt;&gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo systemctl restart ztncui</code></p></li><li><p>通过HTTPS来在服务器的3443端口访问控制界面，比如</p><p><code>e.g. https://my.network.controller:3443</code></p></li><li><p>通过默认的账号<code>admin</code>和密码<code>password</code>.</p></li></ol><h3 id="DEB-installation-on-Debian-x2F-Ubuntu"><a href="#DEB-installation-on-Debian-x2F-Ubuntu" class="headerlink" title="DEB installation on Debian&#x2F;Ubuntu"></a>DEB installation on Debian&#x2F;Ubuntu</h3><ol><li><p><code>curl -O https://s3-us-west-1.amazonaws.com/key-networks/deb/ztncui/1/x86_64/ztncui_0.7.1_amd64.deb</code></p></li><li><p><code>sudo apt-get install ./ztncui_0.7.1_amd64.deb</code></p></li><li><p>(可选择)：添加服务器自己的TLS&#x2F;SSL证书，或者添加服务器自认证的证书 - <strong>后文有教程</strong></p></li><li><p>开放服务器的3443端口(已开放可忽略)</p></li><li><p><code>sudo sh -c &quot;echo &#39;HTTPS_PORT=3443&#39; &gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo sh -c &quot;echo &#39;NODE_ENV=production&#39; &gt;&gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo systemctl restart ztncui</code></p></li><li><p>通过HTTPS来在服务器的3443端口访问控制界面，比如</p><p><code>e.g. https://my.network.controller:3443</code></p></li><li><p>通过默认的账号<code>admin</code>和密码<code>password</code>.</p></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li><p>如果要添加额外的监听端口，只需要在<code>/opt/key-network/ztncui</code>下面添加一个<code>.env</code>文件，其中附带一行</p><p><code>HTTPS_PORT=3443</code></p><p>或者任意一个大于1024的端口即可。</p></li><li><p>如果存在<code>.env</code>文件来指向特定的一个端口，那么ztncui将会在所有的端口监听网络，如果希望限制一个特定的IP进行监听的话，只需要在<code>.env</code>文件中再添加一行</p><p><code>HTTPS_HOST=12.34.56.78</code></p><p>来设置自己制定的IP或者域名即可。</p></li></ol><h2 id="添加Self-signed-Certificate"><a href="#添加Self-signed-Certificate" class="headerlink" title="添加Self-signed Certificate"></a>添加Self-signed Certificate</h2><blockquote><p>这种方法添加的证书会存在浏览器警告的问题，不过由于是自己使用，平时也不会一直盯着控制界面，所以影响应该不会很大，如果有共用或者对安全有需求建议自行添加</p></blockquote><p>以下为无脑脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -i<br><span class="hljs-built_in">cd</span> /opt/key-networks/ztncui/etc/tls<br><span class="hljs-built_in">rm</span> -f privkey.pem fullchain.pem<br>openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privkey.pem -out fullchain.pem<br><span class="hljs-built_in">chown</span> ztncui.ztncui *.pem<br><span class="hljs-built_in">chmod</span> 600 privkey.pem<br></code></pre></td></tr></table></figure><h2 id="配置ztnui"><a href="#配置ztnui" class="headerlink" title="配置ztnui"></a>配置ztnui</h2><p>由于ztnui是自己搭建的一个ZeroTier服务器，所以并没有预先设置好的DHCP分配，需要自己设置分配范围。如果需要添加一个新的网络，在使用账号密码登入以后，点击<code>Add network</code>就可以添加一个自己的虚拟局域网络</p><ol><li><p>点击Add network</p></li><li><p>设置好network的名字并create</p></li><li><p>如果需要设置”隐私”与否，在Private中设置即可，这里稍作翻译即可看懂，所以不多解释</p></li><li><p>点击如下图所示的Easy Setup来快速完成一个IPv4的DHCP分配</p><p><img src="/2021/03/images/ztnui_1.png" alt="ESETUP" title="DHCP分配"></p></li><li><p>如下图所示填入对应信息</p><p><img src="/2021/03/images/ztnui_2.png" alt="IPPOOL" title="IP_POOL"></p><p>以下为一个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">网关:192.168.192.0/24<br>起始IP:192.168.192.1<br>终止IP:192.168.192.254<br></code></pre></td></tr></table></figure></li><li><p>然后点submit即可快速创建，也可以通过generate network address的方式自动随机填入。</p></li><li><p>如果需要设置NAT路由，则只需要在Routes下进行配置和添加即可。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/03/15/C++quicksort/"/>
    <url>/2021/03/15/C++quicksort/</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> q[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[(l + r)&gt;&gt;<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span><br>            i++;<br>        <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span><br>            j--;<br>        <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>            <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">qsort</span>(l, j, q);<br>    <span class="hljs-built_in">qsort</span>(j + <span class="hljs-number">1</span>, r, q);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>​    函数需要读入三个数值，一个是通过指针引入数组<code>q[]</code>，另外两个分别是数组的左端点和右端点，在这里设置为<code>l</code>和<code>r</code>在代码中随机取一个位置<code>e.g. x= q[l+r&gt;&gt;1]</code>，作为分界点<code>x=q[]</code>，然后使用两个指针，一个从前向后扫描数组，一个从后向前扫描数组。其中命名从前向后扫描数组的指针为<code>i</code>，而从后向前扫描数组的指针叫为<code>j</code>，然后开始扫描。</p><p>​    在扫描过程中，在这里以从小到大排序为例，因为小的数字需要排列在前面，所以在<code>i</code>从前向后扫描的时候，如果遇到了比<code>q[x]</code>更大的数字则停止继续扫描，这个时候让<code>j</code>从后向前开始扫描，如果遇到了比<code>q[x]</code>更小的数字则停止扫描。</p><p>​    <strong>Tips:由于<code>--j</code>比<code>++i</code>要后运行，实际情况下常常为<code>j</code>穿过<code>i</code>，而<code>i</code>的位置往往不一定是分界位置，所以尽量取<code>j</code>作为分界位置</strong></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>​    由于最后输出的需要是小的数字在前面，而大的数字在后面，所以在扫描都停止以后，将<code>j</code>指向的小数字和<code>i</code>指向的大数字相互交换位置，就可以把他们正确的放于左边小于<code>q[i]</code>，右边大于<code>q[i]</code>，然后再一直进行扫描，直到<code>i</code>和<code>j</code>重合或者穿过的时候停止扫描，然后再通过递归的方式进行多次分段扫描，直到所有的函数都不能再进行交换(<code>if(l&gt;=r) return;</code>)就返回最后的数值。</p><p>​    Ps：在一次扫描+交换结束以后，<code>i</code>左边的所有数字一定小于<code>x</code>，而<code>j</code>右边的数字一定大于<code>x</code></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n*logn)</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>取x的时候如果用位运算，只需要&gt;&gt;1即可，不要移动多了，不然会出现越界或者其他特殊情况（记住模板就好）</li><li>在分治的qsort中（<code>e.g. qosrt(l,j,q)</code>）如果取<code>j</code>则在上方取<code>x=q[？]</code>中绝对不能取<code>x=q[r]</code>的情况，不然会出现由于边界问题导致的死循环。快捷记忆的方法为：<strong>如果x取了右端点，则分治不为右。如果x取了左端点，则分治不为左</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sort内函数调用</title>
    <link href="/2021/03/15/C++sortcheck/"/>
    <url>/2021/03/15/C++sortcheck/</url>
    
    <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span><span class="hljs-comment">//万能头</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> q[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> s)</span><span class="hljs-comment">//比较函数，big&gt;small,输出从大到小</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b&gt;s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> input;<br>    cin&gt;&gt;input;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;input;i++)<br>    &#123;<br>        cin&gt;&gt;q[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(q,q+input,cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;input;i++)<br>    &#123;<br>        cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li><p>sort函数的载入格式为</p><p><code>sort(array.begin(),array.end(),function);</code></p><p>在begin输入起始位置，在end输入结束位置，function输入要对比的函数即可。</p></li><li><p>函数里面包含两个参数，按大于小于号返回比较大&#x2F;比较小的那个，成员函数同样适用，并且sort函数在使用函数进行排序的速度可以达到和快排差不多的效果。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Devc++调试设置</title>
    <link href="/2021/03/15/Devc++Debug/"/>
    <url>/2021/03/15/Devc++Debug/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于蓝桥杯比赛需要使用Devc++作为IDE工具，平时用习惯了vscode的snap和其他功能以后觉得如果不提前适应一下Devc++的编译环境的话在比赛的时候会吃很大的亏，于是决定之后的学习都用Devc++进行，在此记录一下Devc++启用调试之前需要的一些基本设置</p></blockquote><h2 id="启用调试信息-选做"><a href="#启用调试信息-选做" class="headerlink" title="启用调试信息(选做)"></a>启用调试信息(选做)</h2><blockquote><p>貌似在按F5准备进行调试的时候，即使自己没有进行以下设置，Devc++依旧会询问并且可以直接打开进行设置，这里只做一个提前设置的记录，并非必须</p></blockquote><ol><li><p>首先，打开devc++之后，找到上方的Tools(工具)，如下图所示，打开其中的Compiler options(编译选项)</p><p><img src="/2021/03/images/Devc_debug_1.png" alt="工具" title="Tools"></p></li><li><p>然后按下图开启调试信息（设置为yes）</p><p><img src="/2021/03/images/Devc_debug_2.png" alt="调试信息" title="Debug Info"></p></li></ol><h2 id="显示鼠标所指变量"><a href="#显示鼠标所指变量" class="headerlink" title="显示鼠标所指变量"></a>显示鼠标所指变量</h2><ol><li><p>再次打开Tools，并且打开Enviroment options</p></li><li><p>启用下图黄线部分的选项，开启显示指针所指变量的值</p><p><img src="/2021/03/images/Devc_debug_3.png" alt="指针调试" title="Point Debug"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Devc++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建sudo用户</title>
    <link href="/2021/03/15/Ubuntu_add_sudouser/"/>
    <url>/2021/03/15/Ubuntu_add_sudouser/</url>
    
    <content type="html"><![CDATA[<ol><li><p>添加用户</p><p><code>sudo adduser suername</code></p></li><li><p>添加sudo权限</p><p><code>sudo usermod -G sudo username</code></p></li><li><p>添加root权限</p><p>如果要让此用户拥有root权限，执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo chmod 777 /etc/sudoers<br>sudo vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">User privilege specification</span><br><br>root ALL=(ALL) ALL<br><br>username ALL=(ALL) ALL<br></code></pre></td></tr></table></figure><p>然后保存退出</p></li><li><p>修改sudoers的权限</p><p><code>sudo chmod 644 /etc/sudoers</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frpc手动安装引导</title>
    <link href="/2021/03/14/Frpc_config/"/>
    <url>/2021/03/14/Frpc_config/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>部署Frpc并没有找到类似Frps的一键安装脚本，所以只好自己总结安装并启用Frpc的指令，以备不时之需。</p></blockquote><ol><li><p>首先，在 <a href="https://github.com/fatedier/frp/releases/">fatedier&#x2F;frp</a>中下载最新版的frp打包程序，以下以0.35.1版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz<br>tar -xvf frp_0.35.1_linux_amd64.tar.gz<br><span class="hljs-built_in">rm</span> frp_0.35.1_linux_amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>首先切换到frp的目录下，把frpc和配置文件放于service对应的目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> frp_0.35.1_linux_amd64<br>sudo <span class="hljs-built_in">mv</span> frpc /usr/bin<br>sudo <span class="hljs-built_in">chmod</span> 755 /usr/bin/frpc <br>sudo <span class="hljs-built_in">mkdir</span> /etc/frp<br>sudo <span class="hljs-built_in">mv</span> frpc.ini /etc/frp <br></code></pre></td></tr></table></figure></li><li><p>之后通过指令编辑frpc.ini</p><p><code>sudo vi /etc/frp/frpc.ini</code></p></li><li><p>之后，切换到services的目录下，将frpc.service移动到系统的systemctl进程守护下，并启用权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ./systemd<br>sudo <span class="hljs-built_in">mv</span> frpc.service /usr/lib/systemd/system<br>sudo <span class="hljs-built_in">chmod</span> 644 /usr/lib/systemd/system/frpc.service<br>sudo <span class="hljs-built_in">mv</span> frpc@.service /usr/lib/systemd/system<br>sudo <span class="hljs-built_in">chmod</span> 644 /usr/lib/systemd/system/frpc@.service<br></code></pre></td></tr></table></figure></li><li><p>配置文件就结束了之后只需要直接启用和启动frpc即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl <span class="hljs-built_in">enable</span> frpc<br>sudo systemctl start frpc<br></code></pre></td></tr></table></figure></li><li><p>另外由于不需要配置frps服务，可以回到上级目录并把下载的文件全部删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">rm</span> -rf frp_0.35.1_linux_amd64<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frps安装脚本</title>
    <link href="/2021/03/14/Frps_in_Vps/"/>
    <url>/2021/03/14/Frps_in_Vps/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>在部署Frpc的时候需要自己添加service等到systemctl的目录下，过于麻烦，偶然间发现Frps的服务有一键部署脚本，记录一下方便以后自己查阅并使用</p></blockquote><ol><li><p>首先，运行这个一键脚本需要wget，curl和tar至少三个依赖，在部分配置极低或者版本极老的系统中并没有，需要自己手动安装:</p><p><code>sudo apt update &amp;&amp; sudo apt install -y wget curl tar</code></p></li><li><p>安装完毕之后直接运行<a href="https://github.com/MvsCode/frps-onekey">MvsCode的脚本</a>即可</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">wget https://raw.githubusercontent.com/MvsCode/frps-onekey/master/install-frps.sh -O ./install-frps.sh<br><span class="hljs-built_in">chmod</span> 700 ./install-frps.sh<br>./install-frps.sh install<br></code></pre></td></tr></table></figure></li><li><p>之后根据提示，国内VPS使用aliyun安装，国外VPS使用github安装，并且配置好Frps的端口，dashboard的端口还有对应的token，其他选项在端口没有冲突的情况下直接使用默认即可。</p></li><li><p>安装完毕以后通过指令<code>frps start</code>就可以成功运行了。</p></li><li><p>(选看)之前在CentOS上配置Frps以后，发现Frpc并不能正常连接，结果发现应该问题是出于防火墙，由于穿透只是用于自己学习需求，所以暂时采取直接关闭防火墙的方式，具体指令如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl stop firewalld.service<br>systemctl <span class="hljs-built_in">disable</span> firewalld.service<br></code></pre></td></tr></table></figure><p>结果在关闭防火墙以后发现依旧出现有的连接不能正常启动的情况，再次查阅log发现问题出于Frpc连接设置重名，所以只需要设置<strong>不同的Frpc端口穿透名字不同</strong>即可</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu禁用Suspend</title>
    <link href="/2021/03/14/Ubuntu_Ignore/"/>
    <url>/2021/03/14/Ubuntu_Ignore/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间一直希望能有一个自己方便的，不限速的网络存储工具，可以及时存入自己的工具的同时运行一些自己需要的工具，并且为日后Minecraft服务器的搭建做一定准备，先把可能遇到的问题排除</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于用笔记本做服务器的时候并不需要屏幕显示，并且屏幕显示会带来多余的耗电，于是就想试着把笔记本屏幕关上的同时能让Ubuntu Server正常运行，而不是进入休眠模式，索性在网上查阅资料以后发现并不是很困难，以此在这里记录需要修改的操作以便以后查阅</p><ol><li><p>修改logind.conf文件</p><p><code>sudo vim /etc/systemd/logind.conf</code></p></li><li><p>修改logind.conf中的选项，使得笔记本忽略关闭屏幕对系统的影响</p><p>将原本的</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#HandleLidSwitch=suspend</span><br><span class="hljs-comment">#HandleLidSwitchExternalPower=suspend</span><br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HandleLidSwitch=ignore</span><br><span class="hljs-string">HandleLidSwitchExternalPower=ignore</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>reboot</code>指令来重启电脑即可。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim不兼容模式光标错误</title>
    <link href="/2021/03/14/Ubuntu_Vi_ABCD/"/>
    <url>/2021/03/14/Ubuntu_Vi_ABCD/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>参考:</p><ol><li><a href="https://blog.csdn.net/wr132/article/details/53769257">Ubuntu的Vi&#x2F;Vim编辑器的方向键变成ABCD问题_colorfulshark-CSDN博客</a></li><li><a href="http://edyfox.codecarver.org/html/_vimrc_for_beginners.html">Vim入门基本设置</a></li></ol></blockquote><p>在终端输入如下指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set nocp&quot;</span> &gt;&gt; ~/.vimrc<br><span class="hljs-built_in">source</span> ~/.vimrc<br></code></pre></td></tr></table></figure><blockquote><p>出现问题的原因：</p><p>set nocp</p><p>该命令指定让 VIM 工作在不兼容模式下。在 VIM 之前，出现过一个非常流行的编辑器叫 vi。VIM 许多操作与 vi 很相似，但也有许多操作与 vi 是不一样的。如果使用“:set cp”命令打开了兼容模式开关的话，VIM 将尽可能地模仿 vi 的操作模式。</p><p>也许有许多人喜欢“最正统的 vi”的操作模式，对于初学者来说，vi 里许多操作是比较不方便的。</p><p>举一个例子，VIM 里允许在 Insert 模式下使用方向键移动光标，而 vi 里在 Insert 模式下是不能移动光标的，必须使用 ESC 退回到 Normal 模式下才行。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="/2021/03/13/Markdown_Gram/"/>
    <url>/2021/03/13/Markdown_Gram/</url>
    
    <content type="html"><![CDATA[<hr><p>​        通过使用Github Pages + jekyll 的方法也算是搭建了自己的第一篇博客，由于之后post主要都以markdown的文章发布，所以第一篇blog就留给markdown的语法了。</p><p>​        本篇文章参考自<a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法 - 简书 (jianshu.com)</a>，在学习之后做一个汇总，以便自己后续查看和回忆。</p><hr><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 这是一级标题,也就是字最大的</span><br><span class="hljs-section">## 这是二级标题</span><br><span class="hljs-section">### 这是三级标题</span><br><span class="hljs-section">#### 这是四级标题</span><br><span class="hljs-section">##### 这是五级标题</span><br><span class="hljs-section">###### 这是六级标题</span><br></code></pre></td></tr></table></figure><p>其中，不同的效果如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><br><span class="hljs-section">## 一级标题</span><br><br><span class="hljs-section">## 二级标题</span><br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题</span><br><br><span class="hljs-section">##### 五级标题</span><br><br><span class="hljs-section">###### 六级标题</span><br><br>---<br><br><span class="hljs-section">## 二、字体</span><br><br>字体总共有四种排布:<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**加粗**</span><br><br>  <span class="hljs-code">`**这里是要加粗的字体**`</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-emphasis">*斜体*</span><br><br>  <span class="hljs-code">``*这里是要倾斜的字体*`</span>`<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗*</span>**</span>  ~~(就是粗体+斜体啦)~~<br><br>  <span class="hljs-code">``***这里是要斜体并且加粗的字体***`</span>`<br><br><span class="hljs-bullet">-</span> ~~删除线~~<br><br>  <span class="hljs-code">``~~这里是要打删除线的字体~~`</span>`<br><br><span class="hljs-section">## 三、引用</span><br><br>通过使用引用，可以较为美观的引用别人的内容。<br><br>使用示例:<br><br><span class="hljs-code">```markdown</span><br><span class="hljs-code">&gt; 引用</span><br><span class="hljs-code">&gt;&gt; 引用的引用</span><br><span class="hljs-code">&gt;&gt;&gt; 引用的引用的引用</span><br></code></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><p>引用的引用</p><blockquote><p>引用的引用的引用</p></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>分割线有两种实现方式，只要三个，或者三个以上的 ‘-‘ 或者 ‘*’ 就可以达到目的，以下为示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">---</span><br>----<br><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span>**</span><span class="hljs-emphasis">*</span><br></code></pre></td></tr></table></figure><p>效果如下</p><!-- markdownlint-disable MD035--><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>Markdown中的图片分为三个部分，分别是“图片介绍”，“图床地址”和“图片信息title”</p><ul><li>图片介绍是在图片如果加载失败的时候，将会显示的文字内容</li><li>图床地址用于填写图片存放的位置</li><li>图片信息显示的title，为鼠标移动到图片上面的时候显示的小字内容(可有可无)</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片介绍</span>](<span class="hljs-link">图片url &quot;图片信息显示&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下为一个示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">背景</span>](<span class="hljs-link">/images/background-cover.jpg &quot;背景图片&quot;</span>)<br></code></pre></td></tr></table></figure><p>示例:   <img src="/images/background-cover.jpg" alt="背景" title="背景图片"></p><hr><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>超链接的语法和图片的语法很像，唯一的区别就是前面是否有那个感叹号，示例如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">超链接的内容</span>](<span class="hljs-link">超链接地址 &quot;超链接的title&quot;</span>)<br>[<span class="hljs-string">百度</span>](<span class="hljs-link">http://baidu.com</span>)<br></code></pre></td></tr></table></figure><p><a href="http://baidu.com/">百度</a></p><p><a href="https://halc.top/">HalcyonAzure的Blog</a></p><p>其中Markdown本身的语法目前并不支持超链接打开，需要使用html语言进行修改，由于目前暂时并未学习html有关内容，所以这部分内容直接引用<a href="https://www.jianshu.com/p/191d1e21f7ed">简书</a>中的内容，暂时不研究。</p><blockquote><blockquote><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;超链接地址&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>超链接名<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>示例<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>简书<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><p>直接贴语法：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">`单行代码内容`<br><br>​```<br>多行代码内容<br>​```<br></code></pre></td></tr></table></figure><p>示例的话上面的很多内容都采用了代码块的方法，所以就不多做展示了</p><h2 id="八、列表"><a href="#八、列表" class="headerlink" title="八、列表"></a>八、列表</h2><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：无序列表使用’-&#x2F;+&#x2F;*’的任意一种符号都可以达到效果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 内容<br><span class="hljs-bullet">+</span> 内容<br><span class="hljs-bullet">*</span> 内容<br></code></pre></td></tr></table></figure><p>显示效果:</p><!-- markdownlint-disable MD004--><ul><li>内容</li></ul><ul><li>内容</li></ul><ul><li>内容</li></ul><p>如果需要列表嵌套，只需要在回车后重复输入列表(快捷键Tab)即可，示例如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 内容<br><span class="hljs-bullet">    -</span> 内容1<br><span class="hljs-bullet">    -</span> 内容2<br></code></pre></td></tr></table></figure><ul><li>内容<ul><li>内容1</li><li>内容2</li></ul></li></ul><p>Ps: 在使用Typora编辑列表的时候，如果下一行不再需要列表，只需要通过方向键直接移动光标到下一行即可，如果使用回车来换行的话只会进行列表嵌套的操作</p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>通过从无序列表进行引申，可以得到有序列表的语法内容:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 内容1<br><span class="hljs-bullet">2.</span> 内容2<br></code></pre></td></tr></table></figure><p>示例:</p><ol><li>内容1</li><li>内容2</li></ol><h2 id="表格和流程图"><a href="#表格和流程图" class="headerlink" title="表格和流程图"></a>表格和流程图</h2><p>由于这两部分内容目前还没有遇到使用需求，所以这里同样引用简书内的介绍，等真正有需要和使用的时候再返回这条Blog进行更新和整理</p><blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;表头|<span class="hljs-params">表头</span>|表头<br>&gt;---|<span class="hljs-params">:--:</span>|---:<br>&gt;内容|<span class="hljs-params">内容</span>|内容<br>&gt;内容|<span class="hljs-params">内容</span>|内容<br><br>&gt;第二行分割表头和内容。<br>&gt;- 有一个就行，为了对齐，多加了几个<br>&gt;文字默认居左<br>&gt;-两边加：表示文字居中<br>&gt;-右边加：表示文字居右<br>&gt;注：原生的语法两边都要用 |<span class="hljs-params"> 包起来。此处省略</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;姓名|<span class="hljs-params">技能</span>|排行<br>&gt;--|<span class="hljs-params">:--:</span>|--:<br>&gt;刘备|<span class="hljs-params">哭</span>|大哥<br>&gt;关羽|<span class="hljs-params">打</span>|二哥<br>&gt;张飞|<span class="hljs-params">骂</span>|三弟<br></code></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>出于Blog的排版问题，只有一个示例</p><div class="code-wrapper"><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```~~~</code></pre></div></blockquote><p><del>第一篇Blog就是把别人的东西抄了一遍.jpg</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
