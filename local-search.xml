<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>标准 Linux 启用 ZeroTier 局域网转发</title>
    <link href="/p/d556ca0e.html"/>
    <url>/p/d556ca0e.html</url>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://zerotier.atlassian.net/wiki/spaces/SD/pages/224395274/Route+between+ZeroTier+and+Physical+Networks">ZeroTier · 局域网和ZeroTier网络之间的路由转发</a></li></ul><h1 id="需要解决的问题"><a class="markdownIt-Anchor" href="#需要解决的问题"></a> 需要解决的问题</h1><p>在使用非<code>OpenWRT</code>这种路由器类型的<code>Linux</code>发行版的时候，如果想要使用<code>ZeroTier</code>自带的路由转发的功能，需要进行一系列的操作来启用内部的路由转发机制。</p><p>解决这个问题原本应该十分简单，只需要在<code>sysctl</code>启用对应的<code>forward</code>设置然后设置防火墙即可。但是在<code>CentOS 8</code>上实践的过程中，遇到了<code>iptables-save</code>无法保存防火墙规则的问题。因为对<code>iptables</code>的使用也不是很频繁，这里就写了一个小脚本，通过<code>systemd</code>的方式曲线救国，并记录一下脚本的内容</p><h1 id="启用路由转发的流程"><a class="markdownIt-Anchor" href="#启用路由转发的流程"></a> 启用路由转发的流程</h1><h2 id="初期准备"><a class="markdownIt-Anchor" href="#初期准备"></a> 初期准备</h2><ol><li><p>首先将需要作为内部跳板的局域网机器加入ZeroTier网络中，这一步网上的教程比较多，不多做赘述</p></li><li><p>根据下面这个简单的脚本查询当前机器对应的默认网络<code>CIDR</code>信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提取默认路由的接口名称</span><br>iface=$(route | grep default | awk <span class="hljs-string">&#x27;&#123;print $8&#125;&#x27;</span>)<br><br><span class="hljs-comment"># 使用接口名称获取默认网关</span><br>gateway=$(ip route show default | grep -oP <span class="hljs-string">&quot;default via \K\S+&quot;</span>)<br><br><span class="hljs-comment"># 使用相同接口获取子网掩码</span><br>netmask=$(ip -o -f inet addr show <span class="hljs-variable">$iface</span> | awk <span class="hljs-string">&#x27;&#123;print $4&#125;&#x27;</span> | sed <span class="hljs-string">&#x27;s/.*\///&#x27;</span>)<br><br><span class="hljs-comment"># 输出默认网关和子网掩码</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;gateway&#125;</span>/<span class="hljs-variable">$&#123;netmask&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里为了做示范，假设输出的内容为<code>192.168.1.1/24</code>，机器在<code>ZeroTier</code>子网对应的IP为<code>10.242.231.123</code></p></blockquote></li><li><p>将输出的默认网关填入<code>ZeroTier</code>控制台的<code>Manage Routes</code>处。其中<code>Destination</code>填入我们上面查询到的<code>192.168.1.1/24</code>，<code>Via</code>填入机器对应的网关IP：<code>10.242.231.123</code></p><blockquote><p>在这里设置之后，ZeroTier子网下其他设备就会将<code>192.168.1.x</code>网段的请求都转发给<code>10.242.231.123</code>。因此如果有多个物理局域网需要转发，最好确定彼此之间的网段不会冲突</p></blockquote></li></ol><h2 id="设置转发"><a class="markdownIt-Anchor" href="#设置转发"></a> 设置转发</h2><p>在初期准备完成之后，会发现此时如果想从虚拟局域网的其他设备直接通过<code>192.168.1.x</code>的网段访问内网其他设备，是无法成功通信的。这是因为默认的<code>Linux</code>发行版一般都会禁用路由转发的功能<s>来确保安全</s>。因此还需要我们给当前系统启用路由转发</p><ul><li><p>开启<code>sysctl</code>的路由转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure></li></ul><p>但是在完成了上面的步骤以后，也会发现只有跳板机本身的<code>192.168.1.x</code>可以访问，局域网内其他设备不一定能直接访问。这个时候就还需要我们对防火墙的规则进行修改，放行<code>ZeroTier</code>的网络请求</p><p>对于这一步，根据官方的文档，理论上直接执行下面的步骤就能成功</p><blockquote><h3 id="configure-iptables"><a class="markdownIt-Anchor" href="#configure-iptables"></a> Configure iptables</h3><p>Assign some shell variables (personalize these)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PHY_IFACE=eth0; ZT_IFACE=zt7nnig26<br></code></pre></td></tr></table></figure><p>Add rules to iptables</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo iptables -t nat -A POSTROUTING -o <span class="hljs-variable">$PHY_IFACE</span> -j MASQUERADE sudo iptables -A FORWARD -i <span class="hljs-variable">$PHY_IFACE</span> -o <span class="hljs-variable">$ZT_IFACE</span> -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i <span class="hljs-variable">$ZT_IFACE</span> -o <span class="hljs-variable">$PHY_IFACE</span> -j ACCEPT<br></code></pre></td></tr></table></figure><p>Save iptables rules for next boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install iptables-persistent sudo bash -c iptables-save &gt; /etc/iptables/rules.v4<br></code></pre></td></tr></table></figure></blockquote><p>但是在实践的过程中，发现在物理机刚启动的时候，<code>ZeroTier</code>的网卡并不会立马被添加到系统当中。因此写了一个开机自启动的轮训脚本，在监测到网卡正确加载之后，再对接口进行修改放行</p><ol><li><p>在<code>/etc/systemd/system</code>下创建服务<code>zerotier-nat.service</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=Setup IP forwarding and iptables rules <span class="hljs-keyword">for</span> ZeroTier<br>Wants=zerotier-one.service<br>After=zerotier-one.service network.target<br><br>[Service]<br>Type=oneshot<br>ExecStart=/usr/local/bin/enable-zerotier-nat.sh<br>RemainAfterExit=<span class="hljs-built_in">yes</span><br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>创建文件<code>/usr/local/bin/enable-zerotier-nat.sh</code>，写入下列内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># Enable IP forwarding</span><br>sysctl -w net.ipv4.ip_forward=1<br><br><span class="hljs-comment"># Get the interface with the default route (assumed to be PHY_IFACE)</span><br>PHY_IFACE=$(ip route | grep default | awk <span class="hljs-string">&#x27;&#123;print $5&#125;&#x27;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Physical interface detected: <span class="hljs-variable">$PHY_IFACE</span>&quot;</span><br><br><span class="hljs-comment"># Initialize attempt counter</span><br>attempt=0<br><br><span class="hljs-comment"># Try to find the ZeroTier interface, retry up to 10 times every 5 seconds</span><br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$attempt</span> -lt 10 ]; <span class="hljs-keyword">do</span><br>    ZT_IFACE=$(ip <span class="hljs-built_in">link</span> show | grep -o <span class="hljs-string">&#x27;zt[a-zA-Z0-9]*&#x27;</span>)<br>    <span class="hljs-keyword">if</span> [ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$ZT_IFACE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ZeroTier interface detected: <span class="hljs-variable">$ZT_IFACE</span>&quot;</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ZeroTier interface not found, retrying in 5 seconds...&quot;</span><br>        <span class="hljs-built_in">sleep</span> 5<br>        ((attempt++))<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># Check if ZT_IFACE was found</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$ZT_IFACE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Failed to find ZeroTier interface after 10 attempts.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Set up NAT</span><br>iptables -t nat -A POSTROUTING -o <span class="hljs-variable">$PHY_IFACE</span> -j MASQUERADE<br><br><span class="hljs-comment"># Set up IP forwarding rules</span><br>iptables -A FORWARD -i <span class="hljs-variable">$PHY_IFACE</span> -o <span class="hljs-variable">$ZT_IFACE</span> -m state --state RELATED,ESTABLISHED -j ACCEPT<br>iptables -A FORWARD -i <span class="hljs-variable">$ZT_IFACE</span> -o <span class="hljs-variable">$PHY_IFACE</span> -j ACCEPT<br></code></pre></td></tr></table></figure></li><li><p>为刚刚编辑的脚本添加可执行权限，并设置脚本的开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/enable-zerotier-nat.sh<br>systemctl <span class="hljs-built_in">enable</span> --now zerotier-nat<br></code></pre></td></tr></table></figure></li></ol><p>经过上面的操作之后，理论上就完成了，可以在<code>ZeroTier</code>其他设备上直接访问<code>192.168.1.x</code>的家庭内网设备啦</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原理分析：UDP和TCP在NAT环境下的P2P打洞实现</title>
    <link href="/p/bb3a9deb.html"/>
    <url>/p/bb3a9deb.html</url>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://bford.info/pub/net/p2pnat/index.html">Bryan Ford’s Home Page (bford.info)</a></li></ul><h1 id="p2p的特点"><a class="markdownIt-Anchor" href="#p2p的特点"></a> P2P的特点</h1><p>在当前互联网的结构模式下，大部分的数据通信和交互都是以C/S结构进行通信，即一个客户端和一个中心服务器，客户端通过将数据交给服务器，再有服务器将数据进行适当的处理后与客户端进行交互。除了C/S，还有一种常见的结构，即P2P通信。在P2P网络下，主要的通信双方为“节点”，节点和节点之间的通信是直达的，不需要中心服务器对信息进行处理。</p><p>由于这篇博客本身的目的并不是非要在C/S和P2P中抉择出一个好坏，重点主要放在P2P的技术实现上，就不做优劣对比了。P2P网络本质上是一种去中心化的网络结构，每个节点都直接与其他节点交互，共享节点和节点之间的资源与服务。这种结构相对来说可以更有效的利用资源，提高传输效率和可靠性（打洞成功的情况下）。</p><p>但是既然有这么多好处，那么必然也有相对应的挑战：P2P网络最核心的本质还是需要节点和节点能够直接通信。但是在当前国内的网络环境下，大部分的家庭用户并没有一个自己的公网IP。很多时候想实现节点和节点的直接通信，我们都需要想一个办法跨过防火墙，来让两个节点能够“握手”并“通信”，而这个过程便称为“打洞”。</p><h1 id="nat的通信方式"><a class="markdownIt-Anchor" href="#nat的通信方式"></a> NAT的通信方式</h1><p><img src="https://lsky.halc.top/Gt6JKG.png" alt="NAT通信流程图" /></p><ol><li><strong>内网请求</strong>：用户设备（内网IP地址为192.168.1.10）通过端口5000发起对外部服务器的请求。</li><li><strong>地址转换</strong>：路由器接收到来自内网用户的请求后，使用NAT机制将源地址从内网IP转换为路由器的公网IP地址（203.0.113.45），同时，源端口从5000更改为1024。NAT通过这一端口映射的过程，来维护外网和内网设备的通信。</li><li><strong>请求转发</strong>：经过地址转换后，路由器将修改后的请求通过互联网转发至目标服务器（IP地址为51.68.141.240）的80端口。s</li><li><strong>服务器响应</strong>：服务器接收到请求后，对该请求进行处理，并通过相同的端口（80）向互联网发送响应数据。</li><li><strong>响应数据路由</strong>：互联网将服务器的响应数据发回路由器的公网IP地址（203.0.113.45）的1024端口。</li><li><strong>反向地址转换</strong>：路由器接收到响应数据后，再次使用NAT机制，将响应数据包的目标地址从路由器的“公网IP地址（203.0.113.45）：端口（1024）”映射回用户的”内网IP地址（192.168.1.10）和端口5000“。</li><li><strong>内网传递响应</strong>：最后，路由器将响应数据发送回内网用户，完成整个通信过程。</li></ol><h1 id="udp的打洞过程"><a class="markdownIt-Anchor" href="#udp的打洞过程"></a> UDP的打洞过程</h1><h2 id="建立点对点会话连接"><a class="markdownIt-Anchor" href="#建立点对点会话连接"></a> 建立点对点会话连接</h2><p><img src="https://lsky.halc.top/KZN0EJ.png" alt="image-20240130172638076" /></p><ol><li><strong>注册与穿透服务器</strong>：两个客户端A和B分别与穿透服务器S建立UDP会话。在此过程中，服务器S记录每个客户端的两个<code>Endpoint</code>：客户端自认为用来与S通信的内网<code>Endpoint</code>对，以及服务器观察到的客户端用来进行通信的公网<code>Endpoint</code>。</li><li><strong><code>Endpoint</code>信息的记录与交换</strong>：服务器S将从客户端收到的注册消息中提取内网<code>Endpoint</code>信息，并从IP和UDP头部提取公网<code>Endpoint</code>信息。如果客户端不在NAT后面，这两个<code>Endpoint</code>应该是相同的。</li><li><strong>发起UDP打洞请求</strong>：假设客户端A想要直接与客户端B建立UDP会话。A首先不知道如何到达B，因此A请求S帮助建立与B的UDP会话。</li><li><strong>服务器响应</strong>：S回复A，包含B的公网和内网<code>Endpoint</code>信息。同时，S使用其与B的UDP会话向B发送包含A的公网和内网<code>Endpoint</code>的连接请求消息。收到这些消息后，A和B知道了对方的公网和内网<code>Endpoint</code>。</li><li><strong>双向打洞</strong>：A收到B的公网和内网<code>Endpoint</code>后，开始向这两个<code>Endpoint</code>发送UDP数据包，并锁定首先从B处获得有效响应的<code>Endpoint</code>。类似地，B在收到转发的连接请求后，开始向A的已知<code>Endpoint</code>发送UDP数据包，锁定第一个有效的<code>Endpoint</code>并以此通讯。由于A和B相互发送数据包的操作本身是异步的，因此A和B发送数据包的前后顺序并没有严格要求。</li></ol><h2 id="不同nat下打洞的过程"><a class="markdownIt-Anchor" href="#不同nat下打洞的过程"></a> 不同NAT下打洞的过程</h2><h3 id="客户端a和b都在同一个nat后"><a class="markdownIt-Anchor" href="#客户端a和b都在同一个nat后"></a> 客户端A和B都在同一个NAT后</h3><p><img src="https://lsky.halc.top/4nATYZ.png" alt="image-20240131145913368" /></p><ol><li><p><strong>建立会话</strong>：客户端A与服务器S建立UDP会话，NAT分配公网端口62000。</p></li><li><p><strong>端口分配</strong>：客户端B也与服务器S建立UDP会话，NAT为其分配公网端口62005。</p></li><li><p><strong>连接请求</strong>：客户端A请求使用打洞技术与客户端B建立通信，并通过服务器S作为介绍人。</p></li><li><p><strong>交换Endpoint信息</strong>：服务器S向客户端A发送客户端B的公网和内网Endpoint信息，并将客户端A的信息转发给客户端B。</p></li><li><p><strong>尝试直接通信</strong>：客户端A和B尝试向彼此的公网和内网Endpoint发送UDP数据包。</p></li><li><p><strong>选择通信路径</strong>：根据NAT的支持情况，客户端可能通过NAT（支持Hairpin转译）或直接（不支持Hairpin转译）进行通信。</p><blockquote><p><strong>Hairpin转译</strong>：</p><p>Hairpin是NAT中的一种转译技术，其主要实现了让NAT后的两台设备都可以通过公网的IP和端口进行直接通信，具体的效果如下</p><ol><li><strong>客户端A发送数据</strong>：假设客户端A想要发送数据到客户端B。首先，客户端A会将数据包发送到NAT设备，目标是客户端B的公网Endpoint（例如155.99.25.11:62005）。</li><li><strong>NAT设备处理</strong>：NAT设备接收到来自客户端A的数据包，并查看目标地址。这里涉及Hairpin转译，因为数据包的源地址和目标地址都是由NAT设备分配的公网地址。</li><li><strong>Hairpin转译动作</strong>：如果NAT设备支持Hairpin NAT，它会识别出虽然目标地址是公网地址，但实际上目的地是内网中的另一个客户端。NAT设备将会将数据包的目标地址从B的公网Endpoint转换为B的内网IP地址（10.1.1.3），同时可能还会更改源地址从A的公网Endpoint到A的内网IP地址（10.0.0.1）。</li><li><strong>数据包转发给客户端B</strong>：完成地址转换后，NAT设备将数据包转发到客户端B的内网地址上。此时，数据包好像是从客户端A直接发送给客户端B而不是经过互联网，即使它们实际上是通过NAT设备的公网地址进行通信的。</li><li><strong>客户端B接收数据</strong>：客户端B收到了来自客户端A的数据包，尽管这些数据包最初是发送到NAT设备的公网地址的。</li></ol><p>在P2P通信中，由于内网Endpoint比公网的Endpoint要更早到达客户端B，也就是说Hairpin转译的通信流程还没走完，客户端A通过内网Endpoint和B建立的通信就完成了。因此在实际的通信中，由于内网路由通常比经过NAT的路由更快，客户端A和B更倾向于使用内网Endpoint进行后续的常规通信。</p></blockquote></li></ol><h3 id="客户端a和b在不同nat后"><a class="markdownIt-Anchor" href="#客户端a和b在不同nat后"></a> 客户端A和B在不同NAT后</h3><p><img src="https://lsky.halc.top/GPPOFe.png" alt="不同NAT后打洞的原理" /></p><ol><li><strong>会话初始化</strong>：客户端A和B分别从它们的本地端口4321发起到服务器S的1234端口的UDP通信会话。</li><li><strong>端口映射</strong>：NAT A为客户端A分配公网端口62000，而NAT B为客户端B分配公网端口31000。</li><li><strong>注册与记录</strong>：A和B向服务器S注册它们的内网和公网Endpoint。</li><li><strong>请求协助</strong>：客户端A请求服务器S帮助与客户端B建立连接。</li><li><strong>Endpoint交换</strong>：服务器S向两个客户端交换彼此的公网和内网Endpoint信息。</li><li><strong>尝试直连</strong>：A和B尝试直接向彼此的公网和内网Endpoint发送UDP数据包。</li><li><strong>NAT行为</strong>：如果NAT A和NAT B表现良好，它们将保留公网到内网的映射，为P2P通信“打洞”。</li><li><strong>通信验证</strong>：一旦客户端验证了公网Endpoint的可用性，且因为在两个不同的NAT后，内网Endpoint不可达，它们将停止向内网Endpoint发送消息，只用公网Endpoint通信。</li></ol><h3 id="客户端a和b在多层nat后"><a class="markdownIt-Anchor" href="#客户端a和b在多层nat后"></a> 客户端A和B在多层NAT后</h3><p><img src="https://lsky.halc.top/glofU4.png" alt="多层NAT下打洞的原理" /></p><ol><li><strong>客户端发起连接</strong> - 客户端A和B分别从它们的内网地址发起到服务器S的UDP连接。</li><li><strong>NAT A和B映射</strong> - NAT A和NAT B各自为客户端A和B创建了公网到内网的地址映射。</li><li><strong>NAT C建立映射</strong> - 在ISP级别的NAT C为两个会话建立了公网到内网的地址映射。</li><li><strong>尝试建立P2P连接</strong> - 客户端A和B尝试通过UDP打洞技术建立直接的P2P连接。</li><li><strong>NAT C的Hairpin转译</strong> - 如果NAT C支持Hairpin转译，它会处理从A到B和从B到A的数据包。</li><li><strong>数据包路由</strong> - NAT C将数据包正确地路由到另一端的客户端。</li><li><strong>数据包到达目的地</strong> - 经过NAT的转译，数据包成功到达对方客户端。</li></ol><p>当NAT不支持Hairpin转发的时候就无能为力了，目前Hairpin的普及度也需要打一个问号。也存在一些特殊的NAT结构，让P2P的成功率更加没有保证。如果希望P2P打洞的成功率变高，则需要整个互联网都推动这一块的发展。</p><h2 id="打洞成功后的空闲超时机制"><a class="markdownIt-Anchor" href="#打洞成功后的空闲超时机制"></a> 打洞成功后的空闲超时机制</h2><p>即使在通过上述的几种不同的方法打洞成功，这种方法打出的隧道也并不是可以一直可靠的。大部分的NAT内部都有一个维护UDP转换信息的计时器：如果在一段时间内某个端口上不再有数据通信，那么这个隧道就会因为空闲超时被关闭掉。</p><h3 id="维持隧道连接"><a class="markdownIt-Anchor" href="#维持隧道连接"></a> 维持隧道连接</h3><p>如果希望P2P的隧道能不受NAT网关的时间限制，就需要通过发送持续的心跳包来维持这个隧道的活跃状态。</p><p>除了心跳包的方法，当然也可以在双方长时间没有数据往来的时候将当前的隧道关闭，并在下一次需要通信的时候建立连接。通过这样的方式避免不必要的流量浪费。</p><h1 id="使用tcp实现p2p打洞"><a class="markdownIt-Anchor" href="#使用tcp实现p2p打洞"></a> 使用TCP实现P2P打洞</h1><p>与UDP协议相比，使用TCP实现P2P打洞最大的问题并不在于TCP诸如三次握手等协议层的问题。相比之下，由于TCP拥有诸如<code>SYN_SENT</code>和<code>ESTABLISHED</code>这种状态描述来记录一个会话的具体生命周期，使用TCP进行P2P要比使用UDP更加健壮一些。缺点是由于TCP的打洞目前还未推广开来，因此支持TCP打洞的设备并不多。</p><h2 id="sockets与tcp端口的复用"><a class="markdownIt-Anchor" href="#sockets与tcp端口的复用"></a> Sockets与TCP端口的复用</h2><p>在操作系统的通信API当中，如果要使用<code>Socket</code>建立<code>TCP</code>的连接，可以使用<code>connect()</code>方法来发送一个请求；或使用<code>listen()</code>和<code>accept()</code>来监听一个请求。但是相比UDP，正常情况下TCP要求一个端口仅能绑定一个<code>Socket</code>通信。如果想要绑定第二个的话则会失败。</p><p>如果我们需要实现一个TCP的打洞，我们需要有一个端口，可以在监听请求的同时对外发送请求。为了实现这一点，我们需要使用操作系统中的一种特殊的<code>Socket</code>：通过在<code>TCP Socket</code>携带<code>SO_REUSEADDR</code>这个特殊的关键字，我们就可以实现复用一个TCP端口，绑定多个<code>Sockets</code>。但这么做也是有限制的：所有绑定在这个端口上的<code>Socket</code>请求，都必须要携带<code>SO_REUSEADDR</code>这个关键字。</p><blockquote><p>在类似BSD的系统中，除了针对端口的绑定，还有<code>SO_REUSEPORT</code>这个关键字，用于区分具体是复用端口还是复用地址。这个时候就需要将两个参数同时设置才能生效。</p></blockquote><h2 id="建立tcp的p2p数据流"><a class="markdownIt-Anchor" href="#建立tcp的p2p数据流"></a> 建立TCP的P2P数据流</h2><p>其实TCP打洞的过程和UDP的打洞过程本质并没有很大区别。都是通过握手服务器获取到了对方的 Endpoint 信息后，同时尝试对内网和公网的地址进行访问。</p><p><img src="https://lsky.halc.top/f9rV8M.png" alt="TCP打洞的实现" /></p><p>正如上面介绍<code>Sockets</code>之于TCP的端口复用中提到的：在TCP协议中，开发者需要维护多个<code>Socket</code>，分别来处理监听和信息的发送；而对于UDP来说，只需要维护一个<code>Socket</code>，就可以实现客户端和客户端之间的信息交互。</p><h2 id="tcp连接的握手过程"><a class="markdownIt-Anchor" href="#tcp连接的握手过程"></a> TCP连接的握手过程</h2><p>在TCP打洞技术中，客户端应用程序根据操作系统的不同，可能观察到两种不同的行为。这两种行为反映了不同TCP实现对同步包(SYN)的处理方式的差异。在这里我们假设A向B发送的SYN数据包被B的防火墙丢弃了，但是B向A的Endpoint发送的SYN数据包可以正常抵达（即至少有一方可握手成功）。</p><h3 id="基于bsd的操作系统行为"><a class="markdownIt-Anchor" href="#基于bsd的操作系统行为"></a> 基于BSD的操作系统行为：</h3><p><img src="https://lsky.halc.top/oHhxGK.png" alt="基于BSD的操作系统" /></p><p>简单来说，A的网络程序接收到了B发来的SYN信号，这个信号的Endpoint对应了A之前试图发出去的信号回应。于是，A的网络部件就把这个新信号和它原来用来尝试联系B的那个通道（socket）联系起来了。这样一来，A尝试连接B的<code>connect()</code>就成功了，而且A用来等待别人的监听socket并没有被使用到。</p><h3 id="linux和windows系统的行为"><a class="markdownIt-Anchor" href="#linux和windows系统的行为"></a> Linux和Windows系统的行为：</h3><p><img src="https://lsky.halc.top/cd4KWj.png" alt="Linux和Windows操作系统" /></p><p>在打洞过程中，A收到了B发出的SYN信号。这个信号与A尝试向B发起的连接请求相对应，因此A的TCP实现决定将这个新的连接尝试与原本用于尝试连接B的<code>socket</code>关联起来。</p><p>接着，A通过向B发送SYN-ACK响应，继续常规的TCP连接建立流程。然而，因为A先前向B尝试发起的<code>connect()</code>操作使用了和新的<code>socket</code>相同的源和目标Endpoint，所以<code>connect()</code>操作最终会失败，而用于接受B传来的SYN的新建立的<code>socket</code>下的<code>accept()</code>方法则会成功。</p><h2 id="顺序打洞"><a class="markdownIt-Anchor" href="#顺序打洞"></a> 顺序打洞</h2><p>在一些老旧的Windows系统上，当双方想要进行通信的时候，打洞这个操作不一定是并行的，他有可能是一个顺序下来的步骤。</p><ol><li>A告诉S，它想和B通信，但A这边无法正常接受数据包。</li><li>然后B尝试通过<code>connect()</code>发送一个信号给A，希望通过S的帮助到达A。但因为A还没准备好，所以B的尝试失败了。</li><li>B告诉S，它完成了尝试，并开始准备通过<code>listen()</code>接收A的信号。</li><li>S告诉A，现在轮到你尝试直接联系B了。</li></ol><p>之所以有这种应用场景的需求，是因为在一些老旧的系统上并不能够并发的打开TCP连接，或<code>socket</code>接口没有实现<code>SO_REUSEADDR</code>的关键字。这种方法相对于并发连接来说速度会更慢一些，同时这种方法也需要与S服务器能够一直存在连接。而现在主流的操作系统在建立了P2P连接之后就不需要依赖于服务器S的连接了。</p><h1 id="当前nat网络现状"><a class="markdownIt-Anchor" href="#当前nat网络现状"></a> 当前NAT网络现状</h1><blockquote><p>以下部分内容来源于 GPT-4 的总结</p></blockquote><p>为了使上文提到的打洞技术能够顺利工作，NAT必须具备一些关键的行为特性。虽然不是所有现有的NAT都符合这些要求，但许多NAT已经做到了，并且随着NAT厂商逐渐认识到对点对点（P2P）协议的需求（例如IP语音和在线游戏），它们正变得更加友好于P2P网络。</p><p>这里并不旨在提供一个关于NAT应如何表现的完全或确定性的规范。我们只是提供一些信息，介绍哪些最常见的行为能够支持或阻碍P2P打洞。IETF已经启动了BEHAVE工作组，旨在为NAT行为定义官方的“最佳当前实践”。</p><p>关键特性包括：</p><ul><li><strong>一致的端点转换</strong>：NAT需要一致地将私有网络上的TCP或UDP源端点映射到一个单一的公共端点。这种NAT被称为圆锥NAT，它可以确保来自同一私有端点的所有会话通过NAT上的同一个公共端点传输。</li><li><strong>处理未请求的TCP连接</strong>：当NAT收到一个未经请求的SYN包时，它应该静默丢弃该包，而不是主动拒绝它。这样可以避免干扰TCP打洞过程。</li><li><strong>保持负载不变</strong>：一些NAT会“盲目”扫描数据包负载中的IP地址并进行转换，这种行为虽不常见，但应用程序可以通过对IP地址进行混淆来保护自己。</li><li><strong>Hairpin转换</strong>：在一些需要Hairpin转换支持的多级NAT场景中，当前NAT对此的支持很少，但随着IPv4地址空间的耗尽，支持Hairpin转换在未来NAT实现中变得重要。</li></ul><p>简而言之，为了支持P2P通信和打洞技术，NAT需要具备一些特定的行为特性，包括一致的端点转换、正确处理未请求的连接尝试、保持数据包负载不变，以及在需要时支持Hairpin转换。随着对P2P通信需求的增加，NAT技术也在逐步适应，以更好地支持这些应用。</p><p><strong>在英文原文中还有一些有关于如何衡量和测试NAT结构的方法，由于本文主要探究的是P2P打洞的技术实现，因此在这里就不做拓展了。后续如果遇到有关的技术问题则会在这里进行进一步的更新</strong></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>镜像构建：Windows Cloud Image</title>
    <link href="/p/b9295ba3.html"/>
    <url>/p/b9295ba3.html</url>
    
    <content type="html"><![CDATA[<h1 id="windows-cloud-镜像构建"><a class="markdownIt-Anchor" href="#windows-cloud-镜像构建"></a> Windows Cloud 镜像构建</h1><p><code>Ubuntu</code>和<code>Debian</code>等常见<code>Linux</code>系统都有官方自带<code>cloud-init</code>的<code>cloud image</code>可供下载使用，但是<code>Windows</code>系统在微软中心只找到了<code>ISO</code>镜像的下载路径。当需要在<code>pve</code>等常见虚拟化环境中部署<code>Windows</code>服务器的时候，无论是<code>virtio</code>的驱动，还是<code>iso</code>安装漫长的等待时间都是个问题，所以需要构建<code>cloud image</code>来方便快捷的进行部署</p><h2 id="构建工具"><a class="markdownIt-Anchor" href="#构建工具"></a> 构建工具</h2><p>工具使用的是提供给<code>OpenStack</code>的构建工具：</p><ul><li><a href="https://github.com/cloudbase/windows-imaging-tools">cloudbase/windows-imaging-tools: Tools to automate the creation of a Windows image for OpenStack, supporting KVM, Hyper-V, ESXi and more. (github.com)</a></li></ul><p>构建出来的镜像可以在各种虚拟化环境中部署和运行。</p><h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2><ul><li>一台开启了<code>Hyper-V</code>的<code>Windows</code>宿主机，用于构建镜像。</li><li>一个<code>Windows Server</code>的部署镜像，这里以<code>Windows2022</code>为例。</li><li><code>Windows</code>虚拟机的<code>virtio</code>驱动，可以在<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.240-1/">这里</a>下载到最新的<code>iso</code>。</li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>镜像的构建本身不会污染宿主机环境，但是需要在宿主机中启用<code>Hyper-V</code>，以便于创建虚拟机。（启用教程网上很多，不做阐述）</li><li>启用了<code>Hyper-V</code>以后，为了尽可能构建稳定独立的镜像环境，需要在<code>Hyper-V</code>中创建一个额外的网卡，用于单独构建虚拟机。</li></ol><h4 id="hyper-v-添加网卡"><a class="markdownIt-Anchor" href="#hyper-v-添加网卡"></a> Hyper-V 添加网卡</h4><ol><li><p>通过<code>Windows</code>的搜索功能打开<code>Hyper-V</code>管理器</p><p><img src="https://lsky.halc.top/0grln8.png" alt="Hyper-V管理器" /></p></li><li><p>根据下面的流程创建一个虚拟交换机</p><p><img src="https://lsky.halc.top/gRkOVr.png" alt="创建虚拟交换机" /></p></li><li><p>配置虚拟交换机属性</p><p><img src="https://lsky.halc.top/mYKhyK.png" alt="虚拟交换机属性" /></p></li><li><p>等待应用更改结束后就可以退出<code>Hyper-V</code>管理器了</p></li></ol><h4 id="挂载虚拟光驱"><a class="markdownIt-Anchor" href="#挂载虚拟光驱"></a> 挂载虚拟光驱</h4><p>只要双击打开下载好的<code>Windows2022</code>的<code>iso</code>文件，<code>Windows</code>就会自动对虚拟光驱进行挂载了。这里假设我挂载以后的盘符为<code>D:\</code></p><h2 id="构建流程"><a class="markdownIt-Anchor" href="#构建流程"></a> 构建流程</h2><ol><li><p>首先在<code>Windows</code>宿主机上克隆构建工具的仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git clone https://github.com/cloudbase/windows<span class="hljs-literal">-imaging-tools</span>.git<br></code></pre></td></tr></table></figure></li><li><p>以管理员权限执行<code>Powershell</code>，并进入刚刚<code>clone</code>的仓库目录下</p></li><li><p>为当前的<code>Powershell</code>临时加载镜像构建需要的模块</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> .\WinImageBuilder.psm1<br><span class="hljs-built_in">Import-Module</span> .\Config.psm1<br><span class="hljs-built_in">Import-Module</span> .\UnattendResources\ini.psm1<br></code></pre></td></tr></table></figure></li><li><p>指定配置文件的目录，并初始化对应的文件内容</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$ConfigFilePath</span> = <span class="hljs-string">&quot;.\config.ini&quot;</span><br><span class="hljs-built_in">New-WindowsImageConfig</span> <span class="hljs-literal">-ConfigFilePath</span> <span class="hljs-variable">$ConfigFilePath</span><br></code></pre></td></tr></table></figure></li><li><p>（可跳过）快速初始化配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-IniFileValue</span> <span class="hljs-literal">-Path</span> (<span class="hljs-built_in">Resolve-Path</span> <span class="hljs-variable">$ConfigFilePath</span>) <span class="hljs-literal">-Section</span> <span class="hljs-string">&quot;DEFAULT&quot;</span> `<br>                                      <span class="hljs-literal">-Key</span> <span class="hljs-string">&quot;wim_file_path&quot;</span> `<br>                                      <span class="hljs-literal">-Value</span> <span class="hljs-string">&quot;D:\Sources\install.wim&quot;</span> <span class="hljs-comment"># 这里的D:\是指虚拟光驱挂载到了D:\</span><br></code></pre></td></tr></table></figure><blockquote><p>因为有一些具体的参数还需要调整，因此这一步可以在下一步手动修改<code>config</code>的时候进行</p></blockquote></li><li><p>手动完善刚刚通过命令行创建的<code>config.ini</code>文件，以下是一些注意事项和自己没搞明白的地方</p><ul><li><code>image_name</code>这个配置项需要对<code>install.wim</code>执行<code>Get-WimFileImagesInfo</code>来获取一个列表，然后选出你需要的那个镜像名字。比如对带有桌面环境的<code>Windows Server 2022</code>标准版而言，就是<code>Windows Server 2022 SERVERSTANDARD</code></li><li><code>[vm]</code>的配置参数是指构建用的虚拟机的参数。在构建完成后这个虚拟机会被销毁，一般不用在意。在构建失败的时候可以通过管理员密码进入虚拟机查看信息</li><li><code>[vm]</code>的<code>external_switch</code>中需要填入的就是我们刚刚创建好的<code>Hyper-V</code>虚拟网卡名字，比如按照上图中我们选用的是<code>external</code>，这里直接填入即可。</li><li><code>[drivers]</code>的部分需要选择你下载的<code>virtio</code>镜像地址</li><li><code>time_zone</code>这块不太清楚格式应该怎么填，无论是<code>Asia/Shanghai</code>还是<code>China Standard Time</code>，在自己构建的时候都失败了。如果出现了同样问题的小伙伴建议就默认留空试试</li></ul><p>其他具体是用<code>qcow2</code>还是<code>vhdx</code>就按需填写即可</p></li><li><p>执行构建命令，等待镜像构建成功即可</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-WindowsOnlineImage</span> <span class="hljs-literal">-ConfigFilePath</span> <span class="hljs-variable">$ConfigFilePath</span><br></code></pre></td></tr></table></figure><blockquote><p>镜像构建的过程中，会有一段时间<code>Powershell</code>一直输出查询日志，这个时候可以去Hyper-V管理器那边查看创建好的虚拟机中的构建状态，如果出现了报错的话直接将虚拟机删除，重新调整配置文件再构建即可。</p><p>理论上来说整个构建流程都可以无人值守完成，构建成功了一次以后配置文件和路径在确定的情况下可以保留用于下一次的构建</p></blockquote></li><li><p>构建成功后，生成的对应镜像会存放于<code>config.ini</code>中的<code>image_path</code>配置目录下。</p></li></ol><h2 id="补充说明"><a class="markdownIt-Anchor" href="#补充说明"></a> 补充说明</h2><ul><li><p>整个构建流程对<code>Windows</code>宿主机一般而言不会有环境污染的问题。在构建完成以后，只需要删掉创建的<code>Hyper-V</code>虚拟交换机就可以恢复初始环境。如果在构建用虚拟机构建过程中出现问题，只需要删掉对应的虚拟机和虚拟机对应的磁盘文件即可。</p></li><li><p>如果是在加载驱动的过程中手动中止了构建，也只需要将挂载的虚拟目录弹出或删除，然后从头开始整个流程即可。</p></li><li><p>如果构建成功的话，虚拟机会自动关机并重启，这段时间可能会存在一段时间黑屏情况，不用太在意，等待一段时间以后<code>Powershell</code>会接收到虚拟机的配置信息，从而开始镜像的打包流程。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试：跨墙的内网穿透工具选择</title>
    <link href="/p/59e029c8.html"/>
    <url>/p/59e029c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="性能测试跨墙的内网穿透工具选择"><a class="markdownIt-Anchor" href="#性能测试跨墙的内网穿透工具选择"></a> 性能测试：跨墙的内网穿透工具选择</h1><p>由于需要将家里<code>HomeLab</code>的服务内网穿透到外网服务器上，如果使用<code>Zerotier</code>一类的服务进行穿透的话，在经过<code>GFW</code>以后速度会暴跌。因此需要使用带加密的服务来进行建立连接。</p><p>在大约一年前的时候使用了<code>Frp</code>作为跨墙的内网穿透工具，但是因为不知名的原因，当时<code>Frps</code>和<code>Frpc</code>的连接总是容易断开，当时也没有做具体的原因分析。这段时间在新购买了海外VPS之后决定花一些时间对不同的内网穿透工具在跨越<code>GFW</code>的情况下的性能和丢包做一个对比</p><h2 id="省流不看"><a class="markdownIt-Anchor" href="#省流不看"></a> 省流不看</h2><p>综合性能、带宽和丢包率来看，最新版本的<code>Frp</code>已经是不错的选择。不过目前还不确定在特殊时期<code>Frp</code>能否经历防火墙的考验，而<code>V2Ray</code>虽然在<code>Benchmark</code>的结果上不如人意，但是在跨墙可用性来说是身经百战的。<code>Rathole</code>在个人当前的应用场景下则没有太大的优势。</p><h2 id="测试流程"><a class="markdownIt-Anchor" href="#测试流程"></a> 测试流程</h2><h3 id="机器"><a class="markdownIt-Anchor" href="#机器"></a> 机器</h3><ul><li>内网虚拟机一台，配置为<code>2C4G</code>，后文简称<code>client</code>。该机器位于家庭宽带环境中，没有公网IP。</li><li>外网机器一台，配置为<code>1C1G</code>，后文简称<code>server</code>。使用的是洛杉矶的机器，国内线路有做优化。</li></ul><h3 id="测试工具"><a class="markdownIt-Anchor" href="#测试工具"></a> 测试工具</h3><ul><li>V2RAY：使用<code>ws+tls</code>协议，其中<code>tls</code>部分由<code>nginx</code>进行处理。版本为：5.4.1</li><li>FRP：服务端除了<code>auth.token</code>不添加任何多余的参数，性能方面均以默认配置文件为主。版本为：0.53.2</li><li>Rathole：同样以默认配置文件为主，最新的源码<code>65b27f076c</code>编译而来的二进制文件。版本为：0.5.0</li></ul><p>其中<code>V2RAY</code>与<code>FRP</code>均使用<code>Docker</code>的方式进行部署，<code>Rathole</code>通过<code>screen</code>直接运行在后台。</p><blockquote><p>该测试环境存在诸多不合理的地方，该测试主要为自己的特定使用场景做参考。如果有问题还请斧正</p></blockquote><h3 id="测试流程-2"><a class="markdownIt-Anchor" href="#测试流程-2"></a> 测试流程</h3><ol><li><p>通过三套不同的工具，分别将<code>client</code>上的<code>5201</code>端口转发到<code>server</code>的<code>5201(v2ray)</code>，<code>15201(frp)</code>和<code>25201(rathole)</code>上。</p></li><li><p>在<code>server</code>端输入以下指令，以<code>Json</code>文件获取<code>120s</code>内<code>tcp</code><strong>连接的带宽和稳定性</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3 -J --logfile ./xxx_result.log -c localhost -p xxx -t 120s<br></code></pre></td></tr></table></figure></li><li><p>将测试结果统计后以可视化的形式进行对比</p></li></ol><h2 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h2><h3 id="配置难度"><a class="markdownIt-Anchor" href="#配置难度"></a> 配置难度</h3><ul><li>V2Ray：部署复杂度较高，配置文件可读性较差。对于<code>ws+tls</code>来说，不但要部署<code>v2ray</code>本身，在服务端还需要额外的域名和<code>Nginx</code>进行转发。同时如果我有多个<code>client</code>的时候，会出现不确定到底是代理到哪个机器的问题，在不进行额外配置的情况下容易出现<code>502</code>报错。</li><li>FRP；部署难度极低，配置文件可读性极好，上手难度极低。</li><li>Rathole：部署难度中等，每次添加端口需要同时修改服务端和客户端的配置文件，后续维护是最麻烦的。</li></ul><h3 id="性能对比"><a class="markdownIt-Anchor" href="#性能对比"></a> 性能对比</h3><p>在通过上述测试流程后，对日志进行分析统计，可以得到以下统计图表：</p><p><img src="https://lsky.halc.top/bnWSC3.png" alt="性能测试" /></p><ul><li>带宽：<code>Frp</code>和<code>Rathole</code>没有明显差距，<code>V2Ray</code>的带宽相对来说较低，但是没有拉开明显差距</li><li>丢包率：<code>Frp</code>相比<code>Rathole</code>略有优势，在晚高峰的时候依旧能保证丢包率控制在30以下。<code>V2Ray</code>相比之下则更容易丢包</li><li>由于网站只有小范围用户使用，因此对拥塞控制并没有很高的需求。不过从这份<code>Benchmark</code>中也可以看出，在高并发场景下，<code>Rathole</code>可能会更有优势</li><li>资源占用：<code>V2Ray</code>由于加密解密的严谨性，资源消耗相比<code>Rathole</code>与<code>Frp</code>都要多。在资源占用这一点上，<code>Frp</code>几乎是毫无悬念的领先</li></ul><h3 id="综合考虑"><a class="markdownIt-Anchor" href="#综合考虑"></a> 综合考虑</h3><p>综上，从配置难度以及性能对比的角度来看，暂时使用<code>Frp</code>会是一个不错的选择。如果后续出现了性能的不稳定性也会在这里进行补充说明。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Frp</tag>
      
      <tag>Rathole</tag>
      
      <tag>V2Ray</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取Cloudflare Tunnel下用户真实IP</title>
    <link href="/p/f09b73d7.html"/>
    <url>/p/f09b73d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="cloudflare-tunnel-获取用户真实-ip"><a class="markdownIt-Anchor" href="#cloudflare-tunnel-获取用户真实-ip"></a> Cloudflare Tunnel 获取用户真实 IP</h1><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://developers.cloudflare.com/support/troubleshooting/restoring-visitor-ips/restoring-original-visitor-ips/">Restoring original visitor IPs · Cloudflare Support docs</a></li></ul><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2><ol><li>部署在内网中，在<code>80</code>端口部署了<code>PHP</code>的服务器一台。</li><li>使用了<code>Cloudflare Tunnel</code>对内网<code>http://127.0.0.1</code>进行了转发，并提供<code>https</code>支持</li></ol><p><code>SSPanel</code>需要拥有<code>https</code>的情况下才可以正常使用，但是使用<code>Cloudflare Tunnel</code>默认的设置的情况下，所有的用户登入请求都会被记录为<code>Tunnel</code>的转发地址（在这种情况下即<code>127.0.0.1</code>）。</p><p>在这种情况下，当用户通过<code>Tunnel</code>访问我的网站时，<code>Cloudflare</code>会通过<code>CF-Connecting-IP</code>这个<code>HTTP</code>请求头传递原始访问者的IP地址。因此也就可以通过修改<code>Nginx</code>配置的方法来获取到对应用户的真实IP地址了。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>先在这里贴上修改了的配置文件和注释</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx"> <span class="hljs-section">server</span> &#123;<br>         <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>         <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span>;<br><br>         <span class="hljs-attribute">root</span> /path/to/site/public;<br>         <span class="hljs-attribute">index</span> index.php;<br>         <span class="hljs-attribute">server_name</span> your.domain.com;<br><br>+        <span class="hljs-comment"># 设置 Cloudflare 的真实 IP 地址</span><br>+        <span class="hljs-attribute">set_real_ip_from</span> <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">32</span>;  <span class="hljs-comment"># Cloudflare Tunnel 的 IP 地址</span><br>+        <span class="hljs-attribute">real_ip_header</span> CF-Connecting-IP;<br><br>         <span class="hljs-section">location</span> / &#123;<br>             <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> /index.php<span class="hljs-variable">$is_args</span><span class="hljs-variable">$args</span>;<br>         &#125;<br><br>         <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;<br>             <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$fastcgi_script_name</span> =<span class="hljs-number">404</span>;<br>             <span class="hljs-attribute">include</span> fastcgi_params;<br>             <span class="hljs-attribute">fastcgi_index</span> index.php;<br>             <span class="hljs-attribute">fastcgi_buffers</span> <span class="hljs-number">8</span> <span class="hljs-number">16k</span>;<br>             <span class="hljs-attribute">fastcgi_buffer_size</span> <span class="hljs-number">32k</span>;<br>             <span class="hljs-attribute">fastcgi_pass</span> unix:/run/php/php-fpm.sock;<br>             <span class="hljs-attribute">fastcgi_param</span> DOCUMENT_ROOT <span class="hljs-variable">$realpath_root</span>;<br>             <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="hljs-variable">$realpath_root</span><span class="hljs-variable">$fastcgi_script_name</span>;<br>+            <span class="hljs-attribute">fastcgi_param</span> REMOTE_ADDR <span class="hljs-variable">$remote_addr</span>;  <span class="hljs-comment"># 传递真实 IP 地址给 PHP</span><br>         &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>对于上面修改的不同配置项的作用如下</p><ol><li><p><code>set_real_ip_from 127.0.0.1/32;</code></p><ul><li><code>set_real_ip_from</code>指令用于指定哪些IP地址可以设置真实IP地址。</li><li>在这种情况下，<code>127.0.0.1/32</code>表示本地地址。这是因为Cloudflare Tunnel将流量转发到您的本地服务器，通常表现为来自127.0.0.1（即本地主机）的请求。</li><li>这条指令告诉Nginx，如果请求来自本地主机（<code>127.0.0.1/32</code>），则应该考虑使用另一个HTTP头中的IP地址作为访问者的真实IP地址。</li></ul></li><li><p><code>real_ip_header CF-Connecting-IP;</code></p><ul><li><code>real_ip_header</code>指令用于指定包含真实客户端IP地址的HTTP头。</li><li><code>CF-Connecting-IP</code>是由Cloudflare设置的一个特殊的HTTP头，它包含了发起请求的原始访问者的IP地址。</li><li>通过这个配置，Nginx将使用<code>CF-Connecting-IP</code>头中的值来重写访问者的IP地址，这样PHP应用程序就可以获取到访问者的真实IP，而不是Cloudflare Tunnel的本地地址。</li></ul></li><li><p>在PHP FastCGI 配置块中添加的指令：</p><ul><li><code>fastcgi_param REMOTE_ADDR $remote_addr;</code><ul><li>这一行将Nginx内部变量<code>$remote_addr</code>的值传递给FastCGI进程。由于我们已经使用<code>set_real_ip_from</code>和<code>real_ip_header</code>配置了Nginx，<code>$remote_addr</code>将包含经过Cloudflare处理的真实客户端IP。</li><li>通过将此参数传递给FastCGI（在这种情况下是PHP-FPM），在PHP应用程序中的<code>$_SERVER['REMOTE_ADDR']</code>将包含正确的客户端IP地址。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cloudflare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟化：初识IOMMU（TODO）</title>
    <link href="/p/4416e368.html"/>
    <url>/p/4416e368.html</url>
    
    <content type="html"><![CDATA[<h1 id="初识iommu"><a class="markdownIt-Anchor" href="#初识iommu"></a> 初识IOMMU</h1><p>最近在尝试给朋友的小主机安装<code>ZStack</code>作为虚拟化管理平台的时候，遇到了一个需求：通过HDMI直接将Windows虚拟机的画面输出到外界显示器。需要解决这个问题自然而然的就需要使用直通的方法将显卡直通给虚拟机。不过之前直通都是直接找别人的博客一步一步傻瓜式执行下去，对于每个指令发生了什么，以及<code>iommu</code>是如何工作的都不清楚。刚好趁着这个机会了解并记录下自己的学习历程</p><h2 id="问题来源"><a class="markdownIt-Anchor" href="#问题来源"></a> 问题来源</h2><p>我自己现在有一台基于<code>Proxmox VE</code>的<code>All in one</code>小主机了，这里就叫做主机A，而我朋友的主机则称为主机B。在安装<code>ZStack</code>之前，我原以为直通的过程依旧可以无脑用脚本来实现，但是实际执行过程中却发现在<code>PVE</code>中应该成功的<code>ACS</code>的改动在<code>ZStack</code>中却并没有成功。这便引起我了从<code>ACS</code>到<code>IOMMU</code>作用的好奇。</p><h3 id="启用iommu和acs"><a class="markdownIt-Anchor" href="#启用iommu和acs"></a> 启用IOMMU和ACS</h3><p>首先，在主机A和主机B的BIOS上都启用IOMMU的功能，可以发现原本的<code>iommu</code>分组都十分混乱，大部分设备杂糅在一起。为了解决这个问题，便有了叫做<code>ACS</code>的技术。</p><blockquote><p><strong>ACS的主要功能</strong></p><ol><li><strong>设备隔离</strong>：ACS允许对PCIe设备进行更细粒度的控制，增强了设备间的隔离。这在虚拟化环境中尤为重要，因为它可以帮助确保虚拟机之间的安全隔离，防止一个虚拟机访问另一个虚拟机的PCIe设备。</li><li><strong>控制I/O访问</strong>：ACS可以控制PCIe设备的I/O访问，例如控制哪些设备可以发起对其他设备或内存的直接内存访问（DMA）。</li><li><strong>提高安全性</strong>：通过对设备间访问的更严格控制，ACS有助于提高系统的整体安全性，尤其是在多租户或需要高安全性的环境中。</li></ol></blockquote><p>通过启用<code>iommu</code>的同时启用<code>acs</code>，就可以将系统中<code>iommu</code>的<code>group</code>分成更细的设备单位，具体修改的操作实现参数可能不尽相同，但是基本上都是先对<code>/etc/default/grub</code>中的<code>GRUB_CMDLINE_LINUX</code>进行修改，添加<code>amd_iommu=on</code>和<code>pcie_acs_override=downstream,multifunction</code>即可</p><h3 id="查看分组情况"><a class="markdownIt-Anchor" href="#查看分组情况"></a> 查看分组情况</h3><p>对于分组情况的查看，在<a href="https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF">PCI passthrough via OVMF - ArchWiki (archlinux.org)</a>可以找到一个脚本来列出当前的<code>IOMMU Groups</code>的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>shopt -s nullglob<br>for g in $(find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V); do<br>    echo &quot;IOMMU Group $&#123;g##*/&#125;:&quot;<br>    for d in $g/devices/*; do<br>        echo -e &quot;\t$(lspci -nns $&#123;d##*/&#125;)&quot;<br>    done;<br>done;<br></code></pre></td></tr></table></figure><p>当我在自己的<code>PVE</code>主机上执行这个脚本之后，可以发现显卡是单独在一个<code>Groups</code>中的</p><p><img src="https://lsky.halc.top/RACX6h.png" alt="IOMMU分组" /></p><p>但是在<code>ZStack</code>平台上执行以后可以发现核显并不是单独在一个<code>Groups</code>里面的</p><blockquote><p>当时的log没有保存，这里假象一个其他的例子代替，是一个GTX 970显卡的例子，一般来说独显是会有单独的Groups的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>IOMMU Group 13:<br>06:00.0 VGA compatible controller: NVIDIA Corporation GM204 [GeForce GTX 970] [10de:13c2] (rev a1)<br>06:00.1 Audio device: NVIDIA Corporation GM204 High Definition Audio Controller [10de:0fbb] (rev a1)<br>00:1d.0 USB controller: Intel Corporation 7 Series/C210 Series Chipset Family USB Enhanced Host Controller #1 <br>00:1a.0 USB controller: Intel Corporation 7 Series/C210 Series Chipset Family USB Enhanced Host Controller #2 <br>......<br></code></pre></td></tr></table></figure><p>具体问题的产生原因还不清楚（找到问题以后会来更新博客），不过就<code>IOMMU</code>的分组情况大概是这样。</p><h2 id="iommu"><a class="markdownIt-Anchor" href="#iommu"></a> IOMMU</h2><p>对于什么是<code>iommu</code>，找到这样一个简单扼要的概括</p><blockquote><p>大家知道，I/O设备可以直接存取内存，称为DMA(Direct Memory Access)；DMA要存取的内存地址称为DMA地址（也可称为BUS address）。在DMA技术刚出现的时候，DMA地址都是物理内存地址，简单直接，但缺点是不灵活，比如要求物理内存必须是连续的一整块而且不能是高位地址等等，也不能充分满足虚拟机的需要。后来dmar就出现了。 dmar意为DMA remapping，是Intel为支持虚拟机而设计的I/O虚拟化技术，I/O设备访问的DMA地址不再是物理内存地址，而要通过DMA remapping硬件进行转译，DMA remapping硬件会把DMA地址翻译成物理内存地址，并检查访问权限等等。负责DMA remapping操作的硬件称为IOMMU。做个类比：大家都知道MMU是支持内存地址虚拟化的硬件，MMU是为CPU服务的；而IOMMU是为I/O设备服务的，是将DMA地址进行虚拟化的硬件。</p></blockquote><p>而在这其中，<code>IOMMU</code>分组则是实现设备直通的关键，每个分组都包含了可以共享一同一个虚拟内存映射的设备集合。如果一个设备独占一个<code>IOMMU</code>分组，直通它是很简单的。但是如果多个设备共享同一个分组，比如显卡和<code>USB</code>接口，那么就无法只直通其中一个设备。</p><h2 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h2><p>后续就是找时间尝试研究为什么<code>ACS</code>在<code>ZStack</code>中没有正常被启用，并将结论补充到这篇博客当中。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iommu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识复盘：操作系统的作用</title>
    <link href="/p/e429c37a.html"/>
    <url>/p/e429c37a.html</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的作用"><a class="markdownIt-Anchor" href="#操作系统的作用"></a> 操作系统的作用</h1><blockquote><p>该部分博客为自己在学习《程序员的自我修养：链接、装载与库》的时候对于过去零碎知识点的一个整理和复盘，并非照搬原文，其中会加入一些自己的联想与理解，如有错误还请指出。</p></blockquote><p>操作系统在计算机中主要有两个功能：</p><ul><li><p>对硬件资源进行管理，让硬件尽可能高效的解决问题或执行操作</p></li><li><p>提供抽象的接口，以便于程序对计算机的硬件资源进行调用</p></li></ul><h2 id="cpu的调度"><a class="markdownIt-Anchor" href="#cpu的调度"></a> CPU的调度</h2><p>在计算机的使用过程中，需要消耗时间的任务部分大致可以分为两种情况：</p><ul><li>消耗CPU算力的计算密集型操作</li><li>需要等待设备响应处理的I/O密集型操作</li></ul><p>我们知道在计算机中有南桥和北桥两个概念，北桥连同了CPU等高速芯片，而南桥则负责了磁盘、鼠标、键盘等低速设备。因此我们可以抽象出一个结论：<strong>计算密集型操作</strong> 和 <strong>I/O密集型操作</strong> 是由不同的设备分别处理的。接下来对于操作系统调度分析则会都以这一前提条件进行分析。</p><h3 id="第一阶段多道程序-multiprogramming"><a class="markdownIt-Anchor" href="#第一阶段多道程序-multiprogramming"></a> 第一阶段：多道程序 Multiprogramming</h3><p>假设我们现在需要完成一个很复杂的数学问题，且假设完成这个数学问题分为两个步骤：</p><ol><li>在草稿纸上&quot;随意&quot;的打草稿并推演计算过程，最终计算出答案（计算密集型操作）</li><li>将整个推演过程有条理并工整的誊抄在答卷上，便于他人阅读自己的答案（I/O密集型操作）</li></ol><p>那么如果我们有很多个这样的题目需要完成。那么最高效的方法自然是分配两个同学A和B。假设同学A的计算能力很强，同学B的书写则十分端正，同时可以看懂同学A的草稿，那么我们便可以让同学A只需要负责计算和打草稿，只要做完了第一题就直接开始写第二题，而同学B则在同学A开始计算第二题的过程中开始誊抄第一题的答案。这样便可以让同学A和同学B的时间都统筹利用起来，以此提升效率。</p><p>在计算机中也是同样的道理。在计算机刚刚发展的时候，每次执行一个任务都需要先让CPU计算完后，CPU还要等待诸如打印机等设备输出了结果以后，再进行下一个问题的计算。</p><p>为了解决这个问题，人们便想到使用一个监控程序来监管CPU的运算，当监控程序发现在CPU进行完毕某一次运算以后，如果后续还有其他问题需要使用CPU进行计算的话，则让CPU直接进行下一个问题的计算，而不是等待第一个问题的I/O操作进行完毕以后再进行第二个问题的计算。这就是多道程序的雏形</p><h3 id="第二阶段分时系统-time-sharing-system"><a class="markdownIt-Anchor" href="#第二阶段分时系统-time-sharing-system"></a> 第二阶段：分时系统 Time-Sharing System</h3><p>但是随着计算机功能的逐步发展，多道程序则体现出了一个弊端：那就是任务的执行需要所有人都依次排队，前面的人如果没有解决他的问题就轮不到下一个人。</p><p>假设在银行中有一个人的业务处理需要花费特别特别长的时间，从而导致后面所有人直到银行下班都没完成自己的业务，这无疑是非常令人恼火的一件事情。但是如果这个人将自己的一个任务拆分成多个不同的部分，每完成一个部分就让后面的人先处理下，这样相对而言就能顾及他人的感受，有利于提高处理问题数量的效率。</p><p>因此，我们就了分时系统的概念，在分时系统中，程序可以通过在编写的时候主动调用某个“系统调用”来实现通知操作系统我现在这部分的工作已经完成了一部分，如果后面有其他任务需要执行的话可以先执行其他的任务，再来执行我的任务。从而在一定程度上解决了阻塞问题。</p><h3 id="第三阶段-多任务系统-multi-tasking"><a class="markdownIt-Anchor" href="#第三阶段-多任务系统-multi-tasking"></a> 第三阶段： 多任务系统 Multi-tasking</h3><p>但是分时系统在计算机的衍变过程中也展现出了自己的弊端。</p><p>依据以下两个<strong>分时系统</strong>的特点：</p><ul><li>是否让出CPU是由程序自身决定的。程序需要主动调用特定的系统调用来通知操作系统它愿意让出CPU。</li><li>这种机制的问题是，如果一个程序不主动让出CPU（例如，由于编程错误或恶意行为），那么操作系统不能强制地从该程序中夺回CPU控制权。因此，其他程序可能会被迫等待，导致整个系统的响应性下降。</li></ul><p>假设我们遇到一个程序员在程序中忘记调用分时的“系统调用”，还写了一个死循环的错误代码。那么整个操作系统都将会因为这个问题而出现宕机。</p><p>由此我们就需要一个更高端的操作系统来解决我们的问题，即现代操作系统的解决方案：多任务系统。</p><p><strong>多任务系统</strong>的基础是建立在此时操作系统对所有硬件资源进行了直接的接管。而所有的应用程序都以进程（Process）的方式运行在操作系统这个大Boss之下。所有进程的调度都需要受到操作系统的管理，并且每个进程和进程之间就像是一个小房间，他们的地址空间也都是相互隔离且独立的。</p><p>在这种情况下，CPU就变成了操作系统大Boss来进行管理的一个资源，而不是和之前分时系统一样由应用自己直接对CPU进行管理了。这样的好处是可以让所有程序都听操作系统这个领导的话，而不是和之前一样我想一直占用CPU就一直占用，如果我不调用接口主动释放CPU你们谁都别想用上CPU。</p><p>对于操作系统来说，每个进程就是一个任务，每个任务则又有自己的任务优先级。对于优先级高的任务，操作系统会先进行；对优先级低的任务则后执行。如果一个进程的运行时间超过了某个限制，则会将该程序暂停以分配给其他同时间内也许更需要CPU资源的线程任务。</p><p>在此基础上还会牵扯到一些诸如多级反馈队列、上下文切换开销等问题。这里就不做过多的展开。</p><blockquote><p>这里放一个之前写OSTEP课后实验相关的博客链接，便于自己查阅</p><ul><li><a href="https://halc.top/p/b7974b6">操作系统：通过多级反馈的调度策略 - Halcyon Zone</a></li><li><a href="https://halc.top/p/4b65fa48">操作系统：程序上下文切换的开销 - Halcyon Zone</a></li></ul></blockquote><h2 id="设备驱动"><a class="markdownIt-Anchor" href="#设备驱动"></a> 设备驱动</h2><blockquote><p>有关于设备驱动的内容直接概述过于枯燥无味，因此下面这段解释为使用 GPT-4 生成的一个概述，觉得生动有趣就搬上来了</p></blockquote><p>想象一下，你正在玩一个超级复杂的电子游戏，但你只需要按下一个按钮，就能完成一个复杂的动作，比如打怪兽或跳跃。这个按钮就像是操作系统，而那些复杂的动作就是硬件的操作。你不需要知道每一个细节，只需要按下按钮，游戏就会为你完成所有的事情。</p><p>操作系统就是这样的“神奇按钮”。它位于硬件之上，为上层的应用程序提供了一个统一的方式来访问硬件。想象一下，如果每次你想在屏幕上画一条线，都需要知道你的电脑使用的是什么显卡、屏幕的大小和分辨率，然后写一大堆复杂的代码。这听起来很麻烦，对吧？但是，有了操作系统，你只需要调用一个简单的函数，比如<code>LineTo()</code>，然后操作系统会为你处理所有的细节。</p><p>在操作系统的早期，程序员确实需要直接与硬件交互，这是一件非常繁琐和复杂的事情。但随着时间的发展，操作系统逐渐成熟，它开始为程序员提供了一系列的“抽象”概念，使得程序员可以更加轻松地开发应用程序，而不需要关心硬件的细节。比如，在UNIX系统中，访问硬件设备就像访问普通文件一样简单；在Windows系统中，图形和声音设备被抽象成了特定的对象。</p><p>但是，谁来处理这些复杂的硬件操作呢？答案是：<strong>硬件驱动程序</strong>。它们是<strong>操作系统的一部分</strong>，专门负责与特定的硬件设备交互。这些驱动程序通常由硬件制造商开发，而操作系统提供了一系列的接口和框架，使得这些驱动程序可以在操作系统上运行。</p><p>最后，让我们以读取文件为例。当你想读取一个文件时，你不需要知道这个文件在硬盘上的具体位置。你只需要告诉操作系统你想读取的文件名，然后操作系统会找到这个文件在硬盘上的位置，读取它，并将数据返回给你。这一切都是由文件系统和硬盘驱动程序共同完成的。</p><p>总之，操作系统就像是一个超级英雄，它为我们处理了所有复杂的硬件操作，使得我们可以更加轻松地开发和使用计算机程序。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS问题排查思路</title>
    <link href="/p/23c3db21.html"/>
    <url>/p/23c3db21.html</url>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><p>这篇博客主要是在推特中无意翻到了这篇博客，尝试以翻译的形式做一套笔记，分享的同时加强自己的记忆。</p><ul><li><a href="https://jvns.ca/blog/2023/07/28/why-is-dns-still-hard-to-learn/">Why is DNS still hard to learn? (jvns.ca)</a></li></ul><h1 id="系统背后做的事情"><a class="markdownIt-Anchor" href="#系统背后做的事情"></a> 系统背后做的事情</h1><p>当我们发起一个DNS请求的时候，基本上发生的就是下面两件事</p><ol><li>电脑向一个被标记为<code>resolver</code>的服务器发送一个DNS请求。</li><li><code>resolver</code>服务器首先会检查缓存，并且在必要的时候再向<code>authoritative nameservers</code>发送查询请求。</li></ol><p>但是在这两件事情背后，我们有几个问题需要思考</p><ul><li><p>解析服务器（即上面提到的<code>resolver</code>）的缓存中存放了一些什么东西？</p></li><li><p>在计算机中，在发起一个<code>DNS</code>请求的时候调用的是哪一部分的库？</p><blockquote><p>举个例子，一个请求有可能是由<code>libc</code>中提供的<code>getaddrinfo</code>发起的，这部分代码或是来自<code>glibc</code>，或是<code>musl</code>，又或者是<code>apple</code>提供的库文件；这个请求也有可能是在浏览器中发起，由浏览器进行处理；当然也有可能是某些特定的自定义实现。</p><p>在不同的阶段和方法进行<code>DNS</code>请求做的事情都会略有不同，他们或多或少会有不一样的配置、缓存以及功能。举个例子来说，直到今年（2023）<code>musl</code>的<code>DNS</code>才开始支持<code>TCP</code>询问</p></blockquote></li><li><p>解析器和权威域名服务器（即上文中提到的<code>authoritative nameservers</code>）之间是如何进行通话的？</p><blockquote><p>在这里我们如果能知道在<code>DNS</code>请求期间询问了哪些下游的权威域名服务器，以及他们提供了哪些信息，则很多东西都会非常好理解。</p></blockquote></li></ul><h1 id="了解系统背后发生的事情"><a class="markdownIt-Anchor" href="#了解系统背后发生的事情"></a> 了解系统背后发生的事情</h1><h2 id="获取更详细的dns信息"><a class="markdownIt-Anchor" href="#获取更详细的dns信息"></a> 获取更详细的DNS信息</h2><p>为了让我们可以在获取<code>DNS</code>请求的时候，获取到更多的调试信息，我们可以尝试用<code>dig</code>工具来获取一些信息。一个例子如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dig @223.5.5.5 whatdontexist.lol                                                ] 8:26 PM</span><br><br>; &lt;&lt;&gt;&gt; DiG 9.18.12-0ubuntu0.22.04.2-Ubuntu &lt;&lt;&gt;&gt; @223.5.5.5 whatdontexist.lol<br>; (1 server found)<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 19819<br>;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0<br><br>;; QUESTION SECTION:<br>;whatdontexist.lol.             IN      A<br><br>;; AUTHORITY SECTION:<br>lol.                    3593    IN      SOA     ns0.centralnic.net. hostmaster.centralnic.net. 1690719195 900 1800 6048000 3600<br><br>;; Query time: 0 msec<br>;; SERVER: 223.5.5.5#53(223.5.5.5) (UDP)<br>;; WHEN: Sun Jul 30 20:26:45 CST 2023<br>;; MSG SIZE  rcvd: 100<br></code></pre></td></tr></table></figure><p>在上面这个示例中，我通过向一个不存在的域名：<code>whatdontexist.lol</code>发起了一个<code>DNS</code>请求。我们可以在这里看到许多有意思的信息，比如我们是对<code>223.5.5.5</code>这个<code>DNS</code>服务器，通过<code>UDP</code>发起的请求等等。</p><h2 id="奇妙的调试信息"><a class="markdownIt-Anchor" href="#奇妙的调试信息"></a> 奇妙的调试信息</h2><p>通过使用<code>dig</code>，我们可以知道很多额外的信息。举个例子，我们可以使用<code>dig +norecurse</code>指令来弄清楚<code>DNS</code>解析服务器目前有没有针对某个特定记录的缓存。对于某个特定的记录，如果不存在缓存，则会返回一个<code>SERVFAIL</code>的状态</p><p>举个例子，我们首先可以向<code>223.5.5.5</code>这个阿里的<code>DNS</code>请求<code>www.baidu.com</code>的<code>DNS</code>条目（大概率来说应该是缓存了百度的域名解析的）</p><p><img src="https://lsky.halc.top/J4Tc62.png" alt="阿里解析百度域名" /></p><p>我们可以看到上图中获取到的<code>status</code>为<code>NOERROR</code>，也就意味着百度在阿里云的<code>DNS</code>服务器中可以正常返回需要的结果。</p><p>现在我们再尝试请求一个不是很常见的域名<code>homestarrunner.com</code>，我们可以发现<code>status</code>变成了<code>SERVFAIL</code></p><p><img src="https://lsky.halc.top/VLzQ1J.png" alt="请求一个不常见的域名" /></p><p>这里的<code>SERVFAIL</code>并不代表不存在对于<code>homestarrunner.com</code>的域名解析，只是在阿里云的服务器中并没有缓存这个域名而已。</p><p>不过对于上面这一长串由<code>dig</code>提供的调试信息，如果我们不是经常和它打交道的话看着还是会有点迷惑。比如：</p><ol><li><code>-&gt;&gt;HEADER&lt;&lt;-</code>，<code>flags:</code>，<code>OPT PSEUDOSECTION:</code>，<code>QUESTION SECTION:</code>，<code>MSG SIZE rcvd: 59</code>这些都是啥玩意？</li><li>为什么有的地方看起来是新内容但没换行（比如<code>OPT PSEUDOSECTION:</code>和<code>QUESTION SECTION:</code>）？</li><li>为什么有的返回报文中<code>MSG SIZE rcvd: 59</code>这里是<code>59</code>，而有的报文又是<code>90</code>？不同的报文之间是有啥不同的字段吗？</li></ol><p>总之，从上面的一些问题中，我们可以发现<code>dig</code>的一些输出内容有点像是某些人临时写的一个用于获取这些信息的脚本，而并非有意为了可读性进行一些刻意的设计，为此我们有的时候需要查阅文档来搞懂发生了什么。</p><h3 id="一些小工具"><a class="markdownIt-Anchor" href="#一些小工具"></a> 一些小工具</h3><ol><li><p>这里有一篇文章是原博客作者介绍了如何使用<code>dig</code>的：<a href="https://jvns.ca/blog/2021/12/04/how-to-use-dig/">How to use dig (jvns.ca)</a></p></li><li><p>还有三个工具可以用于更友好的进行一些简单的调试：</p><ul><li><a href="https://github.com/ogham/dog">ogham/dog: A command-line DNS client. (github.com)</a></li><li><a href="https://github.com/mr-karan/doggo">mr-karan/doggo: 🐶 Command-line DNS Client for Humans. Written in Golang (github.com)</a></li><li><a href="https://dns-lookup.jvns.ca/">a simple DNS lookup tool (jvns.ca)</a></li></ul><p>不过对于这些工具有的时候会缺少一些高级功能，比如在原博客发布的时候<code>dog</code>和<code>doggo</code>都还不支持<code>+norecurse</code>这样的功能。所以有的时候学会<code>dig</code>还是有用的</p></li><li><p>通过添加一个<code>+yaml</code>的参数，可以让<code>dig</code>的输出信息更加格式化。不过这样的缺点是返回的信息有点太多了。</p></li></ol><h1 id="小心踩坑"><a class="markdownIt-Anchor" href="#小心踩坑"></a> 小心踩坑</h1><p>在<code>DNS</code>请求中，总是会出现一些奇奇怪怪但是容易不小心就掉进去的陷进。</p><blockquote><p>一些更常见的问题可以翻阅这篇博客：<a href="https://jvns.ca/blog/2022/01/15/some-ways-dns-can-break/">Some ways DNS can break (jvns.ca)</a></p></blockquote><ul><li><p>被动缓存：由于<code>DNS</code>会记录<strong>不存在的域名</strong>，因此假设你在类似<code>cloudflare</code>一类的平台添加自己的<code>DNS</code>解析之前，如果先在自己电脑上访问并被系统缓存了&quot;该域名不存在解析条目&quot;这个结果，即使你后面为这个域名添加了有效的记录，但也要等到之前那条缓存失效了，新的有效结果才能被识别到。</p></li><li><p>在不同平台上对于<code>getaddrinfo</code>的实现并不相同，比如在今年之前，你是没法通过<code>tcp</code>来在<code>musl</code>平台上发起一个<code>dns</code>请求的。</p></li><li><p>有的解析服务器并不尊重解析本应该有的<code>TTL</code>，比如原本你设置了一个域名<code>abc.com</code>的<code>TTL</code>为一分钟或者两分钟。但是路由器认为大部分网络服务都是稳定的（对于非开发人员来说其实倒也是），有可能就会忽略这一点，而硬给你设置一个比如一两个小时的<code>TTL</code>。结果就会导致本来两分钟就应该生效的修改过了一两个小时都没好</p></li><li><p>在<code>Nginx</code>中，如果你按下面的方式配置了一个反向代理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> https://some.domain.com;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么<code>Nginx</code>只会在第一次启动的时候尝试解析这个域名，之后则再也不会进行解析。如果你在这个过程中修改了<code>some.domain.com</code>域名指向的<code>IP</code>，就很有可能会出现一些不应该出现的问题。</p><blockquote><p>这个问题实际上也有一些解决方案，不过不是这篇博客的重点</p></blockquote></li><li><p><code>ndonts</code>会使得<code>k8s</code>中的<code>DNS</code>请求变慢：<a href="https://pracucci.com/kubernetes-dns-resolution-ndots-options-and-why-it-may-affect-application-performances.html">Kubernetes pods /etc/resolv.conf ndots:5 option and why it may negatively affect your application performances (pracucci.com)</a></p><blockquote><p>由于我自己对<code>k8s</code>目前接触不多，因此这里只是贴了一个链接。等以后有接触以后再回过头来研究研究</p></blockquote></li></ul><p>在<code>DNS</code>上踩坑往往可能是一件不起眼，但是遇到了就挺难排查的问题。也许最好的解决方案还是尽可能的去见识下别人遇到的问题。再放一次作者记录的常见问题：<a href="https://jvns.ca/blog/2022/01/15/some-ways-dns-can-break/">Some ways DNS can break (jvns.ca)</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络抓包记录</title>
    <link href="/p/3930e42b.html"/>
    <url>/p/3930e42b.html</url>
    
    <content type="html"><![CDATA[<h1 id="学习记录"><a class="markdownIt-Anchor" href="#学习记录"></a> 学习记录</h1><p>这个博客主要记录了自己尝试通过抓包分析并解决一些问题的心路历程，从结果上来说很可能问题并没有解决，但是尝试解决这个问题的过程中遇到的一些问题以及自己的思考想通过写博客的方式先记录下来，在以后自己知识储备扩充的时候也许就可以回过头来看看解决下。</p><h1 id="第一次抓包"><a class="markdownIt-Anchor" href="#第一次抓包"></a> 第一次抓包</h1><h2 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h2><p>今天在尝试部署<code>zerotier</code>的<code>zeronsd</code>私有<code>DNS</code>服务的时候遇到了一个问题：无论是在我之前国内的服务器A上还是香港的服务器B上，<code>zeronsd</code>的部署都是只需要无脑复制粘贴指令就能成功，但是今天尝试在新租赁的国内服务器C上部署的时候则遇到了一个报错：<code>Error Response</code></p><p><img src="https://lsky.halc.top/wEbLzt.png" alt="不明所以的报错" /></p><p>在翻阅<code>zeronsd</code>源码的时候发现这块逻辑本来应该是对应请求<code>zerotier</code>那边获取到局域网内所有设备的<code>IP</code>以便于创建私有的<code>DNS</code>条目。</p><p><img src="https://lsky.halc.top/kIq3eR.png" alt="zeronsd源码" /></p><p>可以看见这部分错误处理里面并没有<code>Error Response</code>的产生原因，而且同时我在香港的服务器上依旧可以正常使用<code>zeronsd</code>。因此也产生了想尝试通过抓包找到问题所在的想法。</p><h2 id="解决过程"><a class="markdownIt-Anchor" href="#解决过程"></a> 解决过程</h2><h3 id="通过lsof获取目标ip"><a class="markdownIt-Anchor" href="#通过lsof获取目标ip"></a> 通过<code>lsof</code>获取目标IP</h3><p>既然知道了问题是来自于<code>zeronsd</code>，而且应该是一个和网络<code>Response</code>有关系的问题，那么通过抓包应该是最通用的排查方法。在这里首先通过<code>lsof</code>工具查询<code>zeronsd</code>打开的连接</p><blockquote><p>最开始找到的指令是先通过<code>pidof zeronsd</code>找到进程的<code>pid</code>，然后通过<code>pid</code>来用<code>lsof</code>查询，指令大概是<code>lsof -p $(pidof zeronsd)</code>，结果后面翻了下<code>lsof</code>的手册，发现可以直接用<code>-c</code>来找进程，不过<code>pidof</code>以后也感觉会用到，姑且做个记录。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Aliyun:~]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">lsof -c zeronsd</span><br>COMMAND   PID USER   FD      TYPE             DEVICE SIZE/OFF   NODE NAME<br>zeronsd 18437 root  cwd       DIR              254,1     4096      2 /<br>zeronsd 18437 root  rtd       DIR              254,1     4096      2 /<br>zeronsd 18437 root  txt       REG              254,1  8752136 804251 /usr/bin/zeronsd<br>zeronsd 18437 root  mem       REG              254,1    93000 787112 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so<br>zeronsd 18437 root  mem       REG              254,1    26952 787106 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so<br>zeronsd 18437 root  mem       REG              254,1    51696 787107 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so<br>zeronsd 18437 root  mem       REG              254,1  1901536 786465 /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>zeronsd 18437 root  mem       REG              254,1    18688 787097 /usr/lib/x86_64-linux-gnu/libdl-2.31.so<br>zeronsd 18437 root  mem       REG              254,1  1321344 787098 /usr/lib/x86_64-linux-gnu/libm-2.31.so<br>zeronsd 18437 root  mem       REG              254,1   149520 787110 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so<br>zeronsd 18437 root  mem       REG              254,1   100736 786450 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1<br>zeronsd 18437 root  mem       REG              254,1  3076992 802235 /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1<br>zeronsd 18437 root  mem       REG              254,1   597792 802236 /usr/lib/x86_64-linux-gnu/libssl.so.1.1<br>zeronsd 18437 root  mem       REG              254,1   177928 786460 /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>zeronsd 18437 root    0r      CHR                1,3      0t0      4 /dev/null<br>zeronsd 18437 root    1u     unix 0x0000000070328a2d      0t0 105666 type=STREAM<br>zeronsd 18437 root    2u     unix 0x0000000070328a2d      0t0 105666 type=STREAM<br>zeronsd 18437 root    3u  a_inode               0,13        0   8321 [eventpoll]<br>zeronsd 18437 root    4u  a_inode               0,13        0   8321 [eventfd]<br>zeronsd 18437 root    5u  a_inode               0,13        0   8321 [eventpoll]<br>zeronsd 18437 root    6u     unix 0x000000008c202115      0t0 105669 type=STREAM<br>zeronsd 18437 root    7u     unix 0x0000000072325ef6      0t0 105670 type=STREAM<br>zeronsd 18437 root    8u     unix 0x000000008c202115      0t0 105669 type=STREAM<br>zeronsd 18437 root    9u     IPv4             104709      0t0    TCP iZf8zgk9dawv2exr28bz0oZ:57136-&gt;151.101.109.91:https (SYN_SENT)<br></code></pre></td></tr></table></figure><p>可以发现下面有创建一个<code>TCP</code>连接，并且是处于<code>SYN_SENT</code>的状态。同时在我短时间内重复输入<code>lsof</code>的指令（蠢但有效.jpg），发现返回的依旧是<code>SYN_SENT</code>。一般来说<code>SYN</code>握手的速度应该是很快的，这里很长时间内都处于<code>SYN_SENT</code>的状态就明显很不对劲，所以接下来就需要通过抓包来分析。</p><p>在我多次尝试了<code>lsof</code>之后，发现即使有的时候能让连接处于<code>ESTABLISHED</code>的状态，但是过了一会以后依旧会被掐断，并且返回<code>Error Response</code>。通过分析不同的<code>lsof</code>建立<code>TCP</code>连接的目标<code>ip</code>,发现服务器总是向<code>151.101.109.91</code>和<code>146.75.113.91</code>建立连接，应该是请求的域名有做<code>CDN</code>所以解析到了不同的<code>IP</code>。接下来知道了目标<code>IP</code>，抓包就很容易了。这里采取的是通过<code>tshark</code>在配置较弱的服务器上获取到了数据包以后再导出到本地计算机的<code>Wireshark</code>的方法进行分析。</p><h3 id="tshark抓包分析"><a class="markdownIt-Anchor" href="#tshark抓包分析"></a> <code>tshark</code>抓包分析</h3><p>首先使用下面的指令对所有<code>http</code>请求进行抓取，并将抓包的内容保存在<code>data.cap</code>文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tshark -d tcp.port==443,http -w data.cap<br></code></pre></td></tr></table></figure><p>之后再将这个文件下载到本地电脑使用<code>Wireshark</code>过滤选定目标<code>IP</code>追踪<code>TCP</code>流，可以发现数据流如下图</p><p><img src="https://lsky.halc.top/Fm7IOM.png" alt="数据流" /></p><p>可以发现就这一次的数据来说<code>SYN</code>握手的部分是成功了的，<code>TLS</code>的四次握手也能成功建立，但是在发送了一些应用数据之后，云的服务器就开始向远端服务器发送<code>RST</code>报文来请求强制终止连接了。重新抓包以后又发现出现了多次<code>TCP</code>数据包的重传。</p><p>对于在TCP连接中，先发送了<code>FIN</code>，然后发送<code>RST</code>的一个可能性的原因如下：</p><ul><li><a href="https://serverfault.com/questions/854692/client-sends-rst-after-fin-ack">packet capture - Client sends RST after FIN,ACK - Server Fault</a></li></ul><blockquote><p>您的流中的FIN和RST数据包并不直接相关。通过发送FIN，表示没有更多要发送的数据。它仍然可以从连接的另一端接收更多数据。然而，当有更多数据到达时，发送RST来表示应用程序将不再从套接字读取任何数据。</p><p>如果一个应用程序想要干净地关闭TCP连接而不引发任何RST数据包，则必须首先使用shutdown系统调用关闭写入套接字，同时保持读取套接字处于打开状态。在关闭写入套接字之后，它仍然需要读取所有对方要发送的数据，然后才能完全关闭套接字。</p></blockquote><p>但是<code>zeronsd</code>对于这次连接的重置是返回了<code>Error</code>的，所以基本上可以判断并不是<code>zeronsd</code>本身发送的<code>rst</code>阻断连接。</p><p>在这里为了让后续抓包更容易复现，首先对于<code>TLS</code>建立握手的第一个数据包，我们可以直接查询到域名</p><img src="https://lsky.halc.top/3bRIeE.png" alt="检查TLS握手的域名" style="zoom:50%;" /><p>之后我就尝试通过<code>curl -vL my.zerotier.com</code>的方法来通过抓取<code>curl</code>包分析问题。为了区分成功和失败的区别，我在这里也使用了<code>curl -vL www.baidu.com</code>作为对照组。</p><h4 id="百度请求"><a class="markdownIt-Anchor" href="#百度请求"></a> 百度请求</h4><p>返回的抓包内容大致如下：</p><p><img src="https://lsky.halc.top/DKeJLu.png" alt="使用curl请求百度" /></p><p>可以发现整个连接没有大问题，只是在连接结束以后百度那边发送了一个<code>rst</code>包给我们，但是<code>tcp</code>的四次挥手是正常完成了的。</p><h4 id="zerotier请求"><a class="markdownIt-Anchor" href="#zerotier请求"></a> Zerotier请求</h4><p><img src="https://lsky.halc.top/5fRpjw.png" alt="使用curl请求zerotier" /></p><p>可以发现在想要结束连接的时候并没有正常挥手，在客户端这边接收到服务器那边的<code>FIN</code>之前就开始给服务器发送<code>RST</code>报文尝试断开连接</p><h2 id="总述"><a class="markdownIt-Anchor" href="#总述"></a> 总述</h2><p>这次抓包本身没有获取到啥决定性的信息可以确定问题产生的原因，因此目前自己也只能借由<code>Zerotier</code>和百度请求的对比，怀疑是因为<code>Zerotier</code>是国外网站，被服务商阻断了（但是在<code>FIN</code>之后再阻断也很奇怪，虽然会在<code>FIN</code>之后发送<code>RST</code>报文，但是<code>curl</code>还是可以读取到<code>my.zerotier.com</code>的网页信息），暂时对进一步的排查没有头绪。</p><h1 id="第二次遇到问题"><a class="markdownIt-Anchor" href="#第二次遇到问题"></a> 第二次遇到问题</h1><p>我尝试在同一台服务器上部署一个<code>VOIP</code>服务器。也是一样使用别的服务器的时候一点问题都没有，但是在这台国内的服务器上就遇到问题了。这次遇到问题就想尽可能的搞懂原因，因此做了以下实验</p><h2 id="分情况尝试连接"><a class="markdownIt-Anchor" href="#分情况尝试连接"></a> 分情况尝试连接</h2><ul><li><p>实验设备：一台香港服务器（对照组），一台阿里云国内服务器（样本组），以及自己的<code>Windows</code>设备</p></li><li><p>实验情景：在香港和国内服务器上都部署<code>Mumble</code>的服务器（一个<code>VOIP</code>程序），然后使用<code>Windows</code>对这两台服务器进行连接，其中<code>Mumble</code>连接采取了<code>TLS</code>加密的方式，加密证书均为自签。</p></li><li><p>实验步骤：</p><ol><li>使用IP直连香港服务器上在端口<code>64738</code>部署的<code>murmur</code>（<code>Mumble</code>服务端的别称）</li><li>使用域名<code>voice1.abc.com</code>连接香港服务器在端口<code>64738</code>部署的<code>murmur</code></li><li>使用IP直连国内服务器上在端口<code>64738</code>部署的<code>murmur</code></li><li>使用域名<code>voice2.abc.com</code>连接国内服务器在端口<code>64738</code>部署的<code>murmur</code></li></ol></li><li><p>实验期望：四种不同的方式连接<code>murmur</code>都能成功，且不会有明显区别</p></li><li><p>实验结果：方法1-3都可以正常访问，但是方法4连接被服务器阻断</p></li></ul><h2 id="抓包分析问题"><a class="markdownIt-Anchor" href="#抓包分析问题"></a> 抓包分析问题</h2><p>在对以上四种情况进行抓包以后，获取到的<code>Wireshark</code>图像大致如下</p><ol><li><p>香港服务器使用域名连接</p><p><img src="https://lsky.halc.top/2nYkkM.png" alt="香港 - 域名连接" /></p></li><li><p>香港服务器使用IP直连</p><p><img src="https://lsky.halc.top/DzjxGf.png" alt="香港 - IP直连" /></p></li><li><p>国内服务器使用IP直连</p><p><img src="https://lsky.halc.top/oq3GCR.png" alt="国内 - IP直连" /></p></li><li><p>国内服务器使用域名连接</p><p><img src="https://lsky.halc.top/BOOb7K.png" alt="国内 - 域名连接" /></p></li></ol><p>到这里基本上很明显可以发现只有在国内服务器使用域名连接的时候，服务器那边会在进行<code>TLS</code>握手的时候直接进行阻断，让你无法成功建立<code>TLS</code>连接</p><h2 id="总述-2"><a class="markdownIt-Anchor" href="#总述-2"></a> 总述</h2><p>这次抓包也没获得啥特别有用的信息。不过由于这个问题是在用阿里云的时候才遇到，之前用同样在国内的腾讯云没有遇到，则初步怀疑是阿里云对任意端口（非443）现在都做了备案检测，只要是没备案的域名/网站，无论是<code>TLS</code>还是明文，只要检测到你用了域名就禁封。相比之下腾讯那边就要宽松一些，至少<code>murmur</code>在腾讯云上是可以正常使用域名进行连接通讯的。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法（一）</title>
    <link href="/p/83fa91fc.html"/>
    <url>/p/83fa91fc.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础算法一"><a class="markdownIt-Anchor" href="#基础算法一"></a> 基础算法（一）</h1><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><h3 id="快排"><a class="markdownIt-Anchor" href="#快排"></a> 快排</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p></blockquote><p>快排的主要思想是基于分治</p><h4 id="找到分界点"><a class="markdownIt-Anchor" href="#找到分界点"></a> 找到分界点</h4><p>对于一整串数组，首先找到一个值作为分界点。分界点的取值有三种取值方法：</p><ul><li>取区间的左边界</li><li>取区间的中间位置的值</li><li>随机取一个位置</li></ul><h4 id="调整区间"><a class="markdownIt-Anchor" href="#调整区间"></a> 调整区间</h4><p>让分界点（设为x）前面的区间部分全都是小于等于x的值，数组后面的部分则都是大于等于x的部分。</p><h4 id="递归处理左右两段"><a class="markdownIt-Anchor" href="#递归处理左右两段"></a> 递归处理左右两段</h4><p>再对区间的左和右分别进行排序，只要两侧都成功排序那么整个区间就完成了排序。</p><hr /><p>该问题在处理的过程中主要的操作就是调整区间。并且最后的效果是让区间处于了两种互斥的不同状态。因此可以用双指针的做法，同时从前和末端向中间进行扫描，当他们一方扫描到需要进行交换的异端分子的时候，就等待另一端也扫描出同样的异端分子。当双方都扫描到对方的异端分子的时候，只需要将这两个异端分子同时交换，当两个指针相遇的时候，也就是处理好了所有异端分子的时候。</p><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt;= r)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-type">int</span> x = q[(l + r) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>    <span class="hljs-keyword">do</span><br>      i++;<br>    <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>    <span class="hljs-keyword">do</span><br>      j--;<br>    <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>    <span class="hljs-keyword">if</span> (i &lt; j)<br>      <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>  &#125;<br>  <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第k个数"><a class="markdownIt-Anchor" href="#第k个数"></a> 第k个数</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/788/">786. 第k个数 - AcWing题库</a></p></blockquote><h4 id="找到分界点-选取区间"><a class="markdownIt-Anchor" href="#找到分界点-选取区间"></a> 找到分界点、选取区间</h4><p>分界点的选取和快排相同。不同的是由于我们这里只需要第k小的数，因此在此时对划分出来的区间长度进行判断。如果k的大小小于左区间长度l，那么说明k在左区间，继续从左区间寻找第k小的数。如果k的大小大于l，说明k在右区间，在右区间寻找第(k - l)小的数。</p><hr /><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">k_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt;= r)<br>    <span class="hljs-keyword">return</span> q[l];<br>  <span class="hljs-type">int</span> x = q[(l + r) &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>    <span class="hljs-keyword">do</span><br>      i++;<br>    <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>    <span class="hljs-keyword">do</span><br>      j--;<br>    <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>    <span class="hljs-keyword">if</span> (i &lt; j)<br>      <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>  &#125;<br><br>  <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (k &lt;= sl)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">k_sort</span>(l, j, k);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">k_sort</span>(j + <span class="hljs-number">1</span>, r, k - sl);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/789/">787. 归并排序 - AcWing题库</a></p></blockquote><ol><li>确定分界点：<code>mid = (l + r) / 2</code></li><li>分别递归排序左区间和右区间</li><li>将两个数组合并</li></ol><h3 id="双指针合并"><a class="markdownIt-Anchor" href="#双指针合并"></a> 双指针合并</h3><p>归并排序的主要思路就是将原本一个大数组，使用分治的思想，从单个数字的小数组进行不断的归并，最后获得的就是一个有序的新数组。因此主要的操作也就是在合并的这个操作上。</p><p>我们需要合并的数组有两个，因此这部分只需要用两个数组分别指向这两个数组的开头。然后再创建一个临时数组用于存放归并的结果。归并的过程中只需要每次都将两个指针中最小的那个输入加入临时数组中，然后将存入的指针后移，直到两个数组中其中一个被归并完毕，再将另外一个数组后面所有的结果合入答案的临时数组，最后将临时数组的结果写入原数组中即可。</p><hr /><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt;= r)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 将区间分成左右两边，归并合并</span><br>  <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">merge_sort</span>(q, l, mid), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>  <span class="hljs-type">int</span> merged = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 使用一个tmp的临时数组来存储归并后的结果</span><br>  <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>    <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>      tmp[merged++] = q[i++];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      tmp[merged++] = q[j++];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将多余结尾的部分插入tmp当中</span><br>  <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>    tmp[merged++] = q[i++];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>    tmp[merged++] = q[j++];<br>  &#125;<br>  <span class="hljs-comment">// 将tmp合并好的数组返回输入给q[]中</span><br>  <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>    q[i] = tmp[j];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求逆序对的数量"><a class="markdownIt-Anchor" href="#求逆序对的数量"></a> 求逆序对的数量</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量 - AcWing题库</a></p></blockquote><blockquote><p>逆序对：5 2 2 1 4，只要前面一个数比后面一个数字大，即为一个逆序对，因此有[5, 2], [5, 2], [2, 1], [5, 1],  [5, 4]。这五个逆序对</p></blockquote><p>首先，这个问题可以在对一个区间对半切割以后分为三种情况</p><p><img src="https://lsky.halc.top/bNkSHs.png" alt="区间分类" /></p><ul><li>在左区间中存在两个数字是逆序对</li><li>在右区间中存在两个数字是逆序对</li><li>在中间的两个黄色中，左区间存在一个数字是右区间的逆序对</li></ul><p>其次，在这里引入归并排序的思想。在归并排序中，对于整个区间的排序本质上是对于最小区间（两个数字）之间的大小比较和扶正，最后扩展为整个区间的大小比较和扶正（分治）。带入到这个问题中，其实就是首先视 <strong>第三种情况</strong> 为最小的情况，然后最后的所有结果其实都是第三种情况的总和，所谓的第一种情况和第二种情况将会在最小区间的过程中被直接统计进入结果当中，也就是说我们只需要求出所有第三种情况逆序对的数量再加起来就是最后答案。</p><h4 id="对于左右区间逆序对数量的判断"><a class="markdownIt-Anchor" href="#对于左右区间逆序对数量的判断"></a> 对于左右区间逆序对数量的判断</h4><p><img src="https://lsky.halc.top/ZNhDJ8.png" alt="逆序对的数量计算" /></p><p>目前我们只考虑黄色的情况，因此对于一个区间，我们可以分成<code>p</code>和<code>q</code>两个部分来考虑。假设在<code>p</code>和<code>q</code>上有符合归并排序的两个指针i和j,且当前的情况符合了逆序对的<code>p[i] &gt; q[j]</code>的定义。此时我们可以很容易就知道从i到mid这整个区间的数字都是大于q[j]的，而这个区间内数字的数量为<code>mid - i + 1</code>。通过这个规律，我们就可以知道如果我们想要统计所有的黄色情况中逆序对的数量，我们只需要将所有符合<code>p[i] &gt; q[j]</code>情况的<code>mid - i + 1</code>数量加起来，就是最后答案。</p><hr /><p>代码实现：</p><blockquote><p>关于计算逆序对的数量问题，假设总共有n个数据，由于每两个数据是一组，从<code>n</code>和<code>n-1</code>可以为一组的情况下来考虑，最后总共可以有(n(n - 1))/2大小的答案，如果数据集到达了类似100000量级的时候，最后答案会超过int的范围，因此有可能需要使用<code>long long</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> tmp[N], q[N], n;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">count_pair</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt;= r)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 将左区间和右区间分治的结果加起来</span><br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-built_in">merge_sort</span>(l, mid) + <span class="hljs-built_in">merge_sort</span>(mid + <span class="hljs-number">1</span>, r);<br>  <span class="hljs-type">int</span> merged = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>    <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>      <span class="hljs-comment">// 不符合逆序对，直接归并</span><br>      tmp[merged++] = q[i++];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 符合逆序对的定义，归并的同时统计结果数量</span><br>      tmp[merged++] = q[j++];<br>      res += mid - i + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将归并以后长的部分合并</span><br>  <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>    tmp[merged++] = q[i++];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>    tmp[merged++] = q[j++];<br>  &#125;<br>  <span class="hljs-comment">// 将排序以后的数组恢复到q[]内</span><br>  <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>    q[i] = tmp[j];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a class="markdownIt-Anchor" href="#二分"></a> 二分</h2><p>二分算法的本质为在一个区间中，存在一个位置使得区间的性质发生了变化，进而来寻找这个变化的点。</p><p><img src="https://lsky.halc.top/qqbq2L.png" alt="二分示意图" /></p><p>以上面这个图为例，对于红色区间和绿色区间，假设他们有不同的性质，且一个以A作为分界点，一个以B作为分界点。那么在使用二分的时候就有两种考虑</p><h3 id="二分的分类讨论"><a class="markdownIt-Anchor" href="#二分的分类讨论"></a> 二分的分类讨论</h3><p>在分类之前，首先对于所有的二分情况都有一个<code>check()</code>函数，用于判断某个点是否符合某个状态。在这里我们假设为某个点是否符合某个颜色（红/绿）区间的范围内</p><h4 id="红色区间"><a class="markdownIt-Anchor" href="#红色区间"></a> 红色区间</h4><h5 id="区间左边界右移"><a class="markdownIt-Anchor" href="#区间左边界右移"></a> 区间左边界右移</h5><p>如果我们需要使用二分法来取得A点的位置，那么假设我们先设了中点<code>mid=(l + r)/2</code>，那么就有两种情况。第一种情况是<code>mid</code>处于红色范围内，那么我们便很容易可以知道点<code>A</code>一定在<code>mid</code>到<code>r</code>之间</p><p><img src="https://lsky.halc.top/F6D4Iq.png" alt="分类一" /></p><p>此时我们只需要有新的<code>l = mid</code>，然后从<code>l</code>到<code>r</code>中再次进行二分，直到<code>l</code>和<code>r</code>不为<code>l &lt; r</code>的关系即可</p><h5 id="区间右边界左移"><a class="markdownIt-Anchor" href="#区间右边界左移"></a> 区间右边界左移</h5><p>和上图相反，如果我们是<code>mid</code>处于了绿色范围中，那么我们首先可以知道的是，<code>mid</code>这个点自身是不符合红色区间的范围的。因此我们也只需要有新的<code>r = mid - 1</code>即可。</p><hr /><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_left</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-comment">// 由于r是以mid - 1来进行更新移动，因此如果没有+ 1的话将会出现死循环</span><br>    <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>      l = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="绿色区间"><a class="markdownIt-Anchor" href="#绿色区间"></a> 绿色区间</h4><p>绿色区间和红色区间主要思路完全相同，只有区间在移动边界的时候条件不同。当需要右移区间的时候，有<code>l = mid + 1</code>，而区间如果要左移，只需要<code>r = mid</code>即可。因为这里这里不存在<code>mid</code>当区间长度为2的时候，如果右移区间会死循环的问题，因此<code>mid</code>直接取<code>(l + r) &gt;&gt; 1</code>即可。</p><hr /><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>      r = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数的范围"><a class="markdownIt-Anchor" href="#数的范围"></a> 数的范围</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/791/">789. 数的范围 - AcWing题库</a></p></blockquote><p>首先对于二分的题目，首先找出区分***红色区间***和***绿色区间*<strong>的<code>check()</code>函数。在这个题目中，主要目的是找到针对某个数字<code>target</code>，求出在数组中<code>target</code>最小的区间边界和最大的区间边界。因此可以通过</strong>大于等于<code>target</code><strong>和</strong>小于等于<code>target</code>**来写出两个二分的函数，分别用于寻找左边界和右边界的位置</p><hr /><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取区间左边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_left</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numbers[mid] &gt;= value) &#123;<br>      r = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 获取区间右边界</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_right</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numbers[mid] &lt;= value) &#123;<br>      l = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度问题"><a class="markdownIt-Anchor" href="#高精度问题"></a> 高精度问题</h2><h3 id="高精度加法"><a class="markdownIt-Anchor" href="#高精度加法"></a> 高精度加法</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/793/">791. 高精度加法 - AcWing题库</a></p></blockquote><p>高精度加法本质就是以字符串将数字读入以后，代码模拟手动计算十进制的过程，大于十就进一位。</p><hr /><p>模板实现：</p><blockquote><p>这里一定要注意<code>A[i]</code>或者<code>B[i]</code>是否为数字，如果是字符的话还需要进行<code>- '0'</code>来让结果变成数字</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; C;<br>  <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否进位</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>())<br>      t += A[i]; <span class="hljs-comment">// 记得确保这里加入的是数字，而不是字符</span><br>    <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>())<br>      t += B[i];<br>    C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>    t /= <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (t)<br>    C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法"><a class="markdownIt-Anchor" href="#高精度减法"></a> 高精度减法</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/794/">792. 高精度减法 - AcWing题库</a></p></blockquote><p>高精度减法在实现之前，首先要确定被减项比减去的值要大，如果小的话则要提前分类讨论输出一个负号。</p><hr /><p>判断大小的一个简单实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;rhs, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;lhs) &#123;<br>  <span class="hljs-comment">// 如果是&quot;987&quot;，读入的则是&quot;789&quot;。所以只需要从后向前逐步判断</span><br>  <span class="hljs-keyword">if</span> (rhs.<span class="hljs-built_in">size</span>() != lhs.<span class="hljs-built_in">size</span>())<br>    <span class="hljs-keyword">return</span> rhs.<span class="hljs-built_in">size</span>() &gt; lhs.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rhs.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (rhs[i] != lhs[i]) &#123;<br>      <span class="hljs-keyword">return</span> rhs[i] &gt; lhs[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>对于减法的模拟流程，和加法主要的不同就是借位的操作。借位主要体现在计算第<code>i</code>位的<code>A[i]</code>和<code>B[i]</code>的运算的时候，如果有<code>A[i] - B[i]</code>结果是负数的话，那么<code>A[i]</code>就需要向<code>A[i + 1]</code>进行借位。这个时候我们只需要单独使用一个变量<code>t</code>，如果当前运算结果为负数需要借位了则让<code>t</code>为<code>1</code>，并且在每次运算前让<code>A[i]</code>减去<code>t</code>来实现借位的操作。</p><p>同时在执行完了减法的逻辑之后，由于减法和加法不同，可能会出现&quot;0001&quot;这种数字，我们还需要将所有除了最后一位（因为答案可能为&quot;0&quot;）的所有<code>0</code>给去掉。因为通过<code>vector</code>存储的数字是倒序，也就是说&quot;0001&quot;在数组里面是<code>[1, 0, 0, 0]</code>。因此我们只需要每次都把答案的末尾给剔除即可。</p><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>  <span class="hljs-comment">// 执行函数前需要先确保传入的A比B大</span><br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  <span class="hljs-comment">// 减法的流程</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-comment">// 判断之前是否进行了借位操作，然后将A[i]的值给t</span><br>    t = A[i] - t;<br>    <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>())<br>      <span class="hljs-comment">// 使用借位以后的A[i]减去B[i]</span><br>      t -= B[i];<br>    <span class="hljs-comment">// (t + 10) % 10 让答案处于0-9绝对值的状态</span><br>    ans.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 如果相减以后的数字是负数代表需要在下一次操作进行借位</span><br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;<br>      t = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      t = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 去掉多余的0</span><br>  <span class="hljs-keyword">while</span> (ans.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; ans.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>)<br>    ans.<span class="hljs-built_in">pop_back</span>();<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度乘法"><a class="markdownIt-Anchor" href="#高精度乘法"></a> 高精度乘法</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/795/">793. 高精度乘法 - AcWing题库</a></p></blockquote><p>高精度乘法的主要思路和高精度加法差不多，这类题目通常为一个大整数乘以一个小整数。对于这种情况下的乘法，我们只需要先将大整数和之前一样序列化成一个<code>vector&lt;int&gt;</code>的变量，然后和加法一样让容器每一位都和小整数相乘，大于<code>10</code>的部分留给下一位用于进位即可。</p><hr /><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-comment">// 如果为0的话，最后答案可能会为&quot;00000&quot;这种需要删除多余字符的vector</span><br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;<br>  &#125;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>())<br>      t += A[i] * b;<br>    ans.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>    t /= <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法"><a class="markdownIt-Anchor" href="#高精度除法"></a> 高精度除法</h3><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/796/">794. 高精度除法 - AcWing题库</a></p></blockquote><p>高精度除法的题目一般形式为一个大数除以一个小数。此时假设大数是<code>123456789</code>，小数是<code>11</code>。这种情况下按照正常计算逻辑大致如下：</p><p><img src="https://lsky.halc.top/g8dPuG.png" alt="除法" /></p><p>由于在加减乘法中，我们都是将数字以<code>[9, 8, 7, 6, 5, 4, 3, 2, 1]</code>的顺序存储的，因此我们在计算除法的时候需要从<code>A[A.size() - 1]</code>的位置开始正常除法的计算逻辑，直到<code>A[0]</code>。其中在每次除的过程中，假设经过上次运算（默认的<code>r = 0</code>）的<code>r</code>是<code>r'</code>，那么在下一次计算的时候用于计算的余数则是<code>r = r' + A[i]</code>，然后只需要将除数放入<code>ans</code>的数组中，然后余数继续留给下一次计算即可。</p><hr /><p>模板实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> diver, <span class="hljs-type">int</span> &amp;reminder)</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  reminder = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    reminder = reminder * <span class="hljs-number">10</span> + A[i];<br>    ans.<span class="hljs-built_in">push_back</span>(reminder / diver);<br>    reminder = reminder % diver;<br>  &#125;<br>  <span class="hljs-comment">// 由于除法是正常顺序进行计算，因此需要将答案反转以后去掉前导0</span><br>  <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">while</span> (ans.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; ans.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) &#123;<br>    ans.<span class="hljs-built_in">pop_back</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用clink优化cmd</title>
    <link href="/p/82bd449c.html"/>
    <url>/p/82bd449c.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ul><li><a href="https://github.com/chrisant996/clink">chrisant996/clink: Bash’s powerful command line editing in cmd.exe (github.com)</a></li><li><a href="https://github.com/chrisant996/clink-flex-prompt">chrisant996/clink-flex-prompt: Flex prompt for Clink (github.com)</a></li></ul><h2 id="预先准备"><a class="markdownIt-Anchor" href="#预先准备"></a> 预先准备</h2><p>苦于<code>powershell</code>每次都要一秒多的启动速度，偶然这两天发现了<code>clink</code>这个用于提升<code>cmd</code>体验的工具，尝试了下发现经过简单的配置以后可以替代平时绝大部分<code>ps</code>的需求。因此在这里记录一下基本配置流程。</p><h3 id="安装clink和clink-flex-prompt"><a class="markdownIt-Anchor" href="#安装clink和clink-flex-prompt"></a> 安装clink和clink-flex-prompt</h3><p><code>clink</code>和<code>clink-flex-prompt</code>都可以使用<code>scoop</code>在Windows中完成安装。其中<code>clink</code>的大致效果就是在启动<code>cmd</code>的时候进行注入，来实现一些额外功能的扩展。<code>clink-flex-prompt</code>提供的功能则是类似<code>oh-my-zsh</code>的<code>prompt</code>自定义，让交互界面不至于太苍白</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">scoop install clink clink-flex-prompt<br></code></pre></td></tr></table></figure><p>这两个组件都是在<code>scoop</code>默认的<code>main</code>仓库就有，不需要添加额外的<code>bucket</code>就能直接安装。</p><p>在使用<code>scoop</code>安装了<code>clink</code>之后，还需要使用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clink autorun install<br></code></pre></td></tr></table></figure><p>指令来实现每次启动<code>cmd</code>之前都自动启用<code>clink</code>，也可以使用<code>clink inject</code>来在当前的<code>cmd</code>当中暂时体验一下<code>clink</code>的效果</p><h2 id="配置clink"><a class="markdownIt-Anchor" href="#配置clink"></a> 配置clink</h2><p>依据<a href="https://chrisant996.github.io/clink/clink.html#gettingstarted_enhanceddefaults">Clink官方文档</a>中的提及，原本是会有一个<code>Use enhanced default settings</code>的选项来默认实现一些自动填充或快捷键的功能。但在使用<code>scoop</code>安装<code>clink</code>的情况下，至少可以发现自动显示<code>suggestions</code>补全的功能是没有被配置好的。</p><h4 id="自动补全"><a class="markdownIt-Anchor" href="#自动补全"></a> 自动补全</h4><p>对于<code>autosuggest</code>的功能，只需要执行下面的指令就可以实现</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clink <span class="hljs-built_in">set</span> autosuggest.enable true<br></code></pre></td></tr></table></figure><h4 id="创建inputrc文件"><a class="markdownIt-Anchor" href="#创建inputrc文件"></a> 创建<code>.inputrc</code>文件</h4><p>类似<code>zsh</code>有一个<code>.zshrc</code>，对于<code>clink</code>来说也有一个<code>.inputrc</code>的文件用于初始化<code>clink</code>的配置文件。</p><p>使用<code>CMD</code>输入下面的指令来在<code>Windows</code>的用户目录创建<code>inputrc</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">notepad <span class="hljs-variable">%userprofile%</span>\.inputrc<br></code></pre></td></tr></table></figure><p>创建好了以后可以在其中粘贴以下内容来实现一些基本的功能：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># Some common Readline config settings.<br><br><span class="hljs-built_in">set</span> colored-stats                 on   # Turn on completion colors.<br><span class="hljs-built_in">set</span> colored-completion-prefix     on   # <span class="hljs-built_in">Color</span> the typed completion prefix.<br><br># Some config settings that only work <span class="hljs-keyword">in</span> Clink.<br><br>$<span class="hljs-keyword">if</span> clink<br><span class="hljs-built_in">set</span> search-ignore-case            on   # Case insensitive history searches.<br><span class="hljs-built_in">set</span> completion-auto-query-items   on   # Prompt before showing completions <span class="hljs-keyword">if</span> they&#x27;ll exceed half the screen.<br>$endif<br><br># Add your keybindings here...<br></code></pre></td></tr></table></figure><blockquote><p>对于具体<code>inputrc</code>的配置写法可以看这里：<a href="https://chrisant996.github.io/clink/clink.html#init-file">Init File</a></p></blockquote><h3 id="使用clink-flex-prompt自定义终端提示"><a class="markdownIt-Anchor" href="#使用clink-flex-prompt自定义终端提示"></a> 使用clink-flex-prompt自定义终端提示</h3><p>使用<code>scoop</code>安装了<code>flex-prompt</code>以后的使用方式也很简单。只需要在<code>cmd</code>里面执行<code>flexprompt configure</code>以后，就可以像<code>p10k</code>那样来自定义一个自己需要的，较为美观的终端提示了。这一块都是有可视化交互的，就不做过多的赘述。</p><h3 id="实现linux中的一些基础指令"><a class="markdownIt-Anchor" href="#实现linux中的一些基础指令"></a> 实现Linux中的一些基础指令</h3><p>平时写代码的时候因为也主要是用<code>Linux</code>系统，对<code>ls</code>和<code>rm</code>这种指令已经敲出肌肉记忆了。<code>Powershell</code>里面对这些指令做了兼容，因此用的时候没有什么额外的感觉，但是切换到<code>cmd</code>的时候就会发现这些指令都不一样了，<code>dir</code>和<code>del</code>一类的指令用的很不顺手。这个时候就有两种解决方法。一种方法算是曲线救国，通过调用<code>git-bash</code>里面提供的工具来实现类似原生<code>Linux</code>的指令，这也是比较推荐的一种方式。</p><h4 id="配置git可执行文件的目录"><a class="markdownIt-Anchor" href="#配置git可执行文件的目录"></a> 配置Git可执行文件的目录</h4><p>在<code>Windows</code>中安装好了<code>Git</code>之后，往往都会有一个<code>git-bash</code>，而我们则可以通过<code>git-bash</code>来实现一些本来在<code>Linux</code>才能执行的指令。而之所以能达到这种效果，是因为<code>Git</code>在安装好了以后在安装目录下有一个<code>/usr/bin</code>的文件夹，里面已经预先放好了可以使用的类似<code>Linux</code>中的一些基本指令，诸如<code>ls</code>和<code>cat</code>这种常用工具都已经有了。因此我们只需要在系统的环境变量中，将<code>&lt;Git的安装路径&gt;\usr\bin</code>添加到<code>PATH</code>中即可。</p><p>比如我是使用<code>scoop</code>安装了<code>git</code>，因此我的<code>git</code>安装路径如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\<span class="hljs-title">Halc</span>\<span class="hljs-title">scoop</span>\<span class="hljs-title">apps</span>\<span class="hljs-title">git</span>\<span class="hljs-title">current</span>\<span class="hljs-title">usr</span>\<span class="hljs-title">bin</span></span><br></code></pre></td></tr></table></figure><p>然后我就只需要在环境变量中把这个路径添加到<code>PATH</code>中，我就可以使用我需要的基础工具了：</p><img src="https://lsky.halc.top/UO7PvD.png" alt="修改环境变量" style="zoom:50%;" /><h4 id="使用cmd脚本预先配置好alias"><a class="markdownIt-Anchor" href="#使用cmd脚本预先配置好alias"></a> 使用<code>cmd</code>脚本预先配置好alias</h4><p>还有一种方式是创建<code>alias</code>，以替代原生<code>cmd</code>的一些指令。这种方法是我最先使用的方法，后面发现了<code>git-bash</code>中的工具是需要额外配置环境变量以后就没有使用这种方法了。</p><p>在<code>Windows</code>上创建<code>alias</code>的方法是使用<code>doskey</code>来执行创建，<code>clink</code>则支持在启动的时候自动执行一个<code>cmd</code>脚本，来实现<code>doskey</code>的读入。为此<code>clink</code>默认会从以下路径来寻找<code>clink_start.cmd</code>文件，用以初始化<code>cmd</code>控制台</p><ul><li>Windows XP: <code>C:\Documents and Settings\&lt;username&gt;\Local Settings\Application Data\clink</code></li><li>Windows Vista以及更高的版本：<code>C:\Users\&lt;username&gt;\AppData\Local\clink</code></li></ul><blockquote><p>如果需要修改clink_start.cmd的位置，可以参考这部分文档：<a href="https://chrisant996.github.io/clink/clink.html#filelocations">File Locations</a></p></blockquote><p>在这里我的操作系统目前是<code>Windows 10</code>，因此我只需要在<code>C:\Users\&lt;username&gt;\AppData\Local\clink</code>目录下创建<code>clink_start.cmd</code>文件，并写入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs batch">@echo off<br>doskey code=code-insiders $1<br>doskey rm=del<br>doskey cp=copy<br>doskey mv=move<br>doskey of=explorer.exe .<br></code></pre></td></tr></table></figure><p>然后保存以后，就会在下一次启动cmd之前执行这些<code>doskey</code>指令，来实现<code>alias</code>的效果了。</p><h3 id="使用cmd作为windows-terminal的默认应用"><a class="markdownIt-Anchor" href="#使用cmd作为windows-terminal的默认应用"></a> 使用cmd作为Windows Terminal的默认应用</h3><p>最后的最后，只需要在<code>Windows Terminal</code>里面设置<code>cmd</code>为默认的应用，就可以实现每次启动<code>wt</code>的时候，都是秒开<code>cmd</code>的效果了，再也不用每次都等<code>powershell</code>启动才能输入指令了。</p><img src="https://lsky.halc.top/E7bAo0.png" alt="修改Windows Terminal默认配置文件" style="zoom: 50%;" />]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab6 计算机网络：路由转发</title>
    <link href="/p/195b5fa9.html"/>
    <url>/p/195b5fa9.html</url>
    
    <content type="html"><![CDATA[<h2 id="路由转发"><a class="markdownIt-Anchor" href="#路由转发"></a> 路由转发</h2><p>这个实验就是最后一个需要写代码的实验了。主要需要解决的问题是一个IP数据包传入之后，如何通过已有的路由表确定下一跳的IP地址</p><p>这个实验中主要的问题点就是CIDR的匹配。解决这个问题，我们只需要先将CIDR转为子网掩码，也就是以0为基数，左移(32 - 前缀)位，最后得到的也是子网掩码的值。但是这里有一个问题就是，当mask是uint32_t的时候，如果前缀的长度为0，那么子网掩码会变成255.255.255.255，但是实际上应该是0，因此我们需要对前缀是否为0进行判断。</p><p>在判断完毕之后，只需要将网关的IP地址和子网掩码按位与运算，然后将目标IP地址也和子网掩码按位与运算，如果最后的结果相同，那么就说明子网匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> path = _route_table.<span class="hljs-built_in">end</span>();<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;dst_ip = dgram.<span class="hljs-built_in">header</span>().dst;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry = _route_table.<span class="hljs-built_in">begin</span>(); entry != _route_table.<span class="hljs-built_in">end</span>(); entry++) &#123;<br>    <span class="hljs-comment">// CIDR的子网位数是多少，相当于就是在0的基础上补多少个1，但是当prefix_length == 0的时候，</span><br>    <span class="hljs-comment">// 由于位运算的特性，子网掩码会全部变成1，也就相当于是/32的情况。因此当检测到子网掩码是0的时候要直接跳过</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> &amp;mask = entry-&gt;prefix_length ? (~<span class="hljs-number">0U</span>) &lt;&lt; (<span class="hljs-number">32</span> - entry-&gt;prefix_length) : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> network_address = entry-&gt;route_prefix &amp; mask;<br>    <span class="hljs-keyword">if</span> ((dst_ip &amp; mask) == network_address) &#123;<br>        path = entry;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有匹配到对应的路由规则，或者这个数据包已经经过了太多次转发都没有找到目的地，那么就将这个数据包丢弃掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查是否存在对应的路由规则，或者TTL可否生存，如果不符合则丢弃</span><br><span class="hljs-keyword">if</span> (path == _route_table.<span class="hljs-built_in">end</span>() || dgram.<span class="hljs-built_in">header</span>().ttl-- &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有丢弃的话，那么就只需要按照正确的接口将数据包发送出去就行，如果没有下一跳的IP地址，说明数据包已经到达了对应的目的地，只需要直接发送给目标IP即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将数据包发送给正确的接口</span><br>AsyncNetworkInterface &amp;interface = _interfaces[path-&gt;interface_num];<br><span class="hljs-keyword">if</span> (path-&gt;next_hop.<span class="hljs-built_in">has_value</span>()) &#123;<br>    interface.<span class="hljs-built_in">send_datagram</span>(dgram, path-&gt;next_hop.<span class="hljs-built_in">value</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    interface.<span class="hljs-built_in">send_datagram</span>(dgram, Address::<span class="hljs-built_in">from_ipv4_numeric</span>(dgram.<span class="hljs-built_in">header</span>().dst));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>终于也是写完了Lab0-6的所有博客总结😭，Lab7的部分不需要写代码，只需要直接运行程序聊天就行，就不写博客总结了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab5 计算机网络：Network Interface的功能</title>
    <link href="/p/db490294.html"/>
    <url>/p/db490294.html</url>
    
    <content type="html"><![CDATA[<h2 id="network-interface"><a class="markdownIt-Anchor" href="#network-interface"></a> Network Interface</h2><p>在通过TCP协议将数据包进行封装准备好以后，就需要“快递公司”来对这些数据包进行分发了。这个过程可以划分为两个部分，一个是数据包在中转转发的过程中需要经过的“中转”设备有哪些，其次就是如何选择“中转”的线路。</p><p>在网络接口的部分，主要实现的逻辑是作为发送的某一个节点，在知道了下一个中转站的IP地址以后，如何将数据包进行交付。</p><h3 id="需要实现的逻辑"><a class="markdownIt-Anchor" href="#需要实现的逻辑"></a> 需要实现的逻辑</h3><p>首先对目前的知识进行一个梳理。首先在前面四个Lab里面，主要完成的是TCP数据包从一串简单的字符串，到最后封装成一个完整的，可以用于建立连接沟通的TCP数据包。TCP数据包本身并不关心数据包是如何从源IP到目标IP的，这一部分的主要实现是由网络层的IP路由和数据链路层进行沟通。</p><p>在数据链路层中，我们假设已经通过网络层的路由知道了下一条的IP地址，但是要知道一个网口今天可以是<code>192.168.1.1</code>，明天就可以是<code>10.0.0.1</code>，因此我们只知道IP地址是不足以让我们从硬件层面将数据包进行中转发送的，我们还需要针对每一个特定网口本身的硬件地址，也就是MAC地址，来硬件和硬件之间可以正确的发送数据。</p><p>由于硬件地址和IP地址的映射关系有可能是动态的，而每次发送数据都向所有设备广播询问一次MAC和IP的映射关系的话在交流频繁的网络情况下资源利用率十分低下，因此我们也需要在中转设备中动态维护一个缓存用的映射表，同时为这个映射表中每一个条目设定对应的<code>TTL</code>来保证数据的实时性，在超过一定时间以后就删除该缓存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! 构造Arp条目</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArpEntry</span> &#123;<br>    <span class="hljs-type">uint32_t</span> raw_ip_addr;<br>    EthernetAddress eth_addr;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> ArpEntry &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> raw_ip_addr &lt; rhs.raw_ip_addr; &#125;<br>&#125;;<br><br><span class="hljs-comment">//! 记录最大的ttl时间</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> arp_max_ttl = <span class="hljs-number">30000</span>;<br><br><span class="hljs-comment">//! 用于记录arp表</span><br>std::map&lt;ArpEntry, <span class="hljs-type">size_t</span>&gt; _arp_table&#123;&#125;;<br></code></pre></td></tr></table></figure><p>而获取IP和MAC地址对应关系的这个步骤则是由ARP协议实现，在硬件自己不知道要发送的下一个网口的MAC地址的时候，他就会给所有的网口广播ARP，正确的设备识别到了这个ARP是发送给自己的以后就返回自己的MAC地址，如果不是发送给自己的则丢弃不处理。同时和TCP中的超时重传一样，ARP探针自己也有可能会因为硬件链路的问题而导致对方没有收到自己的报文，所以也需要有一个超时重传的逻辑，来让自己尽可能的收到对方的回复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! 构造Arp条目</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArpEntry</span> &#123;<br>    <span class="hljs-type">uint32_t</span> raw_ip_addr;<br>    EthernetAddress eth_addr;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> ArpEntry &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> raw_ip_addr &lt; rhs.raw_ip_addr; &#125;<br>&#125;;<br><br><span class="hljs-comment">//! 记录最大的探针时间</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> arp_probe_ttl = <span class="hljs-number">5000</span>;<br><br><span class="hljs-comment">//! 用于记录探针表</span><br>std::map&lt;ArpProbe, <span class="hljs-type">size_t</span>&gt; _probe_table&#123;&#125;;<br></code></pre></td></tr></table></figure><p>在有了以上两个大体部分以后，我们就只需要实现</p><ul><li>发送(IPV4/ARP)报文</li><li>接受(IPV4/ARP)报文</li><li>超时重传探针，以及管理ARP映射的TTL</li></ul><p>两个部分即可。</p><h3 id="实现细节"><a class="markdownIt-Anchor" href="#实现细节"></a> 实现细节</h3><h4 id="发送报文"><a class="markdownIt-Anchor" href="#发送报文"></a> 发送报文</h4><p>在发送报文之前，我们首先需要将IP地址转换为uint_32，以用于报文的封装，然后检查这个IP地址我们是否已经缓存了它对应的MAC地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> next_hop_ip = next_hop.<span class="hljs-built_in">ipv4_numeric</span>();<br>optional&lt;EthernetAddress&gt; next_eth;<br><br><span class="hljs-comment">// 检查next_hop的IP地址是否在ARP里面有</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;entry : _arp_table) &#123;<br>    <span class="hljs-keyword">if</span> (entry.first.raw_ip_addr == next_hop_ip) &#123;<br>        next_eth = entry.first.eth_addr;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个IP地址对应的MAC地址我们已经缓存了，那么就只需要将这个IP报文封装成网络帧进行发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果在ARP里面有则直接发送并短路</span><br><span class="hljs-keyword">if</span> (next_eth.<span class="hljs-built_in">has_value</span>()) &#123;<br>    EthernetFrame eth_frame;<br>    eth_frame.<span class="hljs-built_in">header</span>() = &#123;next_eth.<span class="hljs-built_in">value</span>(), _ethernet_address, EthernetHeader::TYPE_IPv4&#125;;<br>    eth_frame.<span class="hljs-built_in">payload</span>() = dgram.<span class="hljs-built_in">serialize</span>();<br>    _frames_out.<span class="hljs-built_in">push</span>(eth_frame);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个IP地址在我们维护的ARP映射表中并不存在对应的映射关系，那么我们首先要判断我们是否就这个IP发送过ARP探针，如果发送过探针了那么我们也没必要再发送一次，只要等待之前的探针让对方返回正确的MAC地址给我们即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ARP内没有，先判断之前是否已经发送过探针，如果发送过就不发送了</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;probe : _probe_table) &#123;<br>    <span class="hljs-keyword">if</span> (probe.first.raw_ip_addr == next_hop_ip) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有发送的话，那么我们就需要封装一个ARP探针，用于检测目标IP对应的MAC地址，探针目标的IP地址就是IP数据包下一跳的IP，MAC地址则是广播地址（在该实验中直接将目标MAC设置为空即可）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果没发送就发送，并且将这个探针加入探针表</span><br>ARPMessage arp_probe;<br>arp_probe.opcode = ARPMessage::OPCODE_REQUEST;<br>arp_probe.sender_ethernet_address = _ethernet_address;<br>arp_probe.sender_ip_address = _ip_address.<span class="hljs-built_in">ipv4_numeric</span>();<br>arp_probe.target_ethernet_address = &#123;&#125;;<br>arp_probe.target_ip_address = next_hop_ip;<br>EthernetFrame probe_frame;<br>probe_frame.<span class="hljs-built_in">header</span>() = &#123;ETHERNET_BROADCAST, _ethernet_address, EthernetHeader::TYPE_ARP&#125;;<br>probe_frame.<span class="hljs-built_in">payload</span>() = arp_probe.<span class="hljs-built_in">serialize</span>();<br>_frames_out.<span class="hljs-built_in">push</span>(probe_frame);<br></code></pre></td></tr></table></figure><p>同时由于探针有超时重传的机制，因此对于这个新发送的报文，我们也需要将其加入缓存表中并设定TTL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入缓存表</span><br>ArpProbe _arp = &#123;next_hop_ip, dgram&#125;;<br>_probe_table[_arp] = arp_probe_ttl;<br></code></pre></td></tr></table></figure><p>所有的代码</p><h4 id="接受报文"><a class="markdownIt-Anchor" href="#接受报文"></a> 接受报文</h4><p>在接受报文的部分，我们无非会收到两种报文，一种是包含IP数据的报文，一种是对方给我们发过来的ARP报文</p><p>对于这两种报文，首先我们判断它是不是要发送给我们的或是否是一个广播的网络帧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 丢弃目标MAC地址不是我自己的数据帧</span><br><span class="hljs-keyword">if</span> (frame.<span class="hljs-built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="hljs-built_in">header</span>().dst != ETHERNET_BROADCAST) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是一个确定源MAC和目标MAC的IP数据包，那么我们只需要接受这个数据包然后返回对应的数据即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接受到IP数据段的时候（代表对方和自己都有了互相的ARP信息，不需要对ARP表进行操作），对这个数据段进行处理</span><br><span class="hljs-keyword">if</span> (frame.<span class="hljs-built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;<br>    InternetDatagram datagram;<br>    datagram.<span class="hljs-built_in">parse</span>(frame.<span class="hljs-built_in">payload</span>());<br>    <span class="hljs-keyword">return</span> datagram;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果这是一个ARP探针，我们首先对其进行分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接受到的是一个ARP包，先将这个包的内容序列化，并将其中包含的ARP信息尝试更新到自己的ARP表中</span><br>ARPMessage arp_msg;<br>arp_msg.<span class="hljs-built_in">parse</span>(frame.<span class="hljs-built_in">payload</span>());<br>ArpEntry src = &#123;arp_msg.sender_ip_address, arp_msg.sender_ethernet_address&#125;,<br>            dst = &#123;arp_msg.target_ip_address, arp_msg.target_ethernet_address&#125;;<br><br>_update_arp_table(&#123;src, dst&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>其中_update_arp_table用于更新arp表，具体代码如下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! 更新ARP条目</span><br><span class="hljs-type">void</span> NetworkInterface::_update_arp_table(initializer_list&lt;ArpEntry&gt; arp_entry) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;entry : arp_entry) &#123;<br>        _arp_table[entry] = arp_max_ttl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在解析了网络帧之后，我们大致可以得到以下三种分类</p><h5 id="广播报文请求某个ip对应的mac地址但这个ip不是我们的"><a class="markdownIt-Anchor" href="#广播报文请求某个ip对应的mac地址但这个ip不是我们的"></a> 广播报文，请求某个IP对应的MAC地址，但这个IP不是我们的</h5><p>丢弃过滤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 过滤掉不是发给自己的IP地址的包</span><br><span class="hljs-keyword">if</span> (dst.raw_ip_addr != _ip_address.<span class="hljs-built_in">ipv4_numeric</span>()) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广播报文请求某个ip对应的mac地址但这个ip是我们的"><a class="markdownIt-Anchor" href="#广播报文请求某个ip对应的mac地址但这个ip是我们的"></a> 广播报文，请求某个IP对应的MAC地址，但这个IP是我们的</h5><p>返回我们的MAC地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接受到ARP请求的时候，返回一个包含自己信息的ARP响应报文，同时利用这个frame更新自己的ARP表</span><br><span class="hljs-keyword">if</span> (arp_msg.opcode == ARPMessage::OPCODE_REQUEST) &#123;<br>    ARPMessage reply;<br>    reply.opcode = ARPMessage::OPCODE_REPLY;<br>    reply.sender_ip_address = _ip_address.<span class="hljs-built_in">ipv4_numeric</span>();<br>    reply.sender_ethernet_address = _ethernet_address;<br>    reply.target_ip_address = src.raw_ip_addr;<br>    reply.target_ethernet_address = src.eth_addr;<br><br>    EthernetFrame reply_frame;<br>    reply_frame.<span class="hljs-built_in">header</span>() = &#123;src.eth_addr, _ethernet_address, EthernetHeader::TYPE_ARP&#125;;<br>    reply_frame.<span class="hljs-built_in">payload</span>() = reply.<span class="hljs-built_in">serialize</span>();<br>    _frames_out.<span class="hljs-built_in">push</span>(reply_frame);<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="我们发出的arp探针得到了别人的回复知道了别人的mac地址"><a class="markdownIt-Anchor" href="#我们发出的arp探针得到了别人的回复知道了别人的mac地址"></a> 我们发出的ARP探针得到了别人的回复，知道了别人的MAC地址</h5><p>更新自己的ARP映射表,同时检查是否有对应目标MAC地址的报文等待发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 收到别人传送回来的ARP的时候，如果缓存中有等待的对应条目，则删除，并发送对应的数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry = _probe_table.<span class="hljs-built_in">begin</span>(); entry != _probe_table.<span class="hljs-built_in">end</span>();) &#123;<br>    <span class="hljs-keyword">if</span> (entry-&gt;first.raw_ip_addr == src.raw_ip_addr) &#123;<br>        <span class="hljs-built_in">send_datagram</span>(entry-&gt;first.datagram, Address::<span class="hljs-built_in">from_ipv4_numeric</span>(entry-&gt;first.raw_ip_addr));<br>        entry = _probe_table.<span class="hljs-built_in">erase</span>(entry);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        entry++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超时处理"><a class="markdownIt-Anchor" href="#超时处理"></a> 超时处理</h4><p>在这里我们只需要做两件事</p><ul><li>删除超时的ARP条目</li><li>重新发送超时的探针</li></ul><p>对于正常的条目和探针，我们只需要让其TTL减少即可，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NetworkInterface::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-comment">// 将检测是否有超时的ARP条目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry = _arp_table.<span class="hljs-built_in">begin</span>(); entry != _arp_table.<span class="hljs-built_in">end</span>();) &#123;<br>        <span class="hljs-keyword">if</span> (entry-&gt;second &lt; ms_since_last_tick) &#123;<br>            <span class="hljs-comment">// 删除多余的ARP条目</span><br>            entry = _arp_table.<span class="hljs-built_in">erase</span>(entry);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            entry-&gt;second -= ms_since_last_tick;<br>            entry++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检测是否有超时的探针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> entry = _probe_table.<span class="hljs-built_in">begin</span>(); entry != _probe_table.<span class="hljs-built_in">end</span>(); entry++) &#123;<br>        <span class="hljs-keyword">if</span> (entry-&gt;second &lt; ms_since_last_tick) &#123;<br>            <span class="hljs-comment">// 重新发送超时的探针</span><br>            ARPMessage re_probe_arp;<br>            re_probe_arp.opcode = ARPMessage::OPCODE_REQUEST;<br>            re_probe_arp.sender_ip_address = _ip_address.<span class="hljs-built_in">ipv4_numeric</span>();<br>            re_probe_arp.sender_ethernet_address = _ethernet_address;<br>            re_probe_arp.target_ip_address = entry-&gt;first.raw_ip_addr;<br>            re_probe_arp.target_ethernet_address = &#123;&#125;;<br><br>            EthernetFrame re_probe_frame;<br>            re_probe_frame.<span class="hljs-built_in">header</span>() = &#123;ETHERNET_BROADCAST, _ethernet_address, EthernetHeader::TYPE_ARP&#125;;<br>            re_probe_frame.<span class="hljs-built_in">payload</span>() = re_probe_arp.<span class="hljs-built_in">serialize</span>();<br>            _frames_out.<span class="hljs-built_in">push</span>(re_probe_frame);<br><br>            <span class="hljs-comment">// 重置探针条目对应的时间</span><br>            entry-&gt;second = arp_probe_ttl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            entry-&gt;second -= ms_since_last_tick;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>这个实验主要实现的逻辑都是数据链路层的，和之前几个Lab没有直接的关系。不过值得一提的就是在Lab4测试的时候运行的<code>TUN</code>和<code>TAP</code>很有意思。这两个词之前好奇还是在使用<code>Clash</code>的时候既可以是<code>TUN</code>也可以是<code>TAP</code>模式，而且通常来说<code>TUN</code>模式的性能要比<code>TAP</code>要好。当时还不知道为什么，在写完这个实验以后搜了一些资料，目前浅显的理解大致认为是<code>TAP</code>的网络代理模拟是有处理到数据链路层的，也就是MAC地址也进行了模拟，而<code>TUN</code>则只是模拟到了IP层，并没有自己的MAC地址，因此损耗也要少一些。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab4 计算机网络：TCP Connection的实现</title>
    <link href="/p/10e77bc5.html"/>
    <url>/p/10e77bc5.html</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-connection"><a class="markdownIt-Anchor" href="#tcp-connection"></a> TCP Connection</h2><p>TCP Connection的部分本身并不难，这个实验的主要核心是学习使用<code>tshark</code>或<code>wireshark</code>一类的工具对TCP的网络状况进行分析，找出正确或错误的数据包。</p><h3 id="需要实现的逻辑"><a class="markdownIt-Anchor" href="#需要实现的逻辑"></a> 需要实现的逻辑</h3><p>在这个实验中我们需要将前面写的<code>TCP Sender</code>和<code>TCP Receiver</code>两个部分的逻辑进行合并，使得两者之间可以进行数据的传输。</p><p>除了几个可以直接调用前面实验函数的函数以外，我们主要需要完成的我认为是收到某个报文以后的处理函数<code>segment_received(const TCPSegment &amp;seg)</code>和时间函数<code>tick()</code>。</p><h3 id="实现细节"><a class="markdownIt-Anchor" href="#实现细节"></a> 实现细节</h3><h4 id="接受报文"><a class="markdownIt-Anchor" href="#接受报文"></a> 接受报文</h4><p>对于接受报文这个函数，首先通过对实验报告的分析，我们可以知道我们主要要做的事情可以分为以下三个大逻辑：</p><h5 id="对报文本身合法性的分析"><a class="markdownIt-Anchor" href="#对报文本身合法性的分析"></a> 对报文本身合法性的分析</h5><ul><li>记录收到这个报文的时间，无论对错</li><li>检查这个报文是否是带RST标志的报文，如果是的话则直接断开连接</li><li>如果是在LISTEN状态的时候接受到这个报文的，则要判断对方是否连接</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 首先无论如何，刷新收到报文的时间</span><br>_time_since_last_segment_received = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 然后先检查这个报文是否出错，如果出错则直接返回</span><br><span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().rst) &#123;<br>    _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>    _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>    _is_active = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 如果TCP连接处于LISTEN状态，只接受SYN报文，并且返回一个SYN + ACK的报文</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().syn) &#123;<br>        _sender.<span class="hljs-built_in">fill_window</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对报文进行处理"><a class="markdownIt-Anchor" href="#对报文进行处理"></a> 对报文进行处理</h5><p>接受这个报文，如果带有ACK信息则更新对方已经确认了的<code>ackno</code>和对方当前的<code>window_size</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接受这个报文</span><br>_receiver.<span class="hljs-built_in">segment_received</span>(seg);<br><br><span class="hljs-comment">// 对ACK报文进行确认更新，用于下一次更新的确认</span><br><span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().ack) &#123;<br>    _sender.<span class="hljs-built_in">ack_received</span>(seg.<span class="hljs-built_in">header</span>().ackno, seg.<span class="hljs-built_in">header</span>().win);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="正确的处理连接的关闭"><a class="markdownIt-Anchor" href="#正确的处理连接的关闭"></a> 正确的处理连接的关闭</h5><p>这部分是我认为<code>Lab4</code>里面在理解上较难的部分。其中，TCP的断开分为三种不同的情况：</p><ol><li>由于RST标志导致的强制退出（unclean shutdown）</li><li>正常的通讯结束而导致的关闭（clean shutdown）</li></ol><p>但是对于第二种情况，我们可以进一步分为两种情况：</p><p>首先是最简单的四次挥手报文：</p><ol><li><p><code>Client</code>发送完毕数据，告诉<code>Server</code>我结束(FIN)了<br /><code>Client</code>客户端在给<code>Server</code>发送完毕了所有数据以后，主动发送<code>FIN</code>数据包，表示自己的数据已经发送完毕了。然后<code>Server</code>在收到<code>Client</code>的<code>FIN</code>报文并处理完毕以后则会返回一个<code>FIN ACK</code>报文，来告诉<code>Client</code>他发过来的数据已经在服务端被处理完成了。</p></li><li><p><code>Server</code>也发送完毕了数据，告诉<code>Client</code>我结束(FIN)了<br />这个时候<code>Server</code>也会给<code>Client</code>发送一个<code>FIN</code>的报文，同样等待<code>Client</code>那边确认，如果<code>Client</code>发送了确认报文来确认这个ACK，则代表客户端那边也处理完了，这个时候按理来说首先提出数据发送完毕的<code>Client</code>就可以断开链接了。</p></li></ol><h6 id="client主动关闭"><a class="markdownIt-Anchor" href="#client主动关闭"></a> Client：主动关闭</h6><p><strong>但是，服务端有可能收不到</strong>这最后一个ACK确认报文，从而导致自己一直在等待客户端向自己发送<code>ACK</code>确认报文。</p><p>为了避免这种情况，最简单的处理方法就是让<code>Client</code>给<code>Server</code>发送了<code>FIN ACK</code>报文以后不要急着断开连接，而是设置一个计时器，等待看看<code>Server</code>会不会重传<code>FIN</code>报文。</p><p>如果重传了<code>FIN</code>则代表<code>Server</code>并没有收到先前发送的<code>FIN ACK</code>，这个时候<code>Client</code>就需要重新发送一个<code>ACK</code>回去，告知<code>Server</code>可以断开连接了。</p><p>如果超过了计时器的时间，<code>Client</code>也没有收到<code>Server</code>的重传报文，那么我们就假设<code>Server</code>已经收到了<code>FIN ACK</code>，并且已经关闭了他那边的连接，这个时候<code>Client</code>就可以断开连接了。而这段计时器的等待时间，就是实验中的<code>linger_time = 10 *_cfg.rt_timeout</code>，这个时间往往是比<code>Server</code>超时重传的时间大很多的，也就留给了<code>Server</code>足够多的时间来重传<code>FIN</code>报文。</p><h6 id="server被动关闭"><a class="markdownIt-Anchor" href="#server被动关闭"></a> Server：被动关闭</h6><p>服务端这边就很简单了，在发送完自己的<code>FIN</code>之后，只需要正常等待<code>Client</code>的<code>ACK</code>确认报文，如果没有等到则重传<code>FIN</code>，如果等到了则直接断开连接。</p><h6 id="连接关闭的代码实现"><a class="markdownIt-Anchor" href="#连接关闭的代码实现"></a> 连接关闭的代码实现</h6><p>知道了上面的区分以后，我们实现起来就很简单了，只需要通过添加一个变量<code>_linger_after_streams_finish</code>来判断到底是对方先结束还是自己先结束。如果是对方先结束，则我们不需要等待<code>linger_time</code>，在后面收到了<code>FIN</code>报文以后直接断开连接即可。否则则需要在后面<code>tick()</code>函数的部分添加超时断开连接的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接收到正确的EOF报文，代表对方发送过来的数据流已经结束了，但是自己还有数据要发送</span><br><span class="hljs-comment">// 因此需要等待自己的数据流发送完毕后才能关闭连接</span><br><span class="hljs-keyword">if</span> (_receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">eof</span>() &amp;&amp; <span class="hljs-keyword">not</span> _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>()) &#123;<br>    _linger_after_streams_finish = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// _linger_after_streams_finish是false说明对方发送给我们的数据流已经全部被接受了</span><br><span class="hljs-comment">// 此时有_sender的eof和bytes_in_flight都为0，说明自己的数据流也已经全部发送完毕</span><br><span class="hljs-comment">// 因此可以关闭连接了</span><br><span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>() &amp;&amp; <span class="hljs-built_in">bytes_in_flight</span>() == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">not</span> _linger_after_streams_finish) &#123;<br>    _is_active = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="发送确认报文"><a class="markdownIt-Anchor" href="#发送确认报文"></a> 发送确认报文</h5><p>这部分逻辑就很简单了，如果在接受了对方传来的有序列号消耗数据包以后，我们并没有数据要传输（即无法告知对方我们接受到了数据），那么我们就需要单独传输一个ACK数据包给对方，告知我们已经接收到了对方的数据。（如果对方发送给我们的是一个ACK数据包，我们则不需要回复，也就是收到了占用序号为零的包）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">empty</span>() &amp;&amp;<br>    (seg.<span class="hljs-built_in">length_in_sequence_space</span>() || seg.<span class="hljs-built_in">header</span>().seqno != _receiver.<span class="hljs-built_in">ackno</span>())) &#123;<br>    _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>seg.header().seqno != _receiver.ackno()</code>代表的是一种特殊情况，在<code>TCP</code>连接中，有的时候为了确认当前连接是否依旧有效，对方有可能会随机发送一个错误的序列号给我们，这个时候我们就需要回复一个ACK报文给对方，以此告知对方这个连接依旧是有效的，同时也可以让对方更新我们的窗口大小。</p><h5 id="接受报文的代码实现"><a class="markdownIt-Anchor" href="#接受报文的代码实现"></a> 接受报文的代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先无论如何，刷新收到报文的时间</span><br>    _time_since_last_segment_received = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 然后先检查这个报文是否出错，如果出错则直接返回</span><br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().rst) &#123;<br>        _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">set_error</span>();<br>        _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">set_error</span>();<br>        _is_active = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果TCP连接处于LISTEN状态，只接受SYN报文，并且返回一个SYN + ACK的报文</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().syn) &#123;<br>            _sender.<span class="hljs-built_in">fill_window</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 接受这个报文</span><br>    _receiver.<span class="hljs-built_in">segment_received</span>(seg);<br><br>    <span class="hljs-comment">// 对ACK报文进行确认更新，用于下一次更新的确认</span><br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().ack) &#123;<br>        _sender.<span class="hljs-built_in">ack_received</span>(seg.<span class="hljs-built_in">header</span>().ackno, seg.<span class="hljs-built_in">header</span>().win);<br>    &#125;<br><br>    <span class="hljs-comment">// 接收到正确的EOF报文，代表对方发送过来的数据流已经结束了，但是自己还有数据要发送</span><br>    <span class="hljs-comment">// 因此需要等待自己的数据流发送完毕后才能关闭连接</span><br>    <span class="hljs-keyword">if</span> (_receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">eof</span>() &amp;&amp; <span class="hljs-keyword">not</span> _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>()) &#123;<br>        _linger_after_streams_finish = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// _linger_after_streams_finish是false说明对方发送给我们的数据流已经全部被接受了</span><br>    <span class="hljs-comment">// 此时有_sender的eof和bytes_in_flight都为0，说明自己的数据流也已经全部发送完毕</span><br>    <span class="hljs-comment">// 因此可以关闭连接了</span><br>    <span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>() &amp;&amp; <span class="hljs-built_in">bytes_in_flight</span>() == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">not</span> _linger_after_streams_finish) &#123;<br>        _is_active = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">segments_out</span>().<span class="hljs-built_in">empty</span>() &amp;&amp; (seg.<span class="hljs-built_in">length_in_sequence_space</span>() || seg.<span class="hljs-built_in">header</span>().seqno != _receiver.<span class="hljs-built_in">ackno</span>())) &#123;<br>        _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 填装需要发送的报文</span><br>    _push_out();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间流动"><a class="markdownIt-Anchor" href="#时间流动"></a> 时间流动</h4><p>另外一个需要注意的函数就是<code>tick()</code>函数了。其实这一部分的重要也主要是连带了前面接受报文部分的关闭连接，主要要注意的就是添加一个对<code>linger_time</code>的判断。整个<code>tick()</code>函数的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPConnection::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    _time_since_last_segment_received += ms_since_last_tick;<br>    _sender.<span class="hljs-built_in">tick</span>(ms_since_last_tick);<br>    <span class="hljs-comment">// 如果超时重传次数超过了最大重传次数，那么就直接关闭连接</span><br>    <span class="hljs-keyword">if</span> (_sender.<span class="hljs-built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123;<br>        _send_rst();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 在我方的数据包全部发送并且处理完毕以后，如果接受到了对方传来的EOF报文，并且等待了十倍的RTT时间都没有新的报文传来，则代表连接已经关闭</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">time_since_last_segment_received</span>() &gt;= _linger_time &amp;&amp; _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>() &amp;&amp;<br>        _receiver.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">input_ended</span>()) &#123;<br>        _is_active = <span class="hljs-literal">false</span>;<br>    &#125;<br>    _push_out();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题和难点"><a class="markdownIt-Anchor" href="#问题和难点"></a> 问题和难点</h4><p><code>Lab4</code>实验主要的难点感觉还是在即使跑通了前面大部分的基本测试，也还是有可能因为<code>Lab2</code>和<code>Lab3</code>里面的疏忽，而导致后面模拟真实通讯的时候很容易难以下手。但是在掌握了<code>Wireshark</code>抓包一类的工具用法以后还是很容易发现问题所在并加以纠正的。</p><p>比如我在<code>Lab3</code>中，对于<code>TCPSender</code>在填充窗口大小的时候，一开始并不是设置了一个额外的变量<code>fill_space</code>来控制可以发送的空闲空间的大小，而是直接使用了<code>ack_received</code>方法中收到的最新窗口大小，忽略了<code>bytes_in_flight()</code>也需要考虑在窗口占用里面的问题。在使用<code>Wireshark</code>抓包的时候就明显发现了发送数据包的序号要远超于接收方的确认序号</p><p><img src="https://lsky.halc.top/cZQdDr.png" alt="空闲窗口判断错误" /></p><p>而这个问题也在我通过修改<code>Lab3</code>对应空闲窗口大小的逻辑之后得到了解决。</p><p>我还遇到过的第二个问题就是在小窗口的情况下，没有正确处理链接的关闭。在通过<code>Wireshark</code>抓包以后可以看到</p><p><img src="https://lsky.halc.top/zvSqG9.png" alt="没有正确处理关闭" /></p><p>在发送方还没有给接收方发送完所有数据的时候，接收方就提前终止了自己的连接，这个问题主要出在<code>tick()</code>函数里面关于<code>linger_time</code>的逻辑错误，我并没有等到接收方接受到EOF就直接关闭了链接。错误代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">time_since_last_segment_received</span>() &gt;= _linger_time &amp;&amp; _sender.<span class="hljs-built_in">stream_in</span>().<span class="hljs-built_in">eof</span>()) &#123;<br>    _is_active = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的代码如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">if (time_since_last_segment_received() &gt;= _linger_time &amp;&amp; _sender.stream_in().eof()<br><span class="hljs-addition">+   &amp;&amp; _receiver.stream_out().input_ended()) &#123;</span><br>    _is_active = false;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个<code>Lab4</code>的代码可以在<code>Github</code>的仓库查看：</p><p><a href="https://github.com/HalcyonAzure/CS144/blob/master/libsponge/tcp_connection.cc">tcp_connection.cc</a><br /><a href="https://github.com/HalcyonAzure/CS144/blob/master/libsponge/tcp_connection.hh">tcp_connection.hh</a></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Yadm管理Linux配置文件</title>
    <link href="/p/4457ea2b.html"/>
    <url>/p/4457ea2b.html</url>
    
    <content type="html"><![CDATA[<p>今年暑假看<code>Missing-course</code>的时候开始意识到备份<code>Linux</code>配置文件的重要性，以后即使切换机器也可以很容易的恢复自己喜欢的编程环境。在简单搜索了几个方式以后，决定使用<code>yadm</code>作为管理工具，并且写了一个模板，便于分享和使用。</p><ul><li><a href="https://github.com/HalcyonAzure/Yadm_Dotfiles">Yadm Dotfiles</a></li></ul><h2 id="使用说明"><a class="markdownIt-Anchor" href="#使用说明"></a> 使用说明</h2><p>该仓库的主要用途为使用<code>yadm</code>作为管理工具，通过<code>Github</code>来同步自己的<code>Dotfiles</code></p><ol><li><p>先在自己当前环境下安装<code>yadm</code>，具体安装说明参照<a href="https://yadm.io/docs/install">Installation</a></p></li><li><p>通过<code>Use this template</code>或者下载源码的方式，创建并上传到自己的一个仓库中，最好是<code>Private</code>类型</p></li><li><p>在本身没有经过配置<code>Dotfiles</code>的环境下（或提前备份好自己的<code>Dotfiles</code>）输入以下指令拉取模板到本地进行管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yadm clone https://github.com/&lt;your id&gt;/&lt;your repository&gt; --bootstrap<br></code></pre></td></tr></table></figure></li><li><p>在附带<code>--boostrap</code>的情况下执行完毕上述指令以后将会按默认模板文件使用<code>git</code>来对自己的<code>Dotfiles</code>进行管理</p></li></ol><hr /><h2 id="模板介绍"><a class="markdownIt-Anchor" href="#模板介绍"></a> 模板介绍</h2><h3 id="bootstrap"><a class="markdownIt-Anchor" href="#bootstrap"></a> Bootstrap</h3><p>在<code>clone</code>仓库的时候如果附带了<code>bootstrap</code>将会自动执行以下三件事</p><ul><li>在以 <code>apt/yum/pacman</code> 作为包管理器的情况下安装<code>zsh vim tmux curl wget openssl</code></li><li>安装 <code>oh-my-zsh</code>，并以<code>p10k</code>为主题。安装<code>zsh-autosuggestions</code>,<code>zsh-syntax-highlighting</code>和<code>zsh-proxy</code>三个插件</li><li>切换 <code>zsh</code> 为当前用户的默认终端</li></ul><h3 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h3><h4 id="sshconfig"><a class="markdownIt-Anchor" href="#sshconfig"></a> .ssh/config</h4><ul><li>取消了域名指纹检查，不需要输入yes同意首次链接</li></ul><h4 id="zshrc"><a class="markdownIt-Anchor" href="#zshrc"></a> .zshrc</h4><ul><li>配置了<code>rust</code>国内镜像</li><li>添加了<a href="https://transfer.sh/">transfer</a>用于分享文件（输入<code>transfer /path/to/file</code>即可）</li><li>使用<code>pws</code>作为<code>powershell.exe</code>的<code>alias</code>，便于<code>wsl</code>环境下使用<code>powershell</code></li><li>启用了<code>vi</code>的normal模式，在输入命令的时候按<code>Esc</code>即可</li></ul><h4 id="vimrc"><a class="markdownIt-Anchor" href="#vimrc"></a> .vimrc</h4><ul><li>参考<a href="https://missing-semester-cn.github.io/2020/editors/">missing-semster</a></li><li>为了便于作为<code>wsl</code>环境使用，在<code>Windows Terminal</code>下复制粘贴，关闭了鼠标功能</li></ul><h4 id="cargo"><a class="markdownIt-Anchor" href="#cargo"></a> .cargo</h4><ul><li>配置好了<code>cargo</code>镜像库</li></ul><h3 id="gitconfig"><a class="markdownIt-Anchor" href="#gitconfig"></a> gitconfig</h3><ul><li>配置默认使用<code>~/.gitignore作为全局</code>ignore`文件</li><li>在使用<code>https</code>时的验证交由<code>.git-credentials</code>文件纯文本保存密码（有风险，可加密）</li></ul><h3 id="加密使用"><a class="markdownIt-Anchor" href="#加密使用"></a> 加密使用</h3><p>对于类似<code>.ssh/id_rsa</code>或者<code>.git-credentials</code>文件可以通过<code>yadm</code>自带的<code>encrypt</code>工具进行加密，使用步骤如下</p><ol><li><p>在<code>.config/yadm/encrypt</code>文件内写入需要加密的文件路径，支持正则匹配</p></li><li><p>假设在<code>.ssh/</code>目录下所有文件(例如<code>config, id_rsa</code>)都需要进行加密，则在<code>.config/yadm/encrypt</code>写入<code>.ssh/*</code>后输入以下指令(安装openssl为前提)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yadm encrypt<br></code></pre></td></tr></table></figure><p>则会要求输入一个密码来进行加密</p></li><li><p>加密完则会在<code>.local/share/yadm</code>目录下产生一个<code>archive</code>作为加密打包后的文件，将该文件添加并上传到<code>Github</code></p><blockquote><p>虽然加密文件本身有一定安全性，但为了保险起见还是推荐使用<code>Private</code>仓库来存储自己的<code>Dotfiles</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yadm add ~/.local/share/yadm/archive<br>yadm commit -m &quot;add encrypt archive&quot;<br>yadm push<br></code></pre></td></tr></table></figure><p>原本的文件此时将会依旧本地存在于(例如<code>config, id_rsa</code>)，但不需要上传到<code>Github</code>当中</p></li><li><p>在下次重装系统/更换环境的时候，如果需要通过<code>yadm</code>对环境进行复原并解密加密文件，则只需要输入以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yadm decrypt<br></code></pre></td></tr></table></figure><p>就会将加密打包的文件解密到对应的文件目录，保证一定的安全性</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Yadm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab3 计算机网络：TCP Sender的实现</title>
    <link href="/p/73e1b791.html"/>
    <url>/p/73e1b791.html</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-sender"><a class="markdownIt-Anchor" href="#tcp-sender"></a> TCP Sender</h2><h3 id="需要实现的主要逻辑"><a class="markdownIt-Anchor" href="#需要实现的主要逻辑"></a> 需要实现的主要逻辑</h3><ol><li>追踪<code>Receiver</code>返回的<code>windows_size</code>（可接受的剩余容量）和<code>ackno</code>（已经确认接收的字符位置）</li><li>只要数据来了就直接对数据进行封装并发送，只有在窗口被消耗为零的情况下才停止发送</li><li>将没有被<code>acknowledge</code>的数据包存储起来，在超时的时候进行发送</li></ol><h3 id="实现细节"><a class="markdownIt-Anchor" href="#实现细节"></a> 实现细节</h3><ol><li>对于超时重传的时间判断，使用已经提供的<code>tick()</code>函数，每次调用的时候传入多少时间就消耗了多少时间</li><li>超时重传的默认基准值会以成员变量的形式在<code>TCPSender</code>中进行初始化</li><li>在<code>TCPSegment</code>中有一个<code>_segments_out</code>的成员，只需要向这个<code>queue</code>内<code>push</code>一个<code>TCPSegment</code>就相当于将这个数据段发送了</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><h4 id="额外定义成员"><a class="markdownIt-Anchor" href="#额外定义成员"></a> 额外定义成员</h4><p>对于计时器的部分，为了方便抽象管理，我这里选择直接创建一个类来进行封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPTimer</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> _tick_passed = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录实时的时间戳</span><br>    <span class="hljs-type">size_t</span> _rto_timeout = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录超过多久时间没有收到ACK就重传</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _rto_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重传的次数</span><br><br>    <span class="hljs-type">bool</span> _is_running&#123;<span class="hljs-literal">false</span>&#125;;  <span class="hljs-comment">// 记录计时器是否启动</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重置计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> retx_timeout)</span> </span>&#123;<br>        _rto_count = <span class="hljs-number">0</span>;<br>        _rto_timeout = retx_timeout;<br>        _tick_passed = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 启动计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; _is_running = <span class="hljs-literal">true</span>; &#125;<br><br>    <span class="hljs-comment">// 暂停计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123; _is_running = <span class="hljs-literal">false</span>; &#125;<br><br>    <span class="hljs-comment">// 计时器是否启动</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_running</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_running; &#125;<br><br>    <span class="hljs-comment">// 重传次数</span><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">rto_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _rto_count; &#125;<br><br>    <span class="hljs-comment">// 慢启动</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_start</span><span class="hljs-params">()</span> </span>&#123;<br>        _rto_count++;<br>        _rto_timeout *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新当前时间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123; _tick_passed += ms_since_last_tick; &#125;<br><br>    <span class="hljs-comment">// 检测是否超时</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_timeout</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_running &amp;&amp; _tick_passed &gt;= _rto_timeout; &#125;<br><br>    <span class="hljs-comment">// 重新计时</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">()</span> </span>&#123; _tick_passed = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>private</code>的部分定义则如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 超时重传计时器</span><br>TCPTimer _rto_timer&#123;&#125;;<br><br><span class="hljs-comment">// 记录确认的_ackno</span><br><span class="hljs-type">size_t</span> _ackno = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 记录窗口大小，并标记是否为空窗口</span><br><span class="hljs-type">size_t</span> _window_size = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 缓存队列</span><br>std::queue&lt;TCPSegment&gt; _cache&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="额外定义函数"><a class="markdownIt-Anchor" href="#额外定义函数"></a> 额外定义函数</h4><p>额外定义的函数主要作用为将已经封装好的<code>TCP</code>报文进行发送，如果在发送的时候检测到<code>RTO</code>重传计时器并没有工作，则发送的同时激活重传计时器。同时在发送了报文后对seqno序号进行消耗，移动<code>_next_seqno</code>指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> TCPSender::_send_segment(<span class="hljs-type">const</span> TCPSegment &amp;seg) &#123;<br>    <span class="hljs-comment">// 当前报文需要占用的长度</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> seg_len = seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    _next_seqno += seg_len;<br>    _cache.<span class="hljs-built_in">push</span>(seg);<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    <span class="hljs-comment">// 如果没启动计时器，就启动计时器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> _rto_timer.<span class="hljs-built_in">is_running</span>()) &#123;<br>        _rto_timer.<span class="hljs-built_in">run</span>();<br>        _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window"></a> fill_window()</h4><p>对于需要封装的报文，大致可以分为三类，一类是最开始用于建立连接的<code>SYN</code>报文，一类是携带数据的<code>PAYLOAD</code>报文，最后一类是用于发送结束连接的挥手<code>FIN</code>报文。在该方法中主要的难点就是通过对目前已经确认的<code>ackno</code>和<code>next_seqno</code>等数据来判断当前需要封装的报文具体是哪一类，以及根据还未接收到的数据以及零窗口本身的机制来判断空闲的窗口大小</p><h5 id="fill_space窗口大小"><a class="markdownIt-Anchor" href="#fill_space窗口大小"></a> fill_space窗口大小</h5><p>首先，为了防止出现对方当前空闲窗口已满，而sender就一直啥也不发的情况出现，因此在接受到的窗口大小是0的时候，要将其改为1，来避免零窗口堵塞。同时由于部分数据还在传输的路上，这一部分的数据也需要被减掉，从而得到最后的空闲大小fill_space。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> fill_space = _window_size ? _window_size : <span class="hljs-number">1</span>;<br>fill_space -= <span class="hljs-built_in">bytes_in_flight</span>();<br></code></pre></td></tr></table></figure><h5 id="syn报文"><a class="markdownIt-Anchor" href="#syn报文"></a> SYN报文</h5><p><code>SYN</code>报文的判断很简单，因为发送<code>SYN</code>的话无非是打开连接的建立者A自己，又或者是收到了A发来报文的B返回一个携带<code>ACK</code>的<code>SYN</code>报文进行确认。而对于A和B来说，由于<code>SYN</code>报文都是他们自己发送的第一个报文，因此在封装的过程中，他们的“下一个发送序列号”<code>_next_seqno</code>显而易见的应该为零。大致逻辑代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// _next_seqno == 0 代表还没有开始发送数据，此时需要发送SYN报文</span><br>section.<span class="hljs-built_in">header</span>().syn = (_next_seqno == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h5 id="payload报文"><a class="markdownIt-Anchor" href="#payload报文"></a> PAYLOAD报文</h5><p>对于含有内容的报文，主要的工作就是对<code>payload</code>长度的合理切割，对此只需要在<code>TCPConfig::MAX_PAYLOAD_SIZE</code>和当前剩余``中取最小值并从<code>_stream</code>当中读入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将数据进行封装</span><br><span class="hljs-type">size_t</span> segment_payload_size = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, fill_space);<br>section.<span class="hljs-built_in">payload</span>() = _stream.<span class="hljs-built_in">read</span>(segment_payload_size);<br></code></pre></td></tr></table></figure><h5 id="fin报文"><a class="markdownIt-Anchor" href="#fin报文"></a> FIN报文</h5><p>在<code>_stream</code>发送完毕，并且被我方全部接受了的时候发送一个携带<code>FIN</code>的报文，告知对方我方已经发送完毕。由于<code>FIN</code>本身需要消耗一个序列号，因此发送前需检查当前数据段是否还有一个空位来放FIN</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果要发送FIN的话，窗口内至少还要剩余一个字符(bytes_in_flight的也会占用窗口)</span><br><span class="hljs-keyword">if</span> (_stream.<span class="hljs-built_in">eof</span>() &amp;&amp; fill_space &gt; section.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>    section.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="发送过滤"><a class="markdownIt-Anchor" href="#发送过滤"></a> 发送过滤</h5><p>在标记完了<code>FIN</code>之后，如果这个报文依旧不占用序列号，则说明这个报文不是<code>TCP Sender</code>处理的部分；又或者此时在<code>FIN</code>已经发送的基础上，重复发送了一个<code>FIN</code>，这时多的<code>FIN</code>应该被抛弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空字符报的报文或错误溢出的报文不应该由`TCP Sender`进行发送</span><br><span class="hljs-keyword">if</span> (section.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span> || _next_seqno == _stream.<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><details><summary>最后总的代码如下</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> fill_space = _window_size ? _window_size : <span class="hljs-number">1</span>;<br>    fill_space -= <span class="hljs-built_in">bytes_in_flight</span>();<br>    <span class="hljs-keyword">while</span> (fill_space &gt; <span class="hljs-number">0</span>) &#123;<br>        TCPSegment section;<br><br>        <span class="hljs-comment">// 发送的数据包的序号是将要写入的下一个序号</span><br>        section.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">next_seqno</span>();<br><br>        <span class="hljs-comment">// _next_seqno == 0 代表还没有开始发送数据，此时需要发送SYN报文</span><br>        section.<span class="hljs-built_in">header</span>().syn = (_next_seqno == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 将数据进行封装</span><br>        <span class="hljs-type">size_t</span> segment_payload_size = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, fill_space);<br>        section.<span class="hljs-built_in">payload</span>() = _stream.<span class="hljs-built_in">read</span>(segment_payload_size);<br><br>        <span class="hljs-comment">// 空闲窗口中至少要留有一位序号的位置才能将当前数据包添加FIN(bytes_in_flight的也会占用窗口)</span><br>        <span class="hljs-keyword">if</span> (_stream.<span class="hljs-built_in">eof</span>() &amp;&amp; fill_space &gt; section.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>            section.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果这个报文啥都没有，或者FIN报文已经发送了，就没必要发送新的数据段了</span><br>        <span class="hljs-keyword">if</span> (section.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span> || _next_seqno == _stream.<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        fill_space -= section.<span class="hljs-built_in">length_in_sequence_space</span>();<br><br>        _send_segment(section);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="bytes_in_flight"><a class="markdownIt-Anchor" href="#bytes_in_flight"></a> bytes_in_flight()</h4><p>这个感觉可能是看起来最简单的一个函数了，因为用了<code>_ackno</code>来记录已经确认过的报文，同时<code>_next_seqno</code>又代表的是将要发送的数据流位置，因此只需要将<code>_next_seqno - _ackno</code>返回的就是正在发送中的数据长度了。（最开始想实现的时候还在考虑要不要在每次<code>fill_window</code>和<code>ack_received</code>的时候添加计数器。。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _next_seqno - _ackno; &#125;<br></code></pre></td></tr></table></figure><h4 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received"></a> ack_received()</h4><p>确认报文主要需要的逻辑有以下四个部分：</p><ol><li>只处理有效并且正确的<code>ackno</code>。如果<code>ackno</code>有效，记录<code>ackno</code>和<code>window_size</code>用以<code>fill_window()</code>来进行报文的封装</li><li>记录ack报文中包含的窗口大小</li><li>如果曾经的报文已经确认过，则报文已经送达，将送达的报文从缓冲区中弹出，如果所有的报文都被弹出了，则关闭RTO计时器</li><li>如果接受到了对方这时的窗口又有了空闲大小，则使用<code>fill_window()</code>来填充新的空报文</li></ol><h5 id="对于第一个逻辑"><a class="markdownIt-Anchor" href="#对于第一个逻辑"></a> 对于第一个逻辑</h5><p>对于判断<code>ackno</code>是否是正确的<code>ackno</code>,只需要判断<code>ackno</code>是否处于已经记录的<code>_ackno</code>和<code>_next_seqno</code>之间，如果在这个区间之外，意味着要么是老的<code>ackno</code>，要么是确认了不存在的数据，需要进行短路丢弃，逻辑如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span> abs_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _next_seqno);<br><span class="hljs-comment">// 如果接收到对方发送的确认序号大于自己的下一个序号或者小于自己的已经被确认序号，说明接收到的确认序号是错误的</span><br><span class="hljs-keyword">if</span> (abs_ackno &lt; _ackno || abs_ackno &gt; _next_seqno) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对于第二个逻辑"><a class="markdownIt-Anchor" href="#对于第二个逻辑"></a> 对于第二个逻辑</h5><p>在接受到了窗口大小之后只需要直接将其记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录窗口大小</span><br>_window_size = window_size;<br></code></pre></td></tr></table></figure><h5 id="对于第三-四个逻辑"><a class="markdownIt-Anchor" href="#对于第三-四个逻辑"></a> 对于第三、四个逻辑</h5><p>这部分都是属于对于超时重传的处理，其中主要需要实现的是对缓冲区确认后的报文进行弹出，同时弹出所有报文后取消对<code>RTO</code>的占用，初始化超时重传的等待时间并记录当前的时间。</p><p>其中弹出操作只有在<code>_ackno</code>确认的是第一个报文对应的<code>seqno</code>和<code>length</code>的时候才进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用于判断是否重置计时器</span><br><span class="hljs-type">bool</span> has_reset = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 当缓冲区内的报文已经被ackno确认，则将已经确认的报文进行丢弃</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> _cache.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>       _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno.<span class="hljs-built_in">raw_value</span>() + _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= ackno.<span class="hljs-built_in">raw_value</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> has_reset) &#123;<br>        <span class="hljs-comment">// 有效的确认报文到达，重置计时器</span><br>        _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>        has_reset = <span class="hljs-literal">true</span>;<br>    &#125;<br>    _cache.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-comment">// 所有数据包都被确认了，所以暂停计时器</span><br>    _rto_timer.<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果剩余的窗口还有空间，就填入内容</span><br><span class="hljs-built_in">fill_window</span>();<br></code></pre></td></tr></table></figure><details><summary>最后总的代码如下</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="hljs-comment">//! \param window_size The remote receiver&#x27;s advertised window size</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-type">const</span> WrappingInt32 ackno, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> abs_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _next_seqno);<br>    <span class="hljs-comment">// 如果接收到对方发送的确认序号大于自己的下一个序号或者小于自己的已经被确认序号，说明接收到的确认序号是错误的</span><br>    <span class="hljs-keyword">if</span> (abs_ackno &lt; _ackno || abs_ackno &gt; _next_seqno) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _ackno = abs_ackno;<br><br>    <span class="hljs-comment">// 记录窗口大小</span><br>    _window_size = window_size;<br><br>    <span class="hljs-comment">// 用于判断是否重置计时器</span><br>    <span class="hljs-type">bool</span> has_reset = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 当缓冲区内的报文已经被ackno确认，则将已经确认的报文进行丢弃</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> _cache.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>           _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno.<span class="hljs-built_in">raw_value</span>() + _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= ackno.<span class="hljs-built_in">raw_value</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> has_reset) &#123;<br>            <span class="hljs-comment">// 有效的确认报文到达，重置计时器</span><br>            _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>            has_reset = <span class="hljs-literal">true</span>;<br>        &#125;<br>        _cache.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 所有数据包都被确认了，所以暂停计时器</span><br>        _rto_timer.<span class="hljs-built_in">stop</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果剩余的窗口还有空间，就填入内容</span><br>    <span class="hljs-built_in">fill_window</span>();<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="tick"><a class="markdownIt-Anchor" href="#tick"></a> tick()</h4><p>该函数主要的作用是推动时间流动，并且判断是否触发超时重传，如果触发了超时重传首先将计时器更新到当前时间。然后当对方窗口不繁忙的情况下（window_size非零）触发了重传就把下次重传的等待时间翻倍，并且记录一次重连；如果对方窗口正处于繁忙期（window_size为零），则不翻倍连接时间。然后再将缓冲区内第一个发送的报文进行重新发送。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-comment">// 更新当前时间</span><br>    _rto_timer.<span class="hljs-built_in">update</span>(ms_since_last_tick);<br><br>    <span class="hljs-comment">// 检测是否超时</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">not</span> _rto_timer.<span class="hljs-built_in">is_timeout</span>())) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果上一个收到的报文中，窗口大小不是零，但是依旧超时，说明是网络堵塞，执行慢启动</span><br>    <span class="hljs-keyword">if</span> (_window_size != <span class="hljs-number">0</span>) &#123;<br>        _rto_timer.<span class="hljs-built_in">slow_start</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 重传次数小于最大重传次数，就重传</span><br>    <span class="hljs-keyword">if</span> (_rto_timer.<span class="hljs-built_in">rto_count</span>() &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123;<br>        <span class="hljs-comment">// 发送缓冲区中的第一个报文段</span><br>        _segments_out.<span class="hljs-built_in">push</span>(_cache.<span class="hljs-built_in">front</span>());<br>        _rto_timer.<span class="hljs-built_in">restart</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="consecutive_retransmissions"><a class="markdownIt-Anchor" href="#consecutive_retransmissions"></a> consecutive_retransmissions()</h4><p>这个函数就是直接返回次数的，直接返回<code>_rto_timer.rto_count();</code>的大小即可。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab2 计算机网络：TCP Receiver的实现</title>
    <link href="/p/4e68707.html"/>
    <url>/p/4e68707.html</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-receiver"><a class="markdownIt-Anchor" href="#tcp-receiver"></a> TCP Receiver</h2><h3 id="index和seqno的转换"><a class="markdownIt-Anchor" href="#index和seqno的转换"></a> Index和Seqno的转换</h3><p>为了节省在<code>TCP Header</code>当中的空间，在<code>StreamReassembler</code>里面写的<code>index</code>虽然是一个<code>uint64_t</code>的类型，但是在实际的<code>Header</code>中是使用一个<code>uint32_t</code>的<code>seqno</code>来进行标记位置的。对于<code>uint32_t</code>的<code>seqno</code>和<code>uint64_t</code>的<code>index</code>的相互转换则是通过以<code>4GiB (2^32 bytes)</code>为一个长度进行取模来实现。</p><p>同时为了提高<code>TCP</code>本身的安全性，并且确保每次获得的<code>segments</code>数据段都是来自于本次连接的，因此提出了<code>ISN(Initial Sequence Number)</code>的概念，即本次链接是从序号为<code>isn</code>开始作为<code>seqno</code>进行通信，大于<code>isn</code>的<code>seqno</code>所代表的<code>index</code>是本次链接所需要的数据段，早于<code>isn</code>的<code>seqno</code>则是来自于上一次连接的老数据段，并不需要处理。</p><p>如果想要将<code>uint32_t</code>的<code>seqno</code>转为一个<code>uint64_t</code>则需要一个<code>checkpoint</code>作为定位，防止<code>seqno</code>被定位到错误的位置上。这个<code>checkpoint</code>在实现中就是最后一个重新组装后的字符位置</p><blockquote><p>按lab2的原文：In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</p></blockquote><p>通过寻找距离<code>checkpoint</code>最近的<code>seqno</code>就可以定位到本来需要插入的<code>seqno</code>位置了</p><h4 id="代码思路"><a class="markdownIt-Anchor" href="#代码思路"></a> 代码思路</h4><p>对于将<code>uint32_t</code>转为<code>uint64_t</code>的代码实现很简单，只需要将<code>uint64_t</code>的<code>index</code>加上<code>isn</code>的值之后对<code>2^32</code>进行取模就行了，具体代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> result = (n + isn.<span class="hljs-built_in">raw_value</span>()) % (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(UINT32_MAX) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">WrappingInt32</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(result));<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于将<code>wrap</code>后的<code>seqno</code>转回<code>index</code>，我直接通过类似分类讨论的枚举找到了四个临界点，只需要判断<code>checkpoint</code>相对于临界点的位置就可以得到答案。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> L = (<span class="hljs-number">1ul</span> &lt;&lt; <span class="hljs-number">32</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> a = (checkpoint / L) * L - isn.<span class="hljs-built_in">raw_value</span>() + n.<span class="hljs-built_in">raw_value</span>();<br>    <span class="hljs-keyword">if</span> (checkpoint &gt; a + (L * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span> * L;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (checkpoint &gt; a + L / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> a + L;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (checkpoint &lt; L) &#123;<br>        <span class="hljs-keyword">return</span> n.<span class="hljs-built_in">raw_value</span>() &lt; isn.<span class="hljs-built_in">raw_value</span>() ? a + L : a;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> checkpoint &lt; a - L / <span class="hljs-number">2</span> ? a - L : a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="详细思路点这里硬分类感觉好蠢但是有效jpg"><a class="markdownIt-Anchor" href="#详细思路点这里硬分类感觉好蠢但是有效jpg"></a> 详细思路点这里(硬分类，感觉好蠢，但是有效.jpg)</h5><details><summary>通解推导</summary><h5 id="checkpoint-l"><a class="markdownIt-Anchor" href="#checkpoint-l"></a> checkpoint &gt; L</h5><p>由以下公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mi>i</mi><mi>s</mi><mi>n</mi><mo fence="true">)</mo></mrow><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>L</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">\left ( index+isn \right )\mod{ L } = seqno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span></span></span></span></span></p><p>通过推导可以得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>+</mo><mi>k</mi><mo>∗</mo><mi>L</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">index = seqno + k * L - isn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span></span></span></span></p><p>因此如果需要得到离<code>checkpoint</code>最近的<code>index</code>就只需要找到合适的<code>k</code>即可，在这里不妨设</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">m = checkpoint / L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">L</span></span></span></span></span></p><p>取<code>m</code>作为一个附近值，通过画图可以知道，在一般情况下，答案一定在<code>checkpoint</code>附近的三个区间内</p><p><img src="https://lsky.halc.top/SclwTP.png" alt="k的范围" /></p><h6 id="seqno-isn-0"><a class="markdownIt-Anchor" href="#seqno-isn-0"></a> seqno - isn &gt; 0</h6><p>在这种情况下，<code>checkpoint</code>的前中后三个区间都存在，只要列举并讨论范围就很简单了</p><p>当<code>seqno - isn</code>为正数的时候，<code>index</code>可能的一个取值会落在第②个区间上，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mi>m</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">index&#x27;&#x27; = m * L + seqno - isn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span></span></span></span></p><p>此时第①区间和第③区间上的<code>index</code>可以分别表示为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>−</mo><mi>L</mi><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>+</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">index&#x27; = index&#x27;&#x27; - L \\\\index&#x27;&#x27;&#x27; = index&#x27;&#x27; + L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8852220000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8852220000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p><p>对<code>index'</code>、<code>index''</code>和<code>index'''</code>的中间值进行判断，很容易得到以下规律</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>=</mo><mi>m</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>L</mi><mo>=</mo><mi>U</mi><mi>I</mi><mi>N</mi><mi>T</mi><mn>32</mn><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a-L</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a+L</mtext></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}  a = m*L+seqno-isn \\\\  L = UINT32\_MAX+1 \\\\  \left  \{\begin{matrix}  checkpoint &lt; a - L/2  &amp; \text{index=a-L}\\\\  a-L/2\leq checkpoint&lt; a+L/2  &amp; \text{index=a}\\\\  a+L/2\leq checkpoint &amp; \text{index=a+L}\end{matrix}\right.\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.80004em;vertical-align:-5.1500200000000005em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.65002em;"><span style="top:-10.060039999999997em;"><span class="pstrut" style="height:5.250019999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span></span><span style="top:-8.860039999999998em;"><span class="pstrut" style="height:5.250019999999999em;"></span><span class="mord"></span></span><span style="top:-7.660039999999999em;"><span class="pstrut" style="height:5.250019999999999em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">3</span><span class="mord">2</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-6.4600399999999985em;"><span class="pstrut" style="height:5.250019999999999em;"></span><span class="mord"></span></span><span style="top:-2.850019999999999em;"><span class="pstrut" style="height:5.250019999999999em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500199999999997em;"><span style="top:-1.2999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.2999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.5999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.500019999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500000000000004em;"><span style="top:-5.410000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-1.8099999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-0.6099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500000000000004em;"><span style="top:-5.410000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a-L</span></span></span></span><span style="top:-3.0100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a</span></span></span></span><span style="top:-0.6100000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a+L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.1500200000000005em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><blockquote><p>注：此时checkpoint一定小于 a+L，因为a+L属于第③区间，而checkpoint在第②区间内</p></blockquote><h6 id="seqno-isn-0-2"><a class="markdownIt-Anchor" href="#seqno-isn-0-2"></a> seqno - isn &lt; 0</h6><p>此时因为是从<code>m*L</code>的位置向前移动，所以相比于上面，三个可能是答案的<code>index</code>的分布则改为了</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>m</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi><mspace linebreak="newline"></mspace><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>+</mo><mi>L</mi><mspace linebreak="newline"></mspace><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>+</mo><mn>2</mn><mo>∗</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">index&#x27; = m * L + seqno - isn\\index&#x27;&#x27; = index&#x27; + L\\index&#x27;&#x27;&#x27; = index&#x27; + 2 * L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8852220000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.801892em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8852220000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p><p>所以很容易得到以下结果</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>=</mo><mi>m</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>L</mi><mo>=</mo><mi>U</mi><mi>I</mi><mi>N</mi><mi>T</mi><mn>32</mn><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>3</mn><mo>∗</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a + L</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>3</mn><mo>∗</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a+2*L</mtext></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}  a = m*L+seqno-isn\\  L = UINT32\_MAX+1\\  \left  \{\begin{matrix}  checkpoint &lt; a + L/2  &amp; \text{index=a}\\  a+L/2\leq checkpoint&lt; a+(3*L)/2  &amp; \text{index=a + L}\\  a+(3*L)/2\leq checkpoint &amp; \text{index=a+2*L}\end{matrix}\right.\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.00004em;vertical-align:-2.7500199999999997em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500200000000006em;"><span style="top:-6.46004em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span></span><span style="top:-5.260040000000001em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">3</span><span class="mord">2</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.85002em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a + L</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a+2*L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500199999999997em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>将以上两种规律整合，我们很容易可以得到以下通解</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>=</mo><mi>m</mi><mo>∗</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi><mo>−</mo><mi>i</mi><mi>s</mi><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>L</mi><mo>=</mo><mi>U</mi><mi>I</mi><mi>N</mi><mi>T</mi><mn>32</mn><mi mathvariant="normal">_</mi><mi>M</mi><mi>A</mi><mi>X</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a-L</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>−</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>L</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>3</mn><mo>∗</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a + L</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mn>3</mn><mo>∗</mo><mi>L</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≤</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>index=a+2*L</mtext></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}  a = m*L+seqno-isn\\  L = UINT32\_MAX+1\\  \left  \{\begin{matrix}  checkpoint &lt; a - L/2  &amp; \text{index=a-L}\\  a-L/2\leq checkpoint&lt; a+L/2  &amp; \text{index=a}\\  a+L/2\leq checkpoint&lt; a+(3*L)/2  &amp; \text{index=a + L}\\  a+(3*L)/2\leq checkpoint &amp; \text{index=a+2*L}\end{matrix}\right.\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.2000399999999996em;vertical-align:-3.3500199999999993em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.85002em;"><span style="top:-7.6600399999999995em;"><span class="pstrut" style="height:4.65002em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span></span></span><span style="top:-6.46004em;"><span class="pstrut" style="height:4.65002em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">3</span><span class="mord">2</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.4500200000000003em;"><span class="pstrut" style="height:4.65002em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a-L</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a + L</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">index=a+2*L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3500199999999993em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></details><details><summary>特殊情况</summary><h5 id="checkpoint-l-2"><a class="markdownIt-Anchor" href="#checkpoint-l-2"></a> checkpoint &lt; L</h5><p>在<code>checkpoint &lt; L</code>的时候，通解中对于<code>a - L</code>的一部分(即checkpoint &lt; a + L)就不适用了，不过分析起来也很简单，由于有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>+</mo><mi>i</mi><mi>s</mi><mi>n</mi><mo fence="true">)</mo></mrow><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>L</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">\left ( index+isn \right )\mod{ L } = seqno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span></span></span></span></span></p><p>所以当<code>seqno</code>小于<code>isn</code>的时候，答案一定在下一个区间，因此答案即<code>L - isn + seqno</code>，当<code>seqno</code>大于<code>isn</code>且<code>checkpoint &lt; a + L</code>，所以答案一定为<code>a</code></p><p>所以就可以得到上述代码了。</p></details><h3 id="tcp-段接收处理"><a class="markdownIt-Anchor" href="#tcp-段接收处理"></a> TCP 段接收处理</h3><p>这部分代码逻辑完成的是<code>tcp</code>握手中对于<code>tcp</code>段的接受处理。</p><p>我自己增加的私有成员和用途大致为：</p><ul><li><code>_is_syn</code>: 判断链接是否建立</li><li><code>_isn</code>: 存入第一次建立连接时接受的<code>seqno</code>来初始化</li><li><code>_is_fin</code>: 用于判断结束输入的报文是否传入</li></ul><p>对于<code>ackno</code>和<code>checkpoint</code>的实现机制是：</p><ul><li><code>ackno</code>: 本质上就是返回已经整合好的数据量，也就是<code>bytes_stream</code>的<code>bytes_written()</code>，同时建立连接后一定存在<code>syn</code>所以可以直接加一，之后只需要判断<code>fin</code>是否到达并且整合完毕，然后再次加一即可。</li><li><code>checkpoint</code>: 和<code>ackno</code>差别不大，只需要直接返回已经写入完成的字符个数即可</li></ul><p>知道了上述几个逻辑以后就只需要通过调整简单的逻辑<code>flag</code>加上<code>lab1</code>里面的<code>push_substring</code>来对<code>payload()</code>进行整合就可以通过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-comment">// 等待并处理第一个syn链接</span><br>    <span class="hljs-keyword">if</span> ((_is_syn == <span class="hljs-number">0</span>) &amp;&amp; seg.<span class="hljs-built_in">header</span>().syn) &#123;<br>        _is_syn = <span class="hljs-number">1</span>;<br>        _isn = seg.<span class="hljs-built_in">header</span>().seqno;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_is_syn == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// checkpoint的位置就是已经写入完成的字符的数量</span><br>    <span class="hljs-comment">// In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> checkpoint = _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 将内容写入reassembler，其中之所以要有(- 1 + seg.header().syn)这个部分，是因为当握手成功以后</span><br>    <span class="hljs-comment">// seqno是从1开始的，而没有握手的时候stream_index应该将包含syn的报文写在index为0的位置上</span><br>    <span class="hljs-type">uint64_t</span> stream_index = <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn, checkpoint) - <span class="hljs-number">1</span> + seg.<span class="hljs-built_in">header</span>().syn;<br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(), stream_index, seg.<span class="hljs-built_in">header</span>().fin);<br><br>    <span class="hljs-comment">// 标志结尾的TCP段是否送达</span><br>    <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">header</span>().fin) &#123;<br>        _is_fin = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// 返回已经消耗的index长度，也就是ackno确认了的长度</span><br>    WrappingInt32 result = _isn + _is_syn + _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>();<br>    <span class="hljs-keyword">if</span> ((_is_fin != <span class="hljs-number">0</span>) &amp;&amp; _reassembler.<span class="hljs-built_in">unassembled_bytes</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断是否包含结束的报文</span><br>        result = result + _is_fin;<br>    &#125;<br>    <span class="hljs-comment">// 如果建立了链接才返回ackno，在建立报文之前是没有ackno的，因为没有对方的信息可以让自己确认</span><br>    <span class="hljs-keyword">return</span> _is_syn ? <span class="hljs-built_in">optional</span>&lt;WrappingInt32&gt;(result) : <span class="hljs-literal">nullopt</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _capacity - _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">buffer_size</span>(); &#125;<br></code></pre></td></tr></table></figure><p>这里有一个让我感觉很疑惑的点就是在单元测试中存在两种测试样例，这里做个记录，后面如果知道了原因就来解决一下</p><ul><li>存在同时携带<code>SYN</code>和<code>FIN</code>报文，按照正常的TCP握手感觉这是不合理的</li><li>在接受<code>SYN</code>的同时会接受一部分的<code>Data</code>进行处理，按正常的TCP也是不会这么做的</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab1 计算机网络：字节流重组器</title>
    <link href="/p/aeda2510.html"/>
    <url>/p/aeda2510.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路总结"><a class="markdownIt-Anchor" href="#思路总结"></a> 思路总结</h2><h3 id="有问题的方案"><a class="markdownIt-Anchor" href="#有问题的方案"></a> 有问题的方案</h3><p>这个方案是采用了一个无限长的字符串<code>cache</code>，所有的TCP段中的部分数据先寄存在<code>cache</code>当中。之后通过创建一个在<code>cache</code>上滑动的写入位指针<code>write_p</code>来将能够顺序写入的内容写入<code>_output</code>当中，其中<code>write_p</code>每次滑动的距离<code>len</code>受限于<code>_output</code>还剩下的可容纳空间。</p><p><img src="https://lsky.halc.top/S7h6KM.png" alt="cache_slide" /></p><p>添加的私有成员:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用于存放缓存</span><br>std::string cache;<br><span class="hljs-comment">// 用于标记缓存对应字节上是否写入内容</span><br>std::string dirty_check;<br><span class="hljs-comment">// 标记写入指针</span><br><span class="hljs-type">size_t</span> write_p;<br><span class="hljs-comment">// 标记EOF位</span><br><span class="hljs-type">size_t</span> end_p;<br></code></pre></td></tr></table></figure><p>对于<code>push_string</code>方法的实现：</p><ol><li><p>检查传入的index是否在可写入范围，如果超出可写入范围则直接退出，保证程序的鲁棒性</p></li><li><p>因为写入的数据长度不能超过<code>capacity</code>，因此需要将扩容的长度设置为<code>index + data.length()</code>和<code>write_p + _output.remaining_capacity()</code>中较小的那个</p></li><li><p>将传入的数据（包括可能超过范围的部分）写入<code>cache</code>中，同时将<code>dirty_check</code>中对应的位置标记为<code>1</code></p></li><li><p>将<code>cache</code>的长度缩回到正确扩容后应该的长度，这样可以将多余的内容丢弃</p></li><li><p>检查<code>write_p</code>的位置上是否有数据可以被写入，如果有则通过滑动<code>len</code>来将内容写入<code>_output</code>，否则跳过</p></li><li><p>检查<code>write_p</code>和<code>end_p</code>是否相同，如果相同则代表写入结束，调用<code>_output.end_input()</code></p></li></ol><p>具体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="hljs-comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span><br><span class="hljs-comment">//! contiguous substrings and writes them into the output stream in order.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br>    <span class="hljs-comment">// extend_size: 按照index和data.length()扩容后的大小，只会按扩大的来扩容</span><br>    <span class="hljs-type">size_t</span> extend_size = index + data.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-comment">// 记录EOF的位置</span><br>    <span class="hljs-keyword">if</span> (eof) &#123;<br>        end_p = extend_size;<br>    &#125;<br><br>    <span class="hljs-comment">// 扩容只会变大，不会缩小</span><br>    <span class="hljs-keyword">if</span> (extend_size &gt; cache.<span class="hljs-built_in">length</span>()) &#123;<br>        cache.<span class="hljs-built_in">resize</span>(extend_size);<br>        dirty_check.<span class="hljs-built_in">resize</span>(extend_size);<br>    &#125;<br><br>    <span class="hljs-comment">// 将要排序的内容写入cache当中</span><br>    cache.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data);<br>    dirty_check.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data.<span class="hljs-built_in">length</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-comment">// 缩回原来的大小，将缓冲区外多余的内容丢弃</span><br>    <span class="hljs-keyword">if</span> (expand_size &gt; cache_raw_length) &#123;<br>        cache.<span class="hljs-built_in">resize</span>(expand_size);<br>        dirty_check.<span class="hljs-built_in">resize</span>(expand_size);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查写入位上是否有字符，有字符则通过滑动len来写入_output，否则跳过</span><br>    <span class="hljs-keyword">if</span> (dirty_check[write_p]) &#123;<br>        <span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> output_remaining = _output.<span class="hljs-built_in">remaining_capacity</span>();<br>        <span class="hljs-keyword">while</span> (dirty_check[write_p + len] &amp;&amp; len &lt; output_remaining) &#123;<br>            len++;<br>        &#125;<br>        _output.<span class="hljs-built_in">write</span>(cache.<span class="hljs-built_in">substr</span>(write_p, len));<br>        write_p += len;<br>    &#125;<br><br>    <span class="hljs-comment">// 写入位和EOF位相同，代表写入结束</span><br>    <span class="hljs-keyword">if</span> (write_p == end_p) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于没有统计的字符数量，直接使用一个循环进行统计即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回缓冲区内还没有处理的内容</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> n = write_p;<br>    <span class="hljs-comment">// 检查缓存区有多少字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = write_p; n != cache.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-keyword">not</span> dirty_check[i]; i++) &#123;<br>        n++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cache.<span class="hljs-built_in">length</span>() - n;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于判断缓冲区是否使用完毕则是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当不再写入新的TCP段并且已有的字段全部排序结束的时候缓冲区不再需要排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _output.<span class="hljs-built_in">eof</span>() &amp;&amp; <span class="hljs-keyword">not</span> <span class="hljs-built_in">unassembled_bytes</span>(); &#125;<br></code></pre></td></tr></table></figure><h3 id="测试案例的补充"><a class="markdownIt-Anchor" href="#测试案例的补充"></a> 测试案例的补充</h3><p>使用上面这种写法的话虽然可以达到<code>100% tests passed</code>，并且时间也都能控制在<code>0.5s</code>以内，但是在复习了真实情况下的重组过程发现这个思路存在一些BUG是测试案例没有检测出来的。</p><h4 id="不会抛弃本来应该抛弃的数据同时产生错误的eof位置标记"><a class="markdownIt-Anchor" href="#不会抛弃本来应该抛弃的数据同时产生错误的eof位置标记"></a> 不会抛弃本来应该抛弃的数据，同时产生错误的EOF位置标记</h4><p>以如下的<code>test</code>为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>   ReassemblerTestHarness test&#123;<span class="hljs-number">6</span>&#125;;<br>   test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;defg&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>   test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAssembled</span>(<span class="hljs-number">0</span>));<br>   test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>   test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAvailable</span>(<span class="hljs-string">&quot;abcdef&quot;</span>));<br>   test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAssembled</span>(<span class="hljs-number">6</span>));<br>   test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;kmg&quot;</span>, <span class="hljs-number">7</span>&#125;);<br>   test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAvailable</span>(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后可以发现有报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs log">Test Failure on expectation:<br>        Expectation: stream_out().buffer_size() returned 0, and stream_out().read(0) returned the string &quot;&quot;<br><br>Failure message:<br>        The reassembler was expected to have `0` bytes available, but there were `4`<br><br>List of steps that executed successfully:<br>        Initialized (capacity = 6)<br>        Action:      substring submitted with data &quot;defg&quot;, index `3`, eof `0`<br>        Expectation: net bytes assembled = 0<br>        Action:      substring submitted with data &quot;abc&quot;, index `0`, eof `0`<br>        Expectation: stream_out().buffer_size() returned 6, and stream_out().read(6) returned the string &quot;abcdef&quot;<br>        Expectation: net bytes assembled = 6<br>        Action:      substring submitted with data &quot;kmg&quot;, index `7`, eof `0`<br><br>Exception: The reassembler was expected to have `0` bytes available, but there were `4`<br></code></pre></td></tr></table></figure><p>可以发现，本来在传入第一个<code>defg</code>的时候，字符<code>g</code>应该因为超出<code>capacity</code>而被抛弃，但是是将并没有，导致<code>g</code>停留在了<code>index</code>为<code>6</code>的位置上。读取了<code>_output</code>的所有内容之后，<code>_output</code>的窗口应该是从<code>index</code>为<code>6</code>的位置上开始准备写入，但是由于这个位置上的<code>g</code>在上一个窗口期中并没有被抛弃，结果导致了<code>index</code>为<code>7</code>的<code>kmg</code>写入的时候，连带前面存在的<code>g</code>一起将<code>gkmg</code>写入了<code>_output</code>的窗口当中，从而出现了以下报错。</p><blockquote><p>The reassembler was expected to have <code>0</code> bytes available, but there were <code>4</code></p></blockquote><p>同时对于EOF的位置判断也有类似的BUG，测试样例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ReassemblerTestHarness test&#123;<span class="hljs-number">6</span>&#125;;<br>    test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;defx&quot;</span>, <span class="hljs-number">3</span>&#125;.<span class="hljs-built_in">with_eof</span>(<span class="hljs-literal">true</span>));<br>    test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAssembled</span>(<span class="hljs-number">0</span>));<br>    test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">0</span>&#125;);<br>    test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAvailable</span>(<span class="hljs-string">&quot;abcdef&quot;</span>));<br>    test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAssembled</span>(<span class="hljs-number">6</span>));<br>    test.<span class="hljs-built_in">execute</span>(SubmitSegment&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-number">6</span>&#125;);<br>    test.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">BytesAvailable</span>(<span class="hljs-string">&quot;g&quot;</span>));<br>    test.<span class="hljs-built_in">execute</span>(NotAtEof&#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs log">Test Failure on expectation:<br>        Expectation: not at EOF<br><br>Failure message:<br>        The reassembler was expected to **not** be at EOF, but was<br><br>List of steps that executed successfully:<br>        Initialized (capacity = 6)<br>        Action:      substring submitted with data &quot;defx&quot;, index `3`, eof `1`<br>        Expectation: net bytes assembled = 0<br>        Action:      substring submitted with data &quot;abc&quot;, index `0`, eof `0`<br>        Expectation: stream_out().buffer_size() returned 6, and stream_out().read(6) returned the string &quot;abcdef&quot;<br>        Expectation: net bytes assembled = 6<br>        Action:      substring submitted with data &quot;g&quot;, index `6`, eof `0`<br>        Expectation: stream_out().buffer_size() returned 1, and stream_out().read(1) returned the string &quot;g&quot;<br><br>Exception: The reassembler was expected to **not** be at EOF, but was<br></code></pre></td></tr></table></figure><p>本来在第一个操作的时候作为<code>eof</code>的<code>x</code>应该是被抛弃掉并不读取的，但是在最后这个位置的<code>eof_p</code>还是触发了<code>EOF</code>判断，导致产生了不应该出现的<code>EOF</code>。</p><h2 id="修正方案"><a class="markdownIt-Anchor" href="#修正方案"></a> 修正方案</h2><p>本质的问题就是没有丢弃掉<code>unacceptable</code>的字节，这里采取了一个比较省事但是很不优雅的操作，我是选择在最后扩容后重新再用<code>resize()</code>函数将不需要的那部分丢弃掉，来达到限制容量的目的，最后修正完毕的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> eof_flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">size_t</span> expand_size = index + data.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-comment">// 短路错误index</span><br>    <span class="hljs-keyword">if</span> (index &gt; write_p + _output.<span class="hljs-built_in">remaining_capacity</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 取 index + data.length() 和</span><br>    <span class="hljs-comment">// write_p + _output.remaining_capacity() 中更小的那个作为扩容后的大小</span><br>    <span class="hljs-keyword">if</span> (index + data.<span class="hljs-built_in">length</span>() &lt;= write_p + _output.<span class="hljs-built_in">remaining_capacity</span>()) &#123;<br>        <span class="hljs-comment">// 用于判断EOF是否是在capacity当中的有效字符</span><br>        eof_flag = <span class="hljs-literal">true</span>;<br>        expand_size = index + data.<span class="hljs-built_in">length</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        expand_size = write_p + _output.<span class="hljs-built_in">remaining_capacity</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 记录EOF的位置</span><br>    <span class="hljs-keyword">if</span> (eof &amp;&amp; eof_flag) &#123;<br>        end_p = expand_size;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> cache_raw_length = cache.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-comment">// 先扩大一次容量，用于写入多余的内容</span><br>    <span class="hljs-keyword">if</span> (expand_size &gt; cache_raw_length) &#123;<br>        cache.<span class="hljs-built_in">resize</span>(expand_size);<br>        dirty_check.<span class="hljs-built_in">resize</span>(expand_size);<br>    &#125;<br><br>    <span class="hljs-comment">// 将要排序的内容先写入cache当中</span><br>    cache.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data);<br>    dirty_check.<span class="hljs-built_in">replace</span>(index, data.<span class="hljs-built_in">length</span>(), data.<span class="hljs-built_in">length</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);<br><br>    <span class="hljs-comment">// 缩回原来的大小，将缓冲区外多余的内容丢弃</span><br>    <span class="hljs-keyword">if</span> (expand_size &gt; cache_raw_length) &#123;<br>        cache.<span class="hljs-built_in">resize</span>(expand_size);<br>        dirty_check.<span class="hljs-built_in">resize</span>(expand_size);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查写入位上是否有字符，有字符则通过滑动len来写入_output，否则跳过</span><br>    <span class="hljs-keyword">if</span> (dirty_check[write_p]) &#123;<br>        <span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> output_remaining = _output.<span class="hljs-built_in">remaining_capacity</span>();<br>        <span class="hljs-keyword">while</span> (dirty_check[write_p + len] &amp;&amp; len &lt; output_remaining) &#123;<br>            len++;<br>        &#125;<br>        _output.<span class="hljs-built_in">write</span>(cache.<span class="hljs-built_in">substr</span>(write_p, len));<br>        write_p += len;<br>    &#125;<br><br>    <span class="hljs-comment">// 写入位和EOF位相同，代表写入结束</span><br>    <span class="hljs-keyword">if</span> (write_p == end_p) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab0 计算机网络：流的输入和读出</title>
    <link href="/p/2ca0860a.html"/>
    <url>/p/2ca0860a.html</url>
    
    <content type="html"><![CDATA[<h2 id="热身"><a class="markdownIt-Anchor" href="#热身"></a> 热身</h2><p><code>lab0</code>前后分为两个较为简单的小任务，第一个任务是写一个类似<code>telnet</code>中通信的<code>webget</code>小应用，第二个任务是实现一个简单的<code>ByteStream</code>的类，只需要在单线程的情况下能正常运行即可</p><h3 id="任务一"><a class="markdownIt-Anchor" href="#任务一"></a> 任务一</h3><p>第一个任务的参考主要是从项目文件本身的<code>doctests</code>开始着手，其中在提示中已经说了我们将会使用到<code>TCPSocket</code>和<code>Address</code>，在对应的<code>doctests/socket_example_2.cc</code>和<code>doctests/address_example_1.cc</code>中，我们可以得到对于他们的使用例子，只需要创建一个以目标<code>Address</code>初始化并连接的<code>TCPSocket</code>，然后以这个<code>socket</code>向目标服务器发送类似<code>telnet</code>的请求即可获得我们需要的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TCPSocket socket;<br>socket.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br>socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Connection: close\r\n\r\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>由于最后在输入完<code>Connection: close</code>之后，我们本来也要输入一个回车将请求发送，因此在这里需要两个换行符</p><p>在处理<code>socket.read()</code>的时候，起初没有仔细考虑pdf中提到的<code>a single call to read is not enough</code>的具体含义，以为是首先会接受所有的文本信息，然后对于结果需要将最后的<code>EOF</code>也打印出来，所以第一次写的时候只是简单的调用了两次<code>read()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; socket.<span class="hljs-built_in">read</span>() &lt;&lt; socket.<span class="hljs-built_in">read</span>();<br></code></pre></td></tr></table></figure><p>然而在<code>make check_webget</code>的时候并没有通过，为了找到问题所在，首先找到<code>check_webget</code>的脚本，发现测试的内容为对<code>cs144.keithw.org</code>下的接口<code>/nph-hasher/xyzzy</code>发送请求，并获取最后一行的内容，而这行内容应该是一串正确的HASH。但是在这个时候尝试以上文的方式运行<code>webget</code>的时候则发现输出的只有以下两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP/1.1 200 OK<br>Content-type: text/plain<br></code></pre></td></tr></table></figure><p>但是通过<code>telnet</code>的情况下，正常的输入应该是以下的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">HTTP/1.1 200 OK<br>Content-type: text/plain<br><br>7SmXqWkrLKzVBCEalbSPqBcvs11Pw263K7x4Wv3JckI<br></code></pre></td></tr></table></figure><p>这个时候就懂了多次调用<code>read()</code>的含义直到遇到<code>eof</code>的含义应该是一直读取到所有缓冲区内的内容都被读取完毕，将代码修改如下就可以通过测试了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;host, <span class="hljs-type">const</span> string &amp;path)</span> </span>&#123;<br>    TCPSocket socket;<br>    socket.<span class="hljs-built_in">connect</span>(<span class="hljs-built_in">Address</span>(host, <span class="hljs-string">&quot;http&quot;</span>));<br>    socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>    socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>    socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Connection: close\r\n\r\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (!socket.<span class="hljs-built_in">eof</span>()) &#123;<br>        cout &lt;&lt; socket.<span class="hljs-built_in">read</span>();<br>    &#125;<br>    socket.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任务二"><a class="markdownIt-Anchor" href="#任务二"></a> 任务二</h3><p>第二个任务主要是要我们自己根据头文件的内容来实现一个简单的<code>ByteStream</code>，并且只需要考虑单线程的情况，不用考虑并发等情况。</p><p>最后完成的答案先直接贴上来，这块难度也不会很大，在写的时候先大致按要求写出一个逻辑，即使不是很清楚具体实现对不对也问题不大，只需要通过调试逐步修改即可</p><p>首先添加的成员变量如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// buffer capacity</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> buffer_max_size;<br><br>    <span class="hljs-comment">// buffer string</span><br>    std::string buffer;<br><br>    <span class="hljs-comment">// input ending flag</span><br>    <span class="hljs-type">bool</span> is_input_end = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// counter</span><br>    <span class="hljs-type">size_t</span> write_count, read_count;<br><br>    <span class="hljs-comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span><br>    <span class="hljs-comment">// all, but if any of your tests are taking longer than a second,</span><br>    <span class="hljs-comment">// that&#x27;s a sign that you probably want to keep exploring</span><br>    <span class="hljs-comment">// different approaches.</span><br><br>    <span class="hljs-type">bool</span> _error&#123;&#125;;  <span class="hljs-comment">//!&lt; Flag indicating that the stream suffered an error.</span><br><br>  <span class="hljs-keyword">public</span>:<br>   ...<br></code></pre></td></tr></table></figure><p>最后接口的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <span class="hljs-built_in">buffer_max_size</span>(capacity), <span class="hljs-built_in">buffer</span>(), <span class="hljs-built_in">write_count</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">read_count</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-comment">// 不需要在这里判断input_ended，因为写入过程都是单线程，如果要ended肯定是在write之后进行的</span><br>    <span class="hljs-type">size_t</span> cnt = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">remaining_capacity</span>(), data.<span class="hljs-built_in">length</span>());<br>    buffer += data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, cnt);<br>    write_count += cnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len); &#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, len);<br>    read_count += len;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-function">std::string <span class="hljs-title">ByteStream::read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    string output = buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len);<br>    <span class="hljs-built_in">pop_output</span>(len);<br>    <span class="hljs-comment">// 在pop_output的时候会计算读取，这里不需要再+=len</span><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123; is_input_end = <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> is_input_end; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer.<span class="hljs-built_in">length</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">input_ended</span>() &amp;&amp; buffer.<span class="hljs-built_in">empty</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> write_count; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> read_count; &#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> buffer_max_size - buffer.<span class="hljs-built_in">length</span>(); &#125;<br></code></pre></td></tr></table></figure><h4 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h4><p>接口的逻辑实现都不难，不过写这个<code>lab</code>的时候的第一次在<code>vscode</code>的环境下使用<code>cmake</code>来进行调试，在这里简单记录一下调试的步骤和需求。</p><p><strong>相关code插件</strong>: CMake, CMake Tools, C/C++(Cpptools)</p><p>在这里以<code>write()</code>函数中缺少了<code>write_count += cnt</code>这一行为例，使用<code>make check_lab0</code>可以发现在最后有报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs log">56% tests passed, 4 tests failed out of 9<br><br>Total Test time (real) =   1.49 sec<br><br>The following tests FAILED:<br>         27 - t_byte_stream_one_write (Failed)<br>         28 - t_byte_stream_two_writes (Failed)<br>         29 - t_byte_stream_capacity (Failed)<br>         30 - t_byte_stream_many_writes (Failed)<br>Errors while running CTest<br>make[3]: *** [CMakeFiles/check_lab0.dir/build.make:71: CMakeFiles/check_lab0] Error 8<br>make[2]: *** [CMakeFiles/Makefile2:228: CMakeFiles/check_lab0.dir/all] Error 2<br>make[1]: *** [CMakeFiles/Makefile2:235: CMakeFiles/check_lab0.dir/rule] Error 2<br>make: *** [Makefile:160: check_lab0] Error 2<br></code></pre></td></tr></table></figure><p>此时可以将注意力先集中在最上面的<code>t_byte_stream_one_write</code>上，<code>cmake</code>中将<code>byte_stream_one_write</code>作为<code>target</code>编译并运行，可以得到以下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs log">Test Failure on expectation:<br>        Expectation: bytes_written: 3<br><br>Failure message:<br>        The ByteStream should have had bytes_written equal to 3 but instead it was 0<br><br>List of steps that executed successfully:<br>        Initialized with (capacity=15)<br>             Action: write &quot;cat&quot; to the stream<br>        Expectation: input_ended: 0<br>        Expectation: buffer_empty: 0<br>        Expectation: eof: 0<br>        Expectation: bytes_read: 0<br><br>Exception: The test &quot;write-end-pop&quot; failed<br></code></pre></td></tr></table></figure><p>从这里可以知道是测试<code>&quot;write-end-pop&quot;</code>中的第五个执行中，<code>bytes_written</code>并没有返回预期希望的数字<code>3</code>。因此只需要在<code>tests/byte_stream_one_write.cc</code>内&quot;write-end-pop&quot;的<code>test.execute(BytesWritten&#123;3&#125;);</code>的位置打上断点，然后直接使用<code>vscode</code>下方栏中<code>cmake</code>的<code>debug</code>图标（需要安装C/C++插件才可以使用快速调试，具体参考<a href="https://github.com/microsoft/vscode-cmake-tools/blob/f85174dac4562ea10da73cceee1d84394c0a808c/docs/debug-launch.md#quick-debugging">这里</a>）就可以逐步找到自己逻辑中出错的地方并修改即可。</p><p>热身的两个<code>lab</code>提供的成就感很足，希望自己能尽快完成下一个<code>lab</code>。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchWSL安装及基础配置</title>
    <link href="/p/cdfd3649.html"/>
    <url>/p/cdfd3649.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>在<code>Windows</code>上安装<code>ArchWSL</code>直接使用<code>scoop</code>来安装是比较便捷的一种方案，具体如何在<code>Windows</code>上配置·scoop`可以参考这篇教程：</p><ul><li><a href="https://halc.top/p/f15c20eb.html">Windows上通过Scoop管理和安装软件</a></li></ul><p>在配置好了<code>scoop</code>以后，首先通过以下指令安装<code>ArchWSL</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop install archwsl<br></code></pre></td></tr></table></figure><p>只要按正常流程，按<code>win+s</code>，通过Windows搜索找“Turn Windows features on or off”或“启用或关闭Windows功能”，然后在里面将 <strong>Virtual Machine Platform</strong> 和 <strong>Windows Subsystem for Linux</strong> 勾选上，重启电脑即可。</p><p>重启电脑之后只需要在命令行中输入<code>arch</code>即可启动，如果出现报错或无法使用 <code>WSL2</code> 的情况可以通过搜索引擎或在这里<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">下载Linux内核更新包</a>来解决</p><h2 id="配置镜像源并创建非root用户"><a class="markdownIt-Anchor" href="#配置镜像源并创建非root用户"></a> 配置镜像源并创建非root用户</h2><h3 id="启用mirrorlist包含镜像"><a class="markdownIt-Anchor" href="#启用mirrorlist包含镜像"></a> 启用mirrorlist包含镜像</h3><p>在<code>/etc/pacman.d/mirrorlist</code>内已经有<code>Arch</code>预置好的部分国内镜像源，我们只需要将我们对应需要的镜像前面的注释取消即可使用。</p><p>或者也可以通过下面这个脚本来一键启用所有<code>China</code>部分的镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -E <span class="hljs-string">&#x27;/China/,/##/s/^#S(.)/S\1/g&#x27;</span> /etc/pacman.d/mirrorlist~ &gt; /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><h3 id="添加archlinuxcn源"><a class="markdownIt-Anchor" href="#添加archlinuxcn源"></a> 添加archlinuxcn源</h3><p>通过以下指令将<code>archlinuxcn</code>相关源直接写入<code>/etc/pacman.conf</code>当中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt;&gt; /etc/pacman.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"># 国内archlinuxcn镜像源</span><br><span class="hljs-string">[archlinuxcn]</span><br><span class="hljs-string">Server = https://mirrors.aliyun.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://repo.archlinuxcn.org/\$arch</span><br><span class="hljs-string">Server = https://mirrors.bfsu.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.cloud.tencent.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.163.com/archlinux-cn/\$arch</span><br><span class="hljs-string">Server = https://repo.huaweicloud.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.zju.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.cqupt.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h3 id="安装yay和基础环境"><a class="markdownIt-Anchor" href="#安装yay和基础环境"></a> 安装yay和基础环境</h3><p>首先通过以下指令，来更新软件源、安装<code>archlinuxcn</code>证书、<code>yay</code>和部分基础工具（其中yadm是一个用来备份<code>dotfiles</code>的工具，用于恢复自己常用的<code>Linux</code>环境下的自定义文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syyu --noconfirm ;<br>pacman -S archlinuxcn-keyring --noconfirm &amp;&amp; pacman -S yay wget curl zsh yadm --noconfirm <br></code></pre></td></tr></table></figure><h3 id="创建非root用户"><a class="markdownIt-Anchor" href="#创建非root用户"></a> 创建非root用户</h3><ol><li><p>创建用户 <strong>（注意替换下文的<code>用户名</code>）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -G wheel -s /bin/zsh 用户名<br></code></pre></td></tr></table></figure></li><li><p>将<code>wheel</code>组内的成员给予<code>sudo</code>的权限</p><p>如果希望安全考虑，在<code>sudo</code>之前要输入密码的话，可以输入下面的指令来配置<code>visudo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;%wheel ALL=(ALL:ALL) ALL&#x27;</span> | sudo EDITOR=<span class="hljs-string">&#x27;tee -a&#x27;</span> visudo<br></code></pre></td></tr></table></figure><p>如果偷懒，不希望每次都输入密码的话可以用下面的指令来配置<code>visudo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;%wheel ALL=(ALL:ALL) NOPASSWD: ALL&#x27;</span> | sudo EDITOR=<span class="hljs-string">&#x27;tee -a&#x27;</span> visudo<br></code></pre></td></tr></table></figure><blockquote><p>2.5. 以上所有操作全部可以自动完成，只需要将以下脚本内的用户名替换为自己的用户名即可（默认sudo不需要密码）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -E <span class="hljs-string">&#x27;/China/,/##/s/^#S(.)/S\1/g&#x27;</span> /etc/pacman.d/mirrorlist~ &gt; /etc/pacman.d/mirrorlist<br><span class="hljs-built_in">cat</span> &gt;&gt; /etc/pacman.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"># 国内archlinuxcn镜像源</span><br><span class="hljs-string">[archlinuxcn]</span><br><span class="hljs-string">Server = https://mirrors.aliyun.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://repo.archlinuxcn.org/\$arch</span><br><span class="hljs-string">Server = https://mirrors.bfsu.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.cloud.tencent.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.163.com/archlinux-cn/\$arch</span><br><span class="hljs-string">Server = https://repo.huaweicloud.com/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.zju.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.cqupt.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/\$arch</span><br><span class="hljs-string">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/\$arch</span><br><span class="hljs-string">EOF</span><br>pacman -Syyu --noconfirm ;<br>pacman -S archlinuxcn-keyring --noconfirm &amp;&amp; pacman -S yay wget curl zsh yadm --noconfirm <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;%wheel ALL=(ALL:ALL) NOPASSWD: ALL&#x27;</span> | sudo EDITOR=<span class="hljs-string">&#x27;tee -a&#x27;</span> visudo<br>useradd -m -G wheel -s /bin/zsh 用户名<br></code></pre></td></tr></table></figure></blockquote></li><li><p>给root用户和自定义用户设置密码（自行操作）</p><p>修改root用户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd root<br></code></pre></td></tr></table></figure><p>修改自定义用户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd 用户名<br></code></pre></td></tr></table></figure></li><li><p>(可选)切换到自定义用户下并配置<code>oh-my-zsh</code></p><p>通过以下指令切换用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su 用户名<br></code></pre></td></tr></table></figure><p>配置<code>zsh</code>为<code>oh-my-zsh</code>可以参考这篇教程（Ubuntu配置和Arch大同小异，可以选择性参考）</p><p><a href="https://halc.top/p/80f884dc.html">Ubuntu下安装Oh My Zsh引导</a></p></li></ol><h2 id="设置自定义用户和archwsl为默认"><a class="markdownIt-Anchor" href="#设置自定义用户和archwsl为默认"></a> 设置自定义用户和ArchWSL为默认</h2><p>如果希望设置<code>ArchWSL</code>为<code>WSL</code>的默认发行版，并将刚刚自己创建的用户作为默认用户的话只需要分别在<code>Powershell</code>下执行这两条指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-s</span> Arch<br></code></pre></td></tr></table></figure><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ps">Arch config <span class="hljs-literal">--default-user</span> 用户名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell：管道符与重定向</title>
    <link href="/p/db6cc46f.html"/>
    <url>/p/db6cc46f.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>到目前位置自己还没专门花时间研究过<code>Linux</code>上那些日日都在用的工具(如<code>Shell</code>和<code>Vim</code>)他们本来的用法和含义，本来觉得没必要，不过在看了<code>missing-semester</code>之后顿时感觉效率提高了不少。因此做一个笔记，把一些很实用但是自己并不会去关注的简单用法给记录一下。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li><a href="https://blog.51cto.com/yuyucat/1651914">Linux shell管道与重定向实例分析</a></li><li><a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell预览</a></li><li><a href="https://stackoverflow.com/a/12168594">How does “&lt;&lt;” operator work in linux shell?</a></li><li><a href="https://unix.stackexchange.com/a/14249">Precedence of stdin and stdout redirection in Bash</a></li><li><a href="https://stackoverflow.com/a/29783586">Redirection and pipe behavior in bash vs. zsh</a></li></ul><h2 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> Shell</h2><h3 id="prompt"><a class="markdownIt-Anchor" href="#prompt"></a> prompt</h3><p>在使用最基础的<code>bash</code>作为命令行的时候，常常能发现用户后面有的时候是<code>$</code>二有的时候是<code>#</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[halc@Zephyrus blog]$ su<br>[root@Zephyrus blog]#<br></code></pre></td></tr></table></figure><p>这里<code>$</code>代表了当前用户为普通用户，而<code>#</code>的含义则代表当前是在<code>root</code>用户下</p><h3 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h3><h4 id="输出重定向"><a class="markdownIt-Anchor" href="#输出重定向"></a> 输出重定向</h4><p>在<code>shell</code>程序中，程序的执行主要分为 <strong>输入流</strong> 和 <strong>输出流</strong> 两种不同的流，程序会从输入流中读取信息，然后在通过处理之后打印到输出流当中。</p><p>以<code>cat</code>为例，其作用为将一个文件的内容打印到输出流当中，通过使用 <code>&gt; file</code> 和 <code>&lt; file</code> 来对流进行重定向，可以覆写或者创建对应内容的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将我存于github的pubkey打印输出成id_rsa.pub文件</span><br>curl https://github.com/HalcyonAzure.keys &gt; id_rsa.pub<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将id_rsa.pub的内容重定向 **追加** 到authorized_keys当中</span><br>cat id_rsa.pub &gt;&gt; authorized_keys<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将id_rsa.pub的内容先重定向给<span class="hljs-built_in">cat</span>，再由<span class="hljs-built_in">cat</span>输出到pubkey当中</span><br>cat &lt; id_rsa.pub &gt; pubkey<br></code></pre></td></tr></table></figure><blockquote><p>拓展补充 1：所有的Linux进程都包含3个文件描述符，分别是 <strong>标准输入</strong>，<strong>标准输出</strong> 和 <strong>错误输出</strong>。<br />标准输入(stdin)：对应的文件标识符为0，使用<code>&lt;</code>或<code>&lt;&lt;</code>来操作<br />标准输出(stdout)：对应的文件标识符为1，使用<code>&gt;</code>或<code>&gt;&gt;</code>来操作<br />错误输出(stderr): 对应的文件标识符为2，使用<code>2&gt;</code>或<code>2&gt;&gt;</code>来操作<br />默认情况下，标准输出和错误输出都默认为使用者的屏幕，通过使用输出重定向可以做到控制日志的效果</p><p>补充拓展 2：<code>&gt;/dev/null 2&gt;&amp;1</code>和<code>2&gt;&amp;1 &gt;/dev/null</code>的区别</p><ul><li>对于<code>&gt;/dev/null 2&gt;&amp;1</code>是指先将标准输出指向黑洞设备，然后再将错误输出指向标准输出的指向内容（此时是黑洞），因此标准输出和错误输出都将不输出</li><li>对于<code>2&gt;&amp;1 &gt;/dev/null</code>是先将错误输出指向标准输出（此时为屏幕），然后将标准输出指向黑洞，因此此时错误输出将打印到屏幕，而标准输出将不输出</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行example.sh，并将标准输出重定向至stdout.log，将错误输出重定向至stderr.log</span><br>bash example.sh 1&gt;stdout.log 2&gt;stderr.log<br></code></pre></td></tr></table></figure><p>以一个简单的test.cpp程序为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;This is stand output&quot;</span> &lt;&lt; endl;<br>   cerr &lt;&lt; <span class="hljs-string">&quot;This is error output&quot;</span> &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编译并重定向运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[halc@Zephyrus ~]$ g++ test.cpp -o test<br>[halc@Zephyrus ~]$ ./test 1&gt;stand.log 2&gt;err.log<br>[halc@Zephyrus ~]$ rg output *.log<br>stand.log<br>1:This is stand output<br><br>err.log<br>1:This is error output<br></code></pre></td></tr></table></figure><p>如果希望将对应的文件描述符关闭的话有两种方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">$-指关闭对应的文件操作符</span><br>[halc@Zephyrus ~]$ ./test 1&gt;$- 2&gt;$-<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/dev/null为linux内的黑洞设备</span><br>[halc@Zephyrus ~]$ ./test 1&gt;/dev/null 2&gt;/dev/null<br></code></pre></td></tr></table></figure><blockquote><ul><li>对于<code>&gt;</code>操作符，首先会判断右侧的文件是否存在，如果存在就删除再创建，如果不存在则直接创建，并且右侧的文件一定会置空。</li><li>一条命令执行前会检查0,1,2三个I/O设备是否正常，如果异常则不会进行命令执行</li></ul></blockquote><h4 id="输入重定向"><a class="markdownIt-Anchor" href="#输入重定向"></a> 输入重定向</h4><p>如果想要将内容输出重定向到某个文件，以<code>cat</code>举例有两种不同的办法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将read.md的内容重定向至write.md</span><br>cat &gt; write.md &lt; read.md<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;&lt;&lt; EOF&quot;</span>指对流进行重定向输入，直到遇到<span class="hljs-string">&quot;EOF&quot;</span>(可修改)作为末尾则结束</span><br>cat &gt; input.md &lt;&lt; EOF<br></code></pre></td></tr></table></figure><blockquote><p>摘自：<a href="https://stackoverflow.com/a/12168594">How does “&lt;&lt;” operator work in linux shell?</a></p><blockquote><p><code>&lt;&lt;</code> 操作符主要有以下三个操作逻辑</p><ol><li>首先执行该操作符左侧的程序，在上面的例子中就是<code>cat</code></li><li>抓取用户包括换行等所有的输入内容，直到输入的内容为用户指定的EOF结尾内容（在上面的例子中则恰好也是EOF）则停止</li><li>将所有除了EOF的内容都作为(1)程序的标准输入执行</li></ol></blockquote></blockquote><p>实例：通过<code>bash</code>脚本创建一个<code>test.cpp</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt; test.cpp &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">#include&lt;iostream&gt;</span><br><span class="hljs-string">using namespace std;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int main() &#123;</span><br><span class="hljs-string">   cout &lt;&lt; &quot;This is stand output&quot; &lt;&lt; endl;</span><br><span class="hljs-string">   cerr &lt;&lt; &quot;This is error output&quot; &lt;&lt; endl;</span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h3 id="管道和重定向的使用区别"><a class="markdownIt-Anchor" href="#管道和重定向的使用区别"></a> 管道和重定向的使用区别</h3><blockquote><p>1、文件类型上<br />左边的命令应该有标准输出 | 右边的命令应该能接受标准输入；<br />左边的命令应该有标准输出 &gt; 右边只能是文件；<br />左边的命令应该需要标准输入 &lt; 右边只能是文件；</p><p>2、管道触发两个子进程执行 “|” 两边的程序，而重定向是在一个进程内执行。</p></blockquote><h4 id="结合管道的输入重定向"><a class="markdownIt-Anchor" href="#结合管道的输入重定向"></a> 结合管道的输入重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">(sed -n <span class="hljs-string">&#x27;1,$p&#x27;</span> | grep -n <span class="hljs-string">&#x27;output&#x27;</span>) &lt; test.cpp</span><br>5:   cout &lt;&lt; &quot;This is stand output&quot; &lt;&lt; endl;<br>6:   cerr &lt;&lt; &quot;This is error output&quot; &lt;&lt; endl;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等价于 sed -n <span class="hljs-string">&#x27;1,$p&#x27;</span> &lt; test.cpp | grep -n <span class="hljs-string">&#x27;output&#x27;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于管道运算符，如果希望将`test.cpp`传递给前面的第一个可执行文件`sed`，则需要使用单括号将整个管道传输看作一个单独的指令，否则`test.cpp`将传入`grep`内</span><br></code></pre></td></tr></table></figure><blockquote><p>由于标准输入和标准输出在管道运算符中的重定向是发生在&quot;内容输出&quot;之前的，因此可以通过重定向来修改管道中传输的数据</p><blockquote><p>Because pipeline assignment of standard input or standard output or both takes place before redirection, it can be modified by redirection.</p></blockquote></blockquote><p>举个例子来说，本来管道传输默认只传输标准输出的内容，并不会传输错误输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[halc@Zephyrus ~]$ command1 2&gt;&amp;1 | command2<br></code></pre></td></tr></table></figure><p>通过上面的指令，首先<code>command1</code>的 <strong>错误输出</strong> 会在执行前被重定向至标准输入，然后<code>command1</code>执行，将 <strong>标准输出</strong> 和 <strong>错误输出</strong> 一并通过管道进行传输，作为<code>command2</code>的标准输入</p><h4 id="结合管道的输出重定向"><a class="markdownIt-Anchor" href="#结合管道的输出重定向"></a> 结合管道的输出重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先将test.sh的内容通过<span class="hljs-built_in">cat</span>打印到标准输出， 然后管道传输该输出给<span class="hljs-built_in">tee</span>，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在<span class="hljs-built_in">tee</span>执行之前通过&amp;&gt;将<span class="hljs-built_in">tee</span>的标准输入和错误输出都重定向至/dev/null中，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后执行<span class="hljs-built_in">tee</span>将管道获取的内容写入text.txt，并且将相同的内容写入null设备当中</span><br>cat test.sh | tee text.txt &amp;&gt; /dev/null<br></code></pre></td></tr></table></figure><blockquote><p><code>&gt;</code> 输出重定向，往往在命令最右边（也可以用到命令中间），接收左边命令的输出结果，重定向到指定文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果管道符左侧的程序已经将标准重定向指向了其他文件，那么在bash中管道传输的数据将为空</span><br>[halc@Zephyrus ~]$ rg Word dict &amp;&gt;log | cat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时无输出</span><br>[halc@Zephyrus ~]$ cat log<br>Word1<br>Word2<br>Word3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是<span class="hljs-built_in">log</span>内应该是有内容匹配的</span><br></code></pre></td></tr></table></figure><h5 id="zsh下的重定向与管道传输"><a class="markdownIt-Anchor" href="#zsh下的重定向与管道传输"></a> zsh下的重定向与管道传输</h5><p>在自己实验的时候发现<code>zsh</code>下即使重定向了标准输出和错误输出依旧可以通过管道读取内容，这主要是zsh有一个可以将输出重定向给多个文件的特性，对于管道也会进行二次传递</p><blockquote><p>参考 <a href="https://stackoverflow.com/a/29783586">Redirection and pipe behavior in bash vs. zsh</a></p><blockquote><p>Read the MULTIOS documentation in the zshmisc man page. It’s a feature of zsh which causes it to redirect the output to multiple files at the same time, and it can also be a pipe.</p></blockquote></blockquote><p>具体举例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls &gt;a &gt;b<br></code></pre></td></tr></table></figure><p>上面这个命令在<code>bash</code>当中只有文件<code>a</code>会有内容，而<code>b</code>中并没有获取到标准输出。但是在<code>zsh</code>下执行上面的命令，则<code>a</code>和<code>b</code>中都会拥有相同的输出内容。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>missing-semester</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速部署rclone为services</title>
    <link href="/p/bbde595d.html"/>
    <url>/p/bbde595d.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ul><li><a href="https://jtxiao.com/main/posts/rclone/">Rclone配置</a></li><li><a href="https://www.guyrutenberg.com/2021/06/25/autostart-rclone-mount-using-systemd/">Autostart rclone mount using systemd</a></li></ul><h2 id="安装rclone"><a class="markdownIt-Anchor" href="#安装rclone"></a> 安装Rclone</h2><p>在Linux上安装<code>rclone</code>可以直接使用默认发行版仓库的版本，也可以官方脚本安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl https://rclone.org/install.sh | sudo bash<br></code></pre></td></tr></table></figure><h2 id="配置rclone"><a class="markdownIt-Anchor" href="#配置rclone"></a> 配置Rclone</h2><p>安装完成了之后通过输入以下指令可以在交互式页面当中添加、修改或删除连接信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rclone config<br></code></pre></td></tr></table></figure><h2 id="挂载和关闭挂载"><a class="markdownIt-Anchor" href="#挂载和关闭挂载"></a> 挂载和关闭挂载</h2><p>在配置完成之后，如果需要将<code>rclone</code>的内容挂载到本地，执行类似以下格式的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rclone mount remote_name:path/to/directory path/to/mount_point<br></code></pre></td></tr></table></figure><p>其中可以添加以下参数来对本地的文件进行缓存设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">--transfers：该参数控制最大同时传输任务数量，如果你cpu性能差，建议调低，但太低可能会影响多个文档同时传输的速度。<br>--buffer-size：该参数为读取每个文档时的内存缓冲区大小，控制rclone上传和挂载的时候的内存占用，调低点可以防止内存占用过高而崩溃，但太低可能会影响部分文档的传输速度。<br>--low-level-retries：该参数为传输文档没速度的时候重试次数，没速度的时候，单个会自动睡眠10ms起，然后再重试，不行，再睡眠更长一段时间，再重试，这样可以稍微加快文档上传进度。<br><br>下列参数主要是上传用的<br> --umask 0000 <br> --default-permissions <br> --allow-non-empty <br> --allow-other <br> --transfers 4 <br> --buffer-size 32M <br> --low-level-retries 200<br><br>如果你还涉及到读取使用，比如使用H5ai等在线播放，就还建议加3个参数，添加格式参考上面<br>--dir-cache-time 12h<br>--vfs-read-chunk-size 32M<br>--vfs-read-chunk-size-limit 1G<br>1. --vfs-cache-mode off<br>    - 所有文件操作全部直接进行<br>    - 失败无法自动重试<br>2. --vfs-cache-mode minimal<br>    - 读写模式打开的文件将会首先缓冲到磁盘<br>    - 其他模式打开文件直接进行操作<br>    - 失败无法自动重试<br>3. --vfs-cache-mode writes<br>    - 读写模式打开的文件将会首先缓冲到磁盘<br>    - 只写模式打开的文件将会首先缓冲到磁盘<br>    - 只读取模式打开的文件将会直接进行操作<br>    - 支持自动重试<br>4. --vfs-cache-mode full<br>    - 所有文件操作全部缓存<br>    - 读取会下载整个文件<br></code></pre></td></tr></table></figure><p>在挂载的时候可以添加<code>--deamon</code>参数来让rclone后台临时挂载，如果要取消挂载则输入以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fusermount -u path/to/mount_point<br></code></pre></td></tr></table></figure><h2 id="通过systemd自启动挂载"><a class="markdownIt-Anchor" href="#通过systemd自启动挂载"></a> 通过systemd自启动挂载</h2><p>如果需要配置开机自启动挂载对应的Rclone服务，只需要创建以下文件（以onedrive为例，参数和名字可自定义）：<code>~/.config/systemd/user/rclone-onedrive.service</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=OneDrive (rclone)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载在当前用户的~目录的OneDrive文件夹内，需要提前创建好~/OneDrive</span><br>AssertPathIsDirectory=%h/OneDrive  、<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Make sure we have network enabled</span><br>After=network.target<br><br>[Service]<br>Type=simple<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用vfs模式，将onedrive挂载给/home/xxx/OneDrive文件夹</span><br>ExecStart=/usr/bin/rclone mount onedrive:/ OneDrive --vfs-cache-mode full<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消挂载</span><br>ExecStop=/usr/bin/fusermount -zu %h/OneDrive<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Restart the service whenever rclone exists with non-zero <span class="hljs-built_in">exit</span> code</span><br>Restart=on-failure<br>RestartSec=15<br><br>[Install]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Autostart after reboot</span><br>WantedBy=default.target<br></code></pre></td></tr></table></figure><p>写入完成之后，通过执行以下两个指令在当前用户下生效该服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl --user daemon-reload<br>systemctl --user enable --now rclone-onedrive<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rclone</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结：2022年5月</title>
    <link href="/p/795cfa1d.html"/>
    <url>/p/795cfa1d.html</url>
    
    <content type="html"><![CDATA[<p>这个月算是找回了感觉，还算充实。</p><h2 id="做了的事情"><a class="markdownIt-Anchor" href="#做了的事情"></a> 做了的事情</h2><h3 id="学习方面"><a class="markdownIt-Anchor" href="#学习方面"></a> 学习方面</h3><p>这个月应该算是最平常的一个月了，整个人谈不上有动力，也谈不上完全摆烂。月初刚开始的时候把OSTEP上操作系统虚拟化的部分基本上写完了，然后就开始关注开源之夏项目申请相关的内容。在之前某个学长的推荐下看过一篇<code>xmake-clangd</code>配置vscode写<code>cpp</code>环境的知乎的帖子，当时对于<code>cpp</code>编译和链接相关的知识还完全没有概念，在开源之夏的时候模模糊糊搜了下<code>xmake</code>发现居然有项目能申请，就怂恿和<code>gofaquan</code>一起报了相关的项目。在五月底到六月初花了大概一百多RMB学习了<code>cpp</code>常见的一些项目管理会遇到的问题，感觉还蛮值的，希望最后项目申请能成功中标，给暑假的自己找点事情做。</p><p>学校也快到期末了，这学期的大作业还算应付的过来，大部分大作业都能组队解决，不能组队的也不算麻烦，基本上<code>1-2</code>天的时间也都能搞定，希望下个月的期末考试能一切顺利，别挂科。</p><h3 id="生活方面"><a class="markdownIt-Anchor" href="#生活方面"></a> 生活方面</h3><p>这个月主要的学习部分应该也就是上半个月和六月份初了。五月中旬的时候学校终于有了解封相关的信息，于是开始到处想办法出去吃，报复性消费了好几顿过度饮食，体重直接涨了十多斤。现在期末考试临近，也没有什么减肥的想法，打算在考试前可能就通过不断的摄入碳水来缓解压力了，减肥啥的还是等考完期末考试再说了XD。</p><p>然后就是每次考试前都日常想要有的报复性消费。这学期把自己之前<code>Niz</code>那个108键的键盘换成了68配位的。目前过渡到日常使用已经没什么问题了，后面看看能不能开发点新功能，再提高提高效率(<s>其实就是差生文具多</s>)</p><h2 id="六月份要做的事情"><a class="markdownIt-Anchor" href="#六月份要做的事情"></a> 六月份要做的事情</h2><h3 id="学习计划"><a class="markdownIt-Anchor" href="#学习计划"></a> 学习计划</h3><ul><li>希望期末考试算顺利复习完，不挂科</li><li>能熟悉<code>xmake</code>要导入的包相关源码</li></ul><h3 id="生活计划"><a class="markdownIt-Anchor" href="#生活计划"></a> 生活计划</h3><p>在期末考试结束以前是不指望有什么生活质量了，只能寄托希望给暑假的自己了</p><ul><li>减肥！至少恢复160-以下</li><li>调整自己的作息，打破在家必摆烂的心态（感觉不太可能）</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：分页的计算</title>
    <link href="/p/c1ec22c4.html"/>
    <url>/p/c1ec22c4.html</url>
    
    <content type="html"><![CDATA[<h2 id="第二十章分页较小的表"><a class="markdownIt-Anchor" href="#第二十章分页较小的表"></a> 第二十章：分页：较小的表</h2><ol><li><p>对于线性页表，只要知道第一个<code>Page</code>的地址，存于寄存器当中，就可以通过这个地址依次陆续推算下一个或后面任意一个有效的地址范围。对于多级页表，通过多次搜索，依旧可以在只有最初的页表的地址的情况下，通过多次的偏移查询来定位到最后需要的特定地址。</p></li><li><p>这里取例子说明算法，具体答案通过<code>-c</code>参数可直接输出</p><p>这里以<code>seed</code>为<code>0</code>的时候为例</p><p>首先，在<code>README.md</code>中可以得到以下信息</p><ul><li>Page Size: 32 bytes</li><li>Virtual Address Space：32 KB(1024个分页 2^15)<ul><li>虚拟地址需要 15 bits (<code>VPN</code> 占 10 bit，<code>offset</code> 占 5 bit)</li></ul></li><li>Physical Memory: 128个分页(2^12)<ul><li>物理地址需要 12 bits (<code>PFN</code> 占 7bit, <code>offset</code> 占 5 bit )</li></ul></li><li>Virtual Address Space 的前五位对应了<code>Page Directory</code>的索引</li></ul><p>通过<code>seed</code>生成<code>0</code>对应的地址数据，用于<code>PDE</code>查表，内容如下</p> <details> <summary>Page Content</summary>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs sh">page   0:1b1d05051d0b19001e00121c1909190c0f0b0a1218151700100a061c06050514<br>page   1:0000000000000000000000000000000000000000000000000000000000000000<br>page   2:121b0c06001e04130f0b10021e0f000c17091717071e001a0f0408120819060b<br>page   3:7f7f7f7fcd7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f887f7f7f7f7f7f7f7fb9<br>page   4:0b041004051c13071b131d0e1b150107080507071b0e1b0411001c000c181e00<br>page   5:17131d0a1202111906081507081d1e041b1101121301171902140e070e040a14<br>page   6:0000000000000000000000000000000000000000000000000000000000000000<br>page   7:0000000000000000000000000000000000000000000000000000000000000000<br>page   8:11101a120f10180a11151e151d0c12170a081e0a1e1a06191e08141702190915<br>page   9:0000000000000000000000000000000000000000000000000000000000000000<br>page  10:0000000000000000000000000000000000000000000000000000000000000000<br>page  11:0910141d04011a18170e150c050c18181d1b151016051c16120d13131b11060d<br>page  12:060b16191c05141d01141a0a07120d050e0c110f090b19071100160a0108071d<br>page  13:19100b0e000614140f1d0e091a08121519180b0101161d0a0d16140814090b10<br>page  14:1218140b000d1c0a07040f10020c141d0d0d0e060c140c12191e1b0b00120e07<br>page  15:0000000000000000000000000000000000000000000000000000000000000000<br>page  16:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fea7f7f7f<br>page  17:0000000000000000000000000000000000000000000000000000000000000000<br>page  18:7f7f7f7f7f7fab7f7f7f8e7f7f7fdd7f7f7f7f7f7f7f8b7f7f7f7f7f7f7f7f7f<br>page  19:00130001061402011e0d1b060d0b050a1e170b0c081016150e011c0c0c00041a<br>page  20:1a190402020c1d110807030419041a190411001a11170f151c111b0a03000719<br>page  21:0b081b0e1c151e121e050d111e111a130f0c0b09061d101a1b1d070a13090417<br>page  22:1212150f081b0a0e130f1d1d1c1c120f150608010500140418151e0c1c0e0a03<br>page  23:1d0f030b0c0f1e1e1113140f0f091502091b071d1e110102060a03180b07010b<br>page  24:0000000000000000000000000000000000000000000000000000000000000000<br>page  25:03031c031b0e0e0a0c0b110a1907070e1c0016000c170d0d070e070814121c1e<br>page  26:090e1d18081115180d0c170d070e1d040e130e06001513000917131004150e15<br>page  27:0000000000000000000000000000000000000000000000000000000000000000<br>page  28:0f1d0f0a0211070b0b17071d170e1b0b0b04180c0f0e140b1c0d0b0c171e1a0e<br>page  29:17081e031b010710120c030708171c120118090a10071c050c08101113100c13<br>page  30:7f7f7f7f7f847f7f7f7f977fbd7f7ff47f7f7f7f7f7f7f7f7f7f7f7f7f7f9c7f<br>page  31:7f7f7f7f7f7fd07f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  32:0000000000000000000000000000000000000000000000000000000000000000<br>page  33:7f7f7f7f7f7f7f7fb57f9d7f7f7f7f7f7f7f7f7f7f7f7f7f7f7ff6b17f7f7f7f<br>page  34:0413050d0c02161518101105060710190b1b16160a031d1a0c1a1b0a0f0a151c<br>page  35:0000000000000000000000000000000000000000000000000000000000000000<br>page  36:1d1313160c0c1400050a07130b1b110c0c150c14010d0804100f11171b0f090e<br>page  37:1e0f0a0d0c100c021e1e05070d15001913081a1409101e01151a150412180c12<br>page  38:0000000000000000000000000000000000000000000000000000000000000000<br>page  39:1b111e171108150e160c0f001601151218081506100a1e1e06110a1e1c121615<br>page  40:0d030b1007190b0709191c1d0017100307080c0e1d01151a0b07060904110700<br>page  41:7f7f7f7f7f7f7f7fe57f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f8d7f7f7f7f7f<br>page  42:03041501111c1015001312110c0b1e01001d050306181d000d030806140a050f<br>page  43:190802041311011e0e0916000d141d171b030d00080b0a0b180519100a11050f<br>page  44:7f7f7f7f7f7fcc7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fa27f7f7f7f7f7f<br>page  45:7fb27fef7f7f7f7fa4f57f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  46:0000000000000000000000000000000000000000000000000000000000000000<br>page  47:070a0f1002090b0c0e0d020613190f0402040b111410110a14160c19171c0e0a<br>page  48:0000000000000000000000000000000000000000000000000000000000000000<br>page  49:1e0a0f0702030d13101003010b1d05080e1c1d00140714171b151a1804011610<br>page  50:161b040706011a0f020d0d181704130f0004140b1d0f15040e1619060c0e0d0e<br>page  51:14000f1a070a1a0511071d180d02090f1c0311151019101d12120d120b110905<br>page  52:0000000000000000000000000000000000000000000000000000000000000000<br>page  53:0f0c18090e121c0f081713071c1e191b09161b150e030d121c1d0e1a08181100<br>page  54:1901050f031b1c090d11081006090d121008070318031607081614160f1a0314<br>page  55:0000000000000000000000000000000000000000000000000000000000000000<br>page  56:0000000000000000000000000000000000000000000000000000000000000000<br>page  57:1c1d1602020b000a001e19021b0606141d03000b00121a05030a1d041d0b0e09<br>page  58:0000000000000000000000000000000000000000000000000000000000000000<br>page  59:0000000000000000000000000000000000000000000000000000000000000000<br>page  60:0000000000000000000000000000000000000000000000000000000000000000<br>page  61:010510020c0a0c031c0e1a1e0a0e150d09161b1c130b1e1302021701000c100d<br>page  62:7f7f7fa87f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  63:0612060a1d1b19010407181a12161902021a010601001a0a0404141e0f1b0f11<br>page  64:18121708080d1e161d10111e0518181a1704141c110b1d110c13180700101d15<br>page  65:7f7f7f7f7f7f7f7f7f7f997f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  66:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fd77f7f<br>page  67:0000000000000000000000000000000000000000000000000000000000000000<br>page  68:121216020f060c0f0a0c16011d120511020f150d09141c1b0b1a03011e171311<br>page  69:190a19020d0a0d190f1e1a03090016001b050c01090c0117160b1902010b1b17<br>page  70:0000000000000000000000000000000000000000000000000000000000000000<br>page  71:7f7f7f7f7f7f7f7f7f7f7f857f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  72:180c0018050c0b030a051314000e111b0f02011a181a081402190a1d0e011c13<br>page  73:0000000000000000000000000000000000000000000000000000000000000000<br>page  74:0d0b1e08180d0b011a151b0d14030c06011d0604060b10041e1e040c151b0f1c<br>page  75:1a1c011b00141c0f0c0a1c1c13160a041e14081e120a1b021804030816120d04<br>page  76:0c11150c1b1d1e01191b041d03061d191108070c0013011702000817190f1d03<br>page  77:1c061606001b1a0205071c0b190d0b171308121519141312021d16081513140b<br>page  78:0e02171b1c1a1b1c100c1508191a1b121d110d141e1c1802120f131a07160306<br>page  79:1e1b1516071708030e0a050d1b0d0d1510041c0d180c190c06061d12010c0702<br>page  80:1b081d1c020d170d0f19151d051c1c131d071b171202000007170b18130c1b01<br>page  81:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fe27f7f7f7f7f7f7f7f7f7f7f7f7ffa<br>page  82:0000000000000000000000000000000000000000000000000000000000000000<br>page  83:0000000000000000000000000000000000000000000000000000000000000000<br>page  84:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f947f7f7f7f7fce<br>page  85:7f7f7f7f7f7f7f7f9a7fbf7f7f7f7f7f7f7f7f7faf7f7f7f7f7f7f7f7f7f7f7f<br>page  86:7f7f7f7f7f7f7fc57f7f7f7f7f7f7f7f7f7f7f7fca7f7fee7f7f7f7f7f7f7f7f<br>page  87:1805180d170e1802011c0f1b1d14110602191b18150d09030d111c1d0c031716<br>page  88:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fc47f7f7f7f7f7f7f7f7f7f7f7f<br>page  89:0000000000000000000000000000000000000000000000000000000000000000<br>page  90:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fc07f7f7f7f7f7f7f7fde7f7f7f7f7f7f<br>page  91:7f7f7f7f7f7f7f7f7f7f7f7fa57f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  92:0000000000000000000000000000000000000000000000000000000000000000<br>page  93:0a1a1907001905181505021c12130e0412071816001c01020904070b160c080f<br>page  94:1406190710140713080519110a1200040c1e0f021718181115061619170a1213<br>page  95:0a1d0f1d1e1915040012151d10151406131e0315130b18001b190e030e12070f<br>page  96:7f7f7f7f7f7f7f7f7f7f7f7f7f7fb67f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page  97:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fc87f7f7f7f7fe77f7f7f7f7f7f7f7f7f<br>page  98:15191803171a170e1503170818130f100201001804030b1e1b0919020c111e01<br>page  99:090b1304150b1204140a0e0c0e1509140109170113000e1b0010021a15171400<br>page 100:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fa77f7f7f7f7f7f7f7f7f7fe37f7f<br>page 101:0e0a00010b061005061416091a070a16011c020e1601191e0e030203170c1c0d<br>page 102:1d031b0116000d1a0c1c1612050a0c121e080f1c0a13171317061d0512091309<br>page 103:1e171c061012190e180c121a181400050f07021a1d090c19011303081901010c<br>page 104:7f7f7f7f7f7f7f7f7f7f7f7f80aa7f7f7f7f7f7f7f7f7f7f7f7f7f7ff07f7f7f<br>page 105:b37f7f7f7f7f7f7f7f7f7f7f7f937f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page 106:160a000e1001110a00050310011c1a1d091c1e170814120c090103040e131701<br>page 107:7f7f7f7f7f7f7f7f7f7f7f7f7f7ff17f7f7f7f7f7f7f7f7ff37f7f7f7f7f7f7f<br>page 108:83fee0da7fd47febbe9ed5ade4ac90d692d8c1f89fe1ede9a1e8c7c2a9d1dbff<br>page 109:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f827f7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page 110:1614041e0c120b010e0401131303110a0b180f1b120e130a03151318031c181c<br>page 111:08000115111d1d1c01171514161b130b10061200040a18160a1301051e080c11<br>page 112:19051e1302161e0c150906160019100303141b081e031a0c02080e181a041014<br>page 113:1d07111b1205071e091a181716181a01050f06100f03020019021d1e170d080c<br>page 114:0000000000000000000000000000000000000000000000000000000000000000<br>page 115:110601040d1406151a170d141e1b0a1505110b0d0d141a0e0417171d0c0e101b<br>page 116:0a130b11150f14171a05060f0f19101b180f190e0a0d0e1401161e0e02060307<br>page 117:1b0a170019111d0b130a18121e000401031c1d0e1d19181705110d1d05051404<br>page 118:1119021a1c05191a1b101206150c00040c1b111c1c02120a0f0e0e03190f130e<br>page 119:0000000000000000000000000000000000000000000000000000000000000000<br>page 120:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fcb7f7f7f7f7f7f7f7f7f7f7f7f7f<br>page 121:0000000000000000000000000000000000000000000000000000000000000000<br>page 122:051e0312041b1d18090717090d01040002020d1116040d13020d0b1d010c0c16<br>page 123:0000000000000000000000000000000000000000000000000000000000000000<br>page 124:0000000000000000000000000000000000000000000000000000000000000000<br>page 125:0000000000000000000000000000000000000000000000000000000000000000<br>page 126:7f7f7f7f7f7f7f7f8ce6cf7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f967f7f7f7f7f<br>page 127:7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7fdf7f7f7f7f7f7f7f7f7f7f7f7f957f7f<br></code></pre></td></tr></table></figure> </details><p>并且根据模拟生成的<code>PDBR: 108</code>可以知道<code>Page 108</code>对应的内容即是第一级<code>PDE</code>的映射</p><p>接下来就可以进行计算了，这里取一个<code>vaild</code>和<code>invaild</code>的答案分析计算过程</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Virtual Address 611c:<br>  --&gt; pde index:0x18 [decimal 24] pde contents:0xa1 (valid 1, pfn 0x21 [decimal 33])<br>    --&gt; pte index:0x8 [decimal 8] pte contents:0xb5 (valid 1, pfn 0x35 [decimal 53])<br>      --&gt; Translates to Physical Address 0x6bc --&gt; Value: 08<br>Virtual Address 3da8:<br>  --&gt; pde index:0xf [decimal 15] pde contents:0xd6 (valid 1, pfn 0x56 [decimal 86])<br>    --&gt; pte index:0xd [decimal 13] pte contents:0x7f (valid 0, pfn 0x7f [decimal 127])<br>      --&gt; Fault (page table entry not valid)<br></code></pre></td></tr></table></figure><p>Virtual Address <code>611c</code></p><ol><li><p>将611c按二进制转换为<code>Virtual Address Space</code>对应的 15 bits 为 <code>11000 01000 11100</code>。对<code>PDE</code>分割前五位有<code>11000(decimal 24)</code></p></li><li><p>这个时候对最顶层的<code>PDTR</code>对应的<code>Page 108</code>进行查表操作</p></li></ol><p>首先可以通过<code>Page Content</code>得到<code>Page 108</code>内容如下</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Page 108: 83 fe e0 da 7f d4 7f eb be 9e d5 ad e4 ac 90 d6 92 d8 c1 f8 9f e1 ed e9 a1 e8 c7 c2 a9 d1 db ff<br>Index:    0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31<br></code></pre></td></tr></table></figure><p>通过查表找到对应<code>Index</code>的内容可以知道<code>24(11000)</code>对应位置的内容是<code>a1</code>，转换为二进制为<code>1010 0001</code>，读取最高位为<code>1</code>可以知道是<code>vaild</code>。再通过后面的<code>0010 0001</code>转换为十进制为<code>33</code>，因此再继续查询<code>Page 33</code>的内容</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Page 33:7f 7f 7f 7f 7f 7f 7f 7f b5 7f 9d 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f f6 b1 7f 7f 7f 7f<br>Index:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31<br></code></pre></td></tr></table></figure><p><code>611c</code>的[1-5]位为<code>PDE</code>，这时我们则需要通过[6-10]位来通过<code>PTE</code>寻找<code>VPN</code>对应的<code>PFN</code>地址。由<code>611c</code>为<code>11000 01000 11100</code>可以知道这次为<code>01000</code>即<code>(decmial 8)</code>，对照上面<code>page 33</code>可以发现第八个对应的内容为<code>53</code>，因此可以知道最终<code>VPN</code>对应上了<code>PFN</code>的<code>Page 53</code>。最后再通过<code>offset</code>的<code>11100</code>，配合<code>Page 53</code>对应的二进制<code>PFN</code>地址<code>11 0101</code>结合<code>offset</code>的<code>11100</code>有<code>110101 11100</code>，也就是最后答案的<code>0x6bc</code>，其中通过<code>offset</code>在<code>Page 53</code>中查表可以找到对应的 <code>Value</code> 为 <code>08</code></p><p>Virtual Address <code>3da8</code></p><ol><li><p>和<code>611c</code>同理，将<code>3da8</code>转为二进制<code>01111 01101 01000</code>，得到<code>pde index</code>为<code>01111(15)</code>，对应的<code>Value</code>为<code>0xd6(1101 0110)</code>，通过<code>1101 0110</code>最高位可以知道目标分页为<code>vaild</code>，去掉<code>vaild bit</code>可以得到索引的<code>pte</code>为<code>0x56(0101 0110 | 86)</code></p></li><li><p>检索<code>Page 86</code>，由<code>PTE index</code>为<code>01101</code>可以找到对应的<code>Value</code>为<code>0x7f(0111 1111)</code>由于最高位为<code>0</code>，因此是<code>invaild</code>，也就是说<code>pte</code>无效，无法访问</p></li></ol><p>其他的情况也是依次类推，即可算出结果是否有效</p></li><li><p>根据个人理解，具体缓存<code>hit</code>或<code>miss</code>的概率主要由对应内存上的数据决定。对于访问次数较多的内容<code>hit</code>缓存加快速度的概率自然更高；而对于不重复的多次查询（比如上面的练习），自然<code>miss</code>的概率会更高。因此对于进程来说，如果能将数据尽量集中在某一块分页上则能有效提高内存访问和处理的速度。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：TLB缓存命中和非命中的开销差距</title>
    <link href="/p/20416971.html"/>
    <url>/p/20416971.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十九章实际操作系统的tlb表项"><a class="markdownIt-Anchor" href="#第十九章实际操作系统的tlb表项"></a> 第十九章：实际操作系统的TLB表项</h2><p>本章为测量实验，主要要求为写一份<code>tlb.c</code>来测试在<code>TLB miss</code>和<code>TLB hit</code>的情况下性能开销的变化，以感受<code>TLB</code>的重要性</p><p>对于题中问题的回答</p><ol><li><p>由于<code>gettimeofday()</code>的函数只能精确到微秒，不足以测试较为精确的时间，因此使用<code>CLOCK_PROCESS_CPUTIME_ID</code>和<code>clock_gettime();</code>搭配即可获得纳秒级的时间测量，具体代码实现如下</p></li><li><p>具体代码实现如下</p><details><summary>tlb.c</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 将进程锁定在某个固定CPU上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lockCpu</span><span class="hljs-params">(<span class="hljs-type">int</span> cpuId)</span><br>&#123;<br>   <span class="hljs-type">cpu_set_t</span> mask;<br>   CPU_ZERO(&amp;mask);<br>   CPU_SET(cpuId, &amp;mask);<br>   <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mask), &amp;mask) &lt; <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;set thread affinity failed\n&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>   <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>   &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: ./tlb pages trials&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>   &#125;<br><br>   <span class="hljs-comment">// 将进程锁定在CPU0上</span><br>   lockCpu(<span class="hljs-number">0</span>);<br><br>   <span class="hljs-comment">// 申请页的数量</span><br>   <span class="hljs-type">int</span> page_numebr = atoi(argv[<span class="hljs-number">1</span>]);<br>   <span class="hljs-type">int</span> trials = atoi(argv[<span class="hljs-number">2</span>]);<br><br>   <span class="hljs-keyword">if</span> (page_numebr &lt;= <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Invaild Input&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>   &#125;<br><br>   <span class="hljs-type">int</span> jump = sysconf(_SC_PAGE_SIZE) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">start</span>, <span class="hljs-title">end</span>;</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">start_hit</span>, <span class="hljs-title">end_hit</span>;</span><br><br>   <span class="hljs-type">int</span> sum_miss = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> sum_hit = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">while</span> (trials--)<br>   &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step = <span class="hljs-number">0</span>; step &lt; page_numebr * jump; step += jump)<br>      &#123;<br>            cnt++;<br>            <span class="hljs-type">int</span> *<span class="hljs-built_in">array</span> = <span class="hljs-built_in">calloc</span>(page_numebr, getpagesize());<br><br>            <span class="hljs-comment">// 计算TLB miss的时间</span><br>            clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;start);<br>            <span class="hljs-built_in">array</span>[step] += <span class="hljs-number">0</span>;<br>            clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end);<br>            sum_miss += end.tv_nsec - start.tv_nsec;<br><br>            <span class="hljs-comment">// 计算TLB hit的时间</span><br>            clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;start_hit);<br>            <span class="hljs-built_in">array</span>[step + <span class="hljs-number">1</span>] += <span class="hljs-number">0</span>;<br>            clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;end_hit);<br>            sum_hit += end_hit.tv_nsec - start_hit.tv_nsec;<br>            <span class="hljs-built_in">free</span>(<span class="hljs-built_in">array</span>);<br>      &#125;<br>   &#125;<br>   <span class="hljs-type">int</span> miss_average = sum_miss / cnt;<br>   <span class="hljs-type">int</span> hit_average = sum_hit / cnt;<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time per access(TLS miss): %d\n&quot;</span>, miss_average);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time per access(TLS hit): %d\n&quot;</span>, hit_average);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><p>该程序主要思路为</p><ol><li>统计访问内存需要的总时间</li><li>首先统计<code>TLB miss</code>的情况，在<code>miss</code>之后<code>TLB</code>被激活</li><li>统计对应分页内存的后一位，此时<code>TLB hit</code>，能够成功快速定位</li><li>将总时间除以操作的总次数，得到最后的平均每次时间（单位为<code>ns</code>）</li></ol><p>大致结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; ./tlb 1000 10<br>Time per access(TLS miss): 2105<br>Time per access(TLS hit): 223<br></code></pre></td></tr></table></figure><p>可以明显发现未命中的时候访问时间要远高于<code>TLB hit</code>时的时间</p></li><li><p>通过<code>Python</code>对<code>tlb</code>进行调用，大致结果为<code>4.</code>的效果</p></li><li><p>统计结果如下</p><p><img src="https://lsky.halc.top/ZAwW4O.png" alt="TLB统计" /></p><p>其中蓝色对应<code>TLB miss</code>的时间，橙色对应了<code>TLB hit</code>的开销时间</p><p>Python画图代码如下</p><details><summary>Matplotlib</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execRelocation</span>(<span class="hljs-params">page_number, trival</span>):<br>   r = os.popen(<br>      <span class="hljs-string">&#x27;./tlb %d %d&#x27;</span> % (page_number, trival))<br>   text = r.read()<br>   pattern = <span class="hljs-string">r&quot;(\d+)&quot;</span><br>   tlb = re.findall(pattern, text)<br>   r.close()<br>   <span class="hljs-keyword">return</span> tlb<br><br><br>page_number = sys.argv[<span class="hljs-number">1</span>]<br>trival = sys.argv[<span class="hljs-number">2</span>]<br>    <br>hit_time_access = []<br>miss_time_access = []<br>vpn_n = []<br>    <br><span class="hljs-keyword">for</span> vpn <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(page_number), <span class="hljs-number">128</span>):<br>   <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(vpn) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(page_number))<br>   tlb = execRelocation(vpn, <span class="hljs-built_in">int</span>(trival))<br>   hit_time_access.append(<span class="hljs-built_in">int</span>(tlb[<span class="hljs-number">0</span>]))<br>   miss_time_access.append(<span class="hljs-built_in">int</span>(tlb[<span class="hljs-number">1</span>]))<br>   vpn_n.append(vpn)<br>    <br>plt.xlabel(<span class="hljs-string">&quot;Virtual Page Number&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Time Per Access&quot;</span>)<br>    <br>plt.scatter(vpn_n, hit_time_access, label=<span class="hljs-string">&quot;Hit&quot;</span>)<br>plt.scatter(vpn_n, miss_time_access, label=<span class="hljs-string">&quot;Miss&quot;</span>)<br>    <br>plt.savefig(<span class="hljs-string">&quot;./paging.png&quot;</span>)<br></code></pre></td></tr></table></figure></details></li><li><p>添加<code>-O0</code>的参数可以防止<code>gcc</code>在编译的时候不进行优化</p><p>示例如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -O0 tlb.c -o tlb<br></code></pre></td></tr></table></figure></li><li><p>在<a href="./2022-03-25-ostep_hw_3.md">上下文切换</a>时，解决方案为使用<code>Docker</code>创建一个单核的虚拟机来进行实验操作，这次实验中，使用<code>sched_setaffinity</code>函数来设置进程对CPU亲和力，以让程序在某一单一CPU上运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 将进程锁定在某个固定CPU上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lockCpu</span><span class="hljs-params">(<span class="hljs-type">int</span> cpuId)</span><br>&#123;<br>   <span class="hljs-type">cpu_set_t</span> mask;<br>   CPU_ZERO(&amp;mask);<br>   CPU_SET(cpuId, &amp;mask);<br>   <span class="hljs-keyword">if</span> (sched_setaffinity(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mask), &amp;mask) &lt; <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;set thread affinity failed\n&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过使用<code>calloc()</code>函数，可以在对堆内的变量进行分配内存的同时进行初始化操作，并且在每一次循环进行之前都销毁数组重新创建，可以减少对实验测试的影响</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：分页的原理</title>
    <link href="/p/44838b9c.html"/>
    <url>/p/44838b9c.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十八章分页介绍"><a class="markdownIt-Anchor" href="#第十八章分页介绍"></a> 第十八章：分页介绍</h2><ol><li><p>在虚拟地址中，<code>vpn</code>=<code>address space size</code>/<code>page size</code>. 所以在分页大小不变的情况下增加址空间大小会增加分页数量，在地址空间大小不变的情况下增加分页大小会减少分页数量。</p><p>如果使用了很大的分页，当程序只需要很小一部分内存的时候依旧会申请过大的内存，造成不必要的内存浪费</p></li><li><p>每次当某个分页被地址空间使用后，<code>PTE</code>中对应的<code>Vaild Bit</code>就会置为<code>1</code>。当提高<code>used paged</code>数量后，操作系统总是能找到<code>vpn</code>对应的<code>pfn</code></p></li><li><p>在这三种分配来说，前两种分页的大小相对于地址空间本身来说太大了，而在第三个例子当中，相对于<code>256m</code>，修改分页大小<code>1m</code>为更小的值将更加有助于提高空间的利用效率。</p></li><li><p>首先，地址空间和物理空间的大小都要是分页大小的倍数，其次，物理空间必须要比地址空间更大，否则会无法访问对应的地址空间。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：内存碎片的管理</title>
    <link href="/p/3d85131.html"/>
    <url>/p/3d85131.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十七章空闲空间管理"><a class="markdownIt-Anchor" href="#第十七章空闲空间管理"></a> 第十七章：空闲空间管理</h2><ol><li><p>执行题目给出的参数可以得到以下内容</p> <details> <summary> answer </summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs log">seed 0<br>size 100<br>baseAddr 1000<br>headerSize 0<br>alignment -1<br>policy BEST<br>listOrder ADDRSORT<br>coalesce False<br>numOps 10<br>range 10<br>percentAlloc 50<br>allocList<br>compute True<br><br>ptr[0] = Alloc(3) returned 1000 (searched 1 elements)<br>Free List [ Size 1 ]: [ addr:1003 sz:97 ]<br><br>Free(ptr[0])<br>returned 0<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1003 sz:97 ]<br><br>ptr[1] = Alloc(5) returned 1003 (searched 2 elements)<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1008 sz:92 ]<br><br>Free(ptr[1])<br>returned 0<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:92 ]<br><br>ptr[2] = Alloc(8) returned 1008 (searched 3 elements)<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1016 sz:84 ]<br><br>Free(ptr[2])<br>returned 0<br>Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br><br>ptr[3] = Alloc(8) returned 1008 (searched 4 elements)<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1016 sz:84 ]<br><br>Free(ptr[3])<br>returned 0<br>Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br><br>ptr[4] = Alloc(2) returned 1000 (searched 4 elements)<br>Free List [ Size 4 ]: [ addr:1002 sz:1 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br><br>ptr[5] = Alloc(7) returned 1008 (searched 4 elements)<br>Free List [ Size 4 ]: [ addr:1002 sz:1 ][ addr:1003 sz:5 ][ addr:1015 sz:1 ][ addr:1016 sz:84 ]<br></code></pre></td></tr></table></figure> </details><p>这里以开头两段为例子分析，后面的算法相同</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs log">ptr[0] = Alloc(3) returned 1000 (searched 1 elements)<br>Free List [ Size 1 ]: [ addr:1003 sz:97 ]<br><br>Free(ptr[0])<br>returned 0<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1003 sz:97 ]<br><br>ptr[1] = Alloc(5) returned 1003 (searched 2 elements)<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1008 sz:92 ]<br><br>Free(ptr[1])<br>returned 0<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:92 ]<br></code></pre></td></tr></table></figure><p>首先，根据开头参数可以知道目前分配方式不考虑<code>Header</code>头指针，并且不考虑内存合并</p><p><code>ptr[0] = Alloc(3)</code>会从<code>1000</code>开始分配大小为<code>3</code>的内存(此时空间足够，分配成功)，并返回<code>1000</code>的地址作为开头。此时空闲空间<code>Free List</code>只有一块，从<code>1003</code>开始，总大小为<code>97</code></p><p>之后的<code>Free(ptr[0])</code>则将刚刚分配的内存释放，释放后由于并未合并，因此出现了<code>[3]-&gt;[97]</code>的空闲空间表，之后再进行<code>ptr[1] = Alloc(5)</code>。由于第一个空闲空间为<code>[3]</code>不足以容纳<code>[5]</code>的分配，因此第二个空间是从<code>1003</code>作为内存开始的地址，并使用了<code>5</code>的内存空间</p><p>然后再进行<code>Free(ptr[1])</code>的操作释放内存并且不合并，则有了<code>[3]-&gt;[5]-&gt;[92]</code>的空闲可用空间。后面的运算以此类推</p><p>如果出现了在空闲的大内存中分配了新的小内存</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs log">ptr[4] = Alloc(2) returned 1000 (searched 4 elements)<br>Free List [ Size 4 ]: [ addr:1002 sz:1 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br></code></pre></td></tr></table></figure><p>则占用部分内存后，新的剩余内存将被作为新的内存段保留使用，并且已分配内存也会产生新的内存碎片</p></li><li><p>使用最差匹配有如下输出</p> <details> <summary> answer </summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs log">seed 0<br>size 100<br>baseAddr 1000<br>headerSize 0<br>alignment -1<br>policy WORST<br>listOrder ADDRSORT<br>coalesce False<br>numOps 10<br>range 10<br>percentAlloc 50<br>allocList<br>compute True<br><br>ptr[0] = Alloc(3) returned 1000 (searched 1 elements)<br>Free List [ Size 1 ]: [ addr:1003 sz:97 ]<br><br>Free(ptr[0])<br>returned 0<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1003 sz:97 ]<br><br>ptr[1] = Alloc(5) returned 1003 (searched 2 elements)<br>Free List [ Size 2 ]: [ addr:1000 sz:3 ][ addr:1008 sz:92 ]<br><br>Free(ptr[1])<br>returned 0<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:92 ]<br><br>ptr[2] = Alloc(8) returned 1008 (searched 3 elements)<br>Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1016 sz:84 ]<br><br>Free(ptr[2])<br>returned 0<br>Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br><br>ptr[3] = Alloc(8) returned 1016 (searched 4 elements)<br>Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1024 sz:76 ]<br><br>Free(ptr[3])<br>returned 0<br>Free List [ Size 5 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:8 ][ addr:1024 sz:76 ]<br><br>ptr[4] = Alloc(2) returned 1024 (searched 5 elements)<br>Free List [ Size 5 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:8 ][ addr:1026 sz:74 ]<br><br>ptr[5] = Alloc(7) returned 1026 (searched 5 elements)<br>Free List [ Size 5 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:8 ][ addr:1033 sz:67 ]<br></code></pre></td></tr></table></figure> </details><p>比对可以发现，在最差匹配的情况下，第二次重复分配<code>8</code>大小的空间时不会重复利用本身空闲的长度为<code>8</code>的空间，而是依旧从后面的最大空闲空间中分配<code>8</code>大小的空间出来，此时地址从<code>1024</code>开始分配，并且<code>1008</code>开头的地址不会被复用</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff">Free(ptr[2])<br>returned 0<br>Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1016 sz:84 ]<br><br><span class="hljs-comment">--- BEST</span><br><span class="hljs-deletion">- ptr[3] = Alloc(8) returned 1008 (searched 4 elements)</span><br><span class="hljs-deletion">- Free List [ Size 3 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1016 sz:84 ]</span><br><br><span class="hljs-comment">+++ WORSE</span><br><span class="hljs-addition">+ ptr[3] = Alloc(8) returned 1016 (searched 4 elements)</span><br><span class="hljs-addition">+ Free List [ Size 4 ]: [ addr:1000 sz:3 ][ addr:1003 sz:5 ][ addr:1008 sz:8 ][ addr:1024 sz:76 ]</span><br></code></pre></td></tr></table></figure></li><li><p>在使用<code>FIRST</code>进行匹配的情况下，空间分配的情况与<code>BEST</code>无异，在本例题示范当中，由于<code>FIRST</code>是找到可以用的内容后直接进行匹配，而示例当中恰好所有可用空间最小的情况匹配了<code>FIRST</code>的情况，因此只有搜索的次数变少，效率变快，其他差异不大。</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+ policy FIRST</span><br><span class="hljs-comment">---</span><br><span class="hljs-deletion">- policy BEST</span><br><br><span class="hljs-addition">+ ptr[3] = Alloc(8) returned 1008 (searched 3 elements)</span><br><span class="hljs-comment">---</span><br><span class="hljs-deletion">- ptr[3] = Alloc(8) returned 1008 (searched 4 elements)</span><br><br><span class="hljs-addition">+ ptr[4] = Alloc(2) returned 1000 (searched 1 elements)</span><br><span class="hljs-comment">---</span><br><span class="hljs-deletion">- ptr[4] = Alloc(2) returned 1000 (searched 4 elements)</span><br><br><span class="hljs-addition">+ ptr[5] = Alloc(7) returned 1008 (searched 3 elements)</span><br><span class="hljs-comment">---</span><br><span class="hljs-deletion">- ptr[5] = Alloc(7) returned 1008 (searched 4 elements)</span><br></code></pre></td></tr></table></figure></li><li><p>三种不同的参数分别对应了以下三种不同的内存分配方式</p><ul><li><code>ADDSORT</code>: 空闲的地址在搜索的时候是按地址的顺序进行排序搜索</li><li><code>SIZESORT-</code>: 空闲的地址在搜索的时候按地址块的大小，先搜索大的，后搜索小的</li><li><code>SIZESORT+</code>: 空闲的地址在搜索的时候按地址快的大小，先搜索小的，后搜索大的</li></ul><p>由于<code>BEST</code>和<code>WORSE</code>分配的方法都需要把所有内存段全部搜索后再分配，因此在根据这两种不同的调度之后产生的内存碎片的数量是相同的。在三种不同的调度中采取<code>FIRST</code>控制空闲变量则将会造成比较大的影响。对于<code>SIZESORT-</code>的情况来说，由于未分配的大块内存一直在最前面，因此很容易在反复删除小内存段的过程中不断积累内存碎片；优点是每次直接扫描的第一个就将是可以直接使用的内存，搜索的次数明显减少。采用<code>SIZESORT+</code>的情况下，由于小碎片都积累在前面，因此如果此时遇到比较大块的内存需要分配时，则会增加需要搜索的内存段数量，时间会增加；优点是每次分配的时候都尽量先匹配比较小的内存段，对于多次分配小内存的情况来说，不会那么容易产生浪费。</p></li><li><p>首先，如果对内存段不采用合并处理的话，随着时间推移，内存碎片将会越来越多，并且后面能够成功分配内存需要的搜索次数以及成功概率都会升高。其次，由于内存合并是在地址连续的基础上才会进行合并，因此如果采用了<code>SIZESORT</code>的分配方法，打乱了地址的顺序，虽然依旧有成功合并的可能，但是效率还是要低于以<code>ADDRSORT</code>方法对空闲内存段进行排序。</p></li><li><p>如果<code>-P</code>设置的太高，模拟的则是在平时写程序的过程中一直不对申请的内存空间进行<code>Free</code>释放，则会导致空间过早的就被使用完毕，后续无法再继续分配，设置的低的情况下则代表了内存每次使用分配完毕以后都立即释放，这样就能够一直有空闲的内存等待分配。</p></li><li><p>如果要生成高度碎片化的空间，只要让空闲的空间碎片始终不被合并，并且分配的时候根据上述中第四题得到的规律增加搜索次数，让即使被<code>Free</code>的内存块也无法被使用或增加使用次数即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qBittorrent与jellyfin搭建自动追番引导</title>
    <link href="/p/8d2011c6.html"/>
    <url>/p/8d2011c6.html</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h2><ul><li>Docker Engine: <code>20.10.15</code></li><li>Ubuntu: <code>20.04.4 LTS</code></li><li>X86平台</li></ul><h2 id="部署教程"><a class="markdownIt-Anchor" href="#部署教程"></a> 部署教程</h2><p>部署使用的是老电脑上的<code>Ubuntu 20.04.4 LTS</code>，为了便于备份配置以及轻量上手，采用了<code>Docker-Compose</code>的一件式部署方式，该方案主要倾向解决追番问题，目前基本解决刮削问题。</p><h3 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h3><p>请在百度等搜索引擎直接搜索对应自己平台的&quot;Docker 安装 教程&quot;</p><h3 id="docker-compose部署"><a class="markdownIt-Anchor" href="#docker-compose部署"></a> Docker-Compose部署</h3><p>推荐的<code>qBittorrent</code>+<code>Jellyfin</code>部署配置文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">jellyfin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nyanmisaka/jellyfin:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">jellyfin</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/conf/jellyfin:/config</span>  <span class="hljs-comment"># 对应Jellyfin的配置文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/cache:/cache</span>  <span class="hljs-comment"># 对应Jellyfin的缓存文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/downloads/media:/media</span>  <span class="hljs-comment"># 对应Jellyfin的媒体文件夹</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8096:8096&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">UID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GID=1000</span><br>    <span class="hljs-attr">devices:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/dri:/dev/dri</span>  <span class="hljs-comment"># 如果要使用硬解配置</span><br><br>  <span class="hljs-attr">qbittorrent:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">johngong/qbittorrent:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">qbittorrent</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">qbittorrent</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/conf/qbit:/config</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/downloads:/Downloads</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;host&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">UID=0</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GID=0</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TRACKERSAUTO=YES</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">WEBUIPORT=8995</span>  <span class="hljs-comment"># 网页端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TRACKERS_LIST_URL=https://cdn.jsdelivr.net/gh/ngosang/trackerslist@master/trackers_all.txt</span>  <span class="hljs-comment"># 自动更新种子文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">UMASK=022</span><br></code></pre></td></tr></table></figure><blockquote><p>如果出现了qBittorrent配置有可能随着更新有变化，如果使用过程中出现问题，或需要自己额外配置，具体参考<a href="https://hub.docker.com/r/johngong/qbittorrent">johngong/qbittorrent</a>内的介绍进行修改即可。</p></blockquote><h3 id="配置自动改名工具"><a class="markdownIt-Anchor" href="#配置自动改名工具"></a> 配置自动改名工具</h3><p>下载 <a href="https://github.com/Nriver/Episode-ReName/files/8644661/EpisodeReName.zip">EpisodeReName.zip</a> 并且解压在<code>qbittorrent</code>挂载的<code>Downloads</code>目录下，用于下文中设置自动改名</p><h2 id="使用效果"><a class="markdownIt-Anchor" href="#使用效果"></a> 使用效果</h2><h3 id="rss订阅"><a class="markdownIt-Anchor" href="#rss订阅"></a> RSS订阅</h3><ol><li><p>在诸如<a href="https://mikanani.me/?ref=www.myiys.com">蜜柑计划</a>的网站，找到自己想要看的番剧或电视剧对应的<code>RSS</code>链接</p></li><li><p>在<code>qbittorrent</code>当中添加RSS规则，示例如下</p><p><img src="https://lsky.halc.top/uPhEeN.png" alt="RSS订阅" /></p></li><li><p>添加完毕RSS规则以后，则需要设置下载路径。由于<code>Jellyfin</code>刮削为识别文件夹名字进行刮削，因此这里的命名必须要符合规范来提高成功率</p><p><img src="https://lsky.halc.top/9FKNvM.png" alt="下载路径设置" /><br />注意文件夹命名要为&quot;番剧名/S+季度数&quot;即可</p></li><li><p>在<code>qbittorrent</code>设置内开启自动下载，后续只要识别到了RSS更新，就能自动下载到目标文件夹下</p></li></ol><h3 id="自动修改剧集名"><a class="markdownIt-Anchor" href="#自动修改剧集名"></a> 自动修改剧集名</h3><p>自动修改剧集名字使用的为<a href="https://github.com/Nriver/Episode-ReName">Episode-ReName</a>工具</p><ol><li><p>下载并将<code>Episode-ReName</code>放于<code>Docker</code>挂载后的<code>downloads</code>目录下</p></li><li><p>配置下载完毕自动运行<code>EpisodeRename</code>来对番剧重命名</p><p><img src="https://lsky.halc.top/D99DtN.png" alt="自动重命名" /></p><p>配置参数如下</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">/Downloads/EpisodeReName <span class="hljs-string">&quot;%D/%N&quot;</span> 10 <br><span class="hljs-comment"># 10指下载完毕10s后执行</span><br><span class="hljs-comment"># &quot;%D/%N&quot;指对下载完毕后单文件执行</span><br></code></pre></td></tr></table></figure></li><li><p>由于重命名后的文件无法直接继续做种，因此在<code>qbittorrent</code>内同样要设置自动取消做种上传</p><p><img src="https://lsky.halc.top/OGxcUV.png" alt="取消做种" /></p><p><strong>秉承BT分享的精神，或者使用PT站的朋友可以学习如何设置硬链接等方式对文件实现共享，本文不做解释</strong></p></li></ol><h3 id="jellyfin元数据插件"><a class="markdownIt-Anchor" href="#jellyfin元数据插件"></a> Jellyfin元数据插件</h3><p>元数据刮削主要用的是<code>TheMovieDb</code>, <code>AniDB</code>, <code>AniSearch</code>和<code>AniList</code>这几个插件，不过依旧存在抓取的时候抓到英文介绍为多的问题，不过暂且算是能使用，海报和宣传图也基本上都有，日常使用没有很大问题</p>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qbittorrent</tag>
      
      <tag>jellyfin</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL配置Proxy代理引导</title>
    <link href="/p/6088c65c.html"/>
    <url>/p/6088c65c.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在三番五次被<code>wsl</code>的<code>proxy</code>问题折腾的心态爆炸，并重装了好几次系统以后，总算理清楚了<code>WSL</code>如果想要搭配<code>windowns</code>上的<code>clash for windows</code>的正确使用方法。把之前无论是需要脚本还是各种复杂操作的博客都删了，在这里记录一个完全不需要任何脚本，也不需要额外配置防火墙的合理方案。</p><h2 id="工具环境"><a class="markdownIt-Anchor" href="#工具环境"></a> 工具环境</h2><ul><li><code>WSL 2 ArchLinux</code>（理论上来说其他发行版应该相同)</li><li><code>Windows 11</code>（win10应该同理）</li><li><code>Clash For Windows</code></li></ul><h2 id="clash的配置"><a class="markdownIt-Anchor" href="#clash的配置"></a> Clash的配置</h2><blockquote><p>改方案为<code>WSL</code>继承<code>System Proxy</code>来达到代理上网的目的，使用<code>TUN Mode</code>直接用就行，不需要额外设置</p></blockquote><ol><li><p>正常配置好<code>Clash For Windows</code>，并且启用<code>Allow LAN</code>的设置</p></li><li><p>在<code>允许应用或功能通过 Windows Defender防火墙</code>中寻找是否有<code>clash-win64.exe</code>的规则配置，注意不是 <strong>Clash For Windows</strong> ，<code>CFW</code>本身只是<code>clash</code>的一个前端，在启动<code>CFW</code>的时候有概率防火墙只添加<code>CFW</code>本身，而不添加作为核心的<code>clash</code>的防火墙规则，这个时候则需要我们手动修改</p></li><li><p>如果已经有了<code>clash-win64.exe</code>的规则，则只需要配置<strong>专有和公共网络同时允许</strong>即可。如果没有<code>clash-win64.exe</code>的规则，可以通过下方的<code>允许其他应用</code>手动添加规则，具体<code>clash</code>核心文件的路径可以通过任务管理器后台或<code>Clash for Windows\resources\static\files\win\x64\clash-win64.exe</code>类似的路径查询到。添加规则的时候同时允许<strong>专用和公共</strong>即可</p></li></ol><blockquote><p>之前经常折腾好了防火墙但过了三四个月或者一段时间后<code>wsl</code>和<code>windows</code>之间就因为防火墙断开，但总找不到原因，现在想想很有可能是当时<code>clash for windows</code>升级安装的时候规则被覆盖或路径变化导致的。WSL2的网络对Windows来说也是一个Public的公开网络，在设置了单独程序允许通信之后，虽然<code>wsl</code>有可能无法<code>ping</code>通<code>windows</code>的主机，但正常访问<code>clash</code>的代理端口是没有问题的</p></blockquote><h2 id="wsl的配置"><a class="markdownIt-Anchor" href="#wsl的配置"></a> WSL的配置</h2><p>到这里为止防火墙的问题就解决了，只需要通过合理的方法配置好<code>WSL</code>下的代理变量就可以正常使用。其中<code>主机名.local</code>这个域名是会直接在<code>wsl</code>内映射到作为<code>dns</code>服务器的宿主机上，因此并不需要写额外的脚本来添加映射</p><p>较为简单的方法即通过<code>zsh</code>终端下<code>oh my zsh</code>+ <a href="https://github.com/SukkaW/zsh-proxy">zsh-proxy</a> 插件，通过设置<code>proxy</code>来实现全局基本功能的代理配置，而在<code>config_proxy</code>步骤中的代理IP填入类似<code>Zephyrus.local:7890</code>格式的地址即可。</p><blockquote><p>Zephyrus为我Windows的设备名，可在Windows设置中重命名，一般来说默认设置应该为类似<code>DESKTOP-XXXX.local:7890</code>，修改和查看的方法可通过搜索引擎自己解决</p></blockquote><p>通过以上方式配置后的<code>WSL</code>就可以正常通过<code>Windows</code>上的<code>Clash</code>代理了。每次<code>WSL</code>出网络问题总是感觉莫名其妙没头绪，之前也试过通过<code>New-NetFireWallRule</code>一类的方法放行防火墙，但都不是很好用或者后面偶尔突然就出问题，现在总算弄清楚了原因而且能很舒服的使用<code>win</code>里面的代理了。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zsh</tag>
      
      <tag>WSL</tag>
      
      <tag>Clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：通过分段管理内存</title>
    <link href="/p/783d8b13.html"/>
    <url>/p/783d8b13.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十六章分段"><a class="markdownIt-Anchor" href="#第十六章分段"></a> 第十六章：分段</h2><ol><li><p>这里记录一个样例作为例子，其他的答案则跳过重复的计算步骤</p><p>运行第一个<code>seed</code>可以得到以下输出</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs log">ARG seed 0<br>ARG address space size 128<br>ARG phys mem size 512<br><br>Segment register information:<br><br>Segment 0 base  (grows positive) : 0x00000000 (decimal 0)<br>Segment 0 limit                  : 20<br><br>Segment 1 base  (grows negative) : 0x00000200 (decimal 512)<br>Segment 1 limit                  : 20<br><br>Virtual Address Trace<br>VA  0: 0x0000006c (decimal:  108) --&gt; PA or segmentation violation?<br>VA  1: 0x00000061 (decimal:   97) --&gt; PA or segmentation violation?<br>VA  2: 0x00000035 (decimal:   53) --&gt; PA or segmentation violation?<br>VA  3: 0x00000021 (decimal:   33) --&gt; PA or segmentation violation?<br>VA  4: 0x00000041 (decimal:   65) --&gt; PA or segmentation violation?<br></code></pre></td></tr></table></figure><p>对于<code>VA 0: 0x0000006c (decimal: 108)</code>的情况计算如下</p><ol><li>由<code>Address Size</code>为128<code>(2^7)</code>得到高位为第7位</li><li>将<code>VA</code>的<code>0x6c(108)</code>转为二进制，按7位来算则是<code>1 101100</code>，因此可以知道这是<code>SEG 1</code>的地址</li><li>栈是从最下方的内存反方向增加，<code>VA</code>最底部内存位为<code>0x80(128)</code>，因此<code>0x6c(108)</code>的<code>VA</code>对应偏移量为<code>108 - 128 = -20</code></li><li><code>VA</code>中<code>0x80(128)</code>的地址对应PA为<code>0x200(512)</code>，因此按偏移量<code>-20</code>算可以得到VA中<code>0x6c(108)</code>对应的<code>PA</code>为<code>0x1ec(492)</code></li></ol><p><img src="https://lsky.halc.top/qm2dvL.jpg" alt="计算过程(字丑.jpg)" /></p> <details> <summary>答案</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs log">Virtual Address Trace<br>VA  0: 0x0000006c (decimal:  108) --&gt; VALID in SEG1: 0x000001ec (decimal:  492)<br>VA  1: 0x00000061 (decimal:   97) --&gt; SEGMENTATION VIOLATION (SEG1)<br>VA  2: 0x00000035 (decimal:   53) --&gt; SEGMENTATION VIOLATION (SEG0)<br>VA  3: 0x00000021 (decimal:   33) --&gt; SEGMENTATION VIOLATION (SEG0)<br>VA  4: 0x00000041 (decimal:   65) --&gt; SEGMENTATION VIOLATION (SEG1)<br></code></pre></td></tr></table></figure> </details></li><li><p>以第一题为参考；在虚拟地址中<code>SEG 0</code>的范围是<code>0-19</code>，<code>SEG 1</code>的范围是<code>108-127</code>，非法地址为<code>20-107</code>。</p><p>以下为通过运行<code>-A</code>标志对分界点进行分别测试有如下结果</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs log">Virtual Address Trace<br>  VA  0: 0x00000000 (decimal:    0) --&gt; VALID in SEG0: 0x00000000 (decimal:    0)<br>  VA  1: 0x00000013 (decimal:   19) --&gt; VALID in SEG0: 0x00000013 (decimal:   19)<br>  VA  2: 0x00000014 (decimal:   20) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  3: 0x0000006b (decimal:  107) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA  4: 0x0000006c (decimal:  108) --&gt; VALID in SEG1: 0x000001ec (decimal:  492)<br>  VA  5: 0x0000007f (decimal:  127) --&gt; VALID in SEG1: 0x000001ff (decimal:  511)<br></code></pre></td></tr></table></figure></li><li><p>设置为以下指令即可</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./segmentation.py -a 16 -p 128 -A  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 --b0 0 --l0 2 --b1 16 --l1 1 -c<br></code></pre></td></tr></table></figure><p>输出结果</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs log">Virtual Address Trace<br>  VA  0: 0x00000000 (decimal:    0) --&gt; VALID in SEG0: 0x00000000 (decimal:    0)<br>  VA  1: 0x00000001 (decimal:    1) --&gt; VALID in SEG0: 0x00000001 (decimal:    1)<br>  VA  2: 0x00000002 (decimal:    2) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  3: 0x00000003 (decimal:    3) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  4: 0x00000004 (decimal:    4) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  5: 0x00000005 (decimal:    5) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  6: 0x00000006 (decimal:    6) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  7: 0x00000007 (decimal:    7) --&gt; SEGMENTATION VIOLATION (SEG0)<br>  VA  8: 0x00000008 (decimal:    8) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA  9: 0x00000009 (decimal:    9) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 10: 0x0000000a (decimal:   10) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 11: 0x0000000b (decimal:   11) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 12: 0x0000000c (decimal:   12) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 13: 0x0000000d (decimal:   13) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 14: 0x0000000e (decimal:   14) --&gt; SEGMENTATION VIOLATION (SEG1)<br>  VA 15: 0x0000000f (decimal:   15) --&gt; VALID in SEG1: 0x0000000f (decimal:   15)<br></code></pre></td></tr></table></figure></li><li><p>要让90%的地址可以被访问，则对于<code>SEG 0</code>的界限寄存器到<code>SEG 1</code>的界限寄存器中间地址差要为总虚拟地址的<code>10%</code>即可。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>b</mi><mn>1</mn><mo>−</mo><mi>l</mi><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mn>0</mn><mo>+</mo><mi>l</mi><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mfrac><mo>&lt;</mo><mn>10</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">  \frac{(b1 - l1  - (b0 + l0))}{Address Size} &lt; 10\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">%</span></span></span></span></span></p></li><li><p>所以地址都失效代表没有可以访问的地址，因此<code>l0</code>和<code>l1</code>界限寄存器都设置为0即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：虚拟内存和物理内存地址转换</title>
    <link href="/p/1724953e.html"/>
    <url>/p/1724953e.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十五章机制地址转换"><a class="markdownIt-Anchor" href="#第十五章机制地址转换"></a> 第十五章：机制：地址转换</h2><p>该章节主要引出了基址寄存器和界限寄存器的概念，表述了在操作系统内程序执行的时候虚拟内存的分布和物理内存的地址转换关系</p><ol><li><p>判断是否越界只需要将访问内存地址大小和<code>Limit</code>进行比较，在小于<code>Limit</code>的情况下直接做加法即可</p></li><li><p>获取到所有访问的数据后，可以发现访问的地址中最大的为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">VA  9: 0x000003a1 (decimal:  929)<br></code></pre></td></tr></table></figure><p>因此只需要将<code>-l</code>设置为930即可</p><blockquote><p>补充为什么不是929</p><p>界限寄存器是在基址寄存器的基础上开始<code>limit</code>个单位的内存可被使用，就好比数组中的<code>limit</code>为10个空间的情况下，只有<code>0-9</code>可以被使用。对应到该题，如果想要让<code>(0x000003a1)</code>的地址不越界，则需要设置<code>930</code>个可用空间</p></blockquote></li><li><p>题目默认的物理地址为<code>16k</code>，也就是<code>16,384</code>，只需要设置<code>-b</code>为<code>16384 - 100 = 16284</code>即可</p></li><li><p>和上文实验差别不大，其中<code>-a</code>参数是设置随即生成的取地址的大小范围，<code>-p</code>为设置物理内存的最大范围，实际内存主要是否越界只和<code>-b</code>的基址寄存器、<code>-l</code>的界限寄存器以及<code>-p</code>的物理内存有关系，<code>-a</code>作为一个随机数范围没有实际含义</p></li><li><p>通过<code>PyPlot</code>画图，在默认的<code>-n</code>情况下，当<code>limit</code>从0逐渐增加到<code>asize</code>的时候，可以得到大致如下的图片</p><p><img src="https://lsky.halc.top/PehmA1.png" alt="limit" /></p><blockquote><p>附画图代码</p></blockquote> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execRelocation</span>(<span class="hljs-params">seed, limit, num</span>):<br>    r = os.popen(<span class="hljs-string">&#x27;python3 relocation.py -s %d -l %d -c&#x27;</span> % (seed, limit))<br>    pass_num = r.read().count(<span class="hljs-string">&quot;VALID&quot;</span>)<br>    r.close()<br>    <span class="hljs-keyword">return</span> pass_num / num<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    limitTop = <span class="hljs-number">1024</span><br>    limit_list = []<br>    case_list = []<br>    <span class="hljs-comment"># 从 0 - limitTop开始以50为公差测试对应通过的概率</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, limitTop, <span class="hljs-number">50</span>):<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 对于每个limit重复实验20次，取平均值</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>            <span class="hljs-built_in">sum</span> += execRelocation(j, i, <span class="hljs-number">10</span>)<br>        <span class="hljs-comment"># 结果存入list</span><br>        case_list.append(<span class="hljs-built_in">sum</span> / <span class="hljs-number">10</span>)<br>        limit_list.append(i)<br>    <span class="hljs-comment"># 画图</span><br>    plt.xlabel(<span class="hljs-string">&quot;limit&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;pass rate&quot;</span>)<br>    plt.plot(limit_list, case_list)<br>    plt.savefig(<span class="hljs-string">&quot;limit.png&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修复WSL中env:&#39;bash\r&#39;的冲突问题</title>
    <link href="/p/b3a8b5ef.html"/>
    <url>/p/b3a8b5ef.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>由于之前C/C++环境配置出问题，近期把<code>WSL</code>重装了一次，结果在配置<code>zsh-proxy</code>的时候出现了报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs error">/usr/bin/env: ‘bash\r’: No such file or directory<br></code></pre></td></tr></table></figure><p>直接搜索的方案要么是直接屏蔽掉Windows的<code>Path</code>继承，要么是说重启下<code>wsl</code>就好，但都比较模棱两可</p><h2 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h2><p>后面在查看了<code>proxy</code>相关的报错后，发现只有配置<code>git</code>的<code>proxy</code>时会出现这个问题，同时根据<code>Stack Overflow</code>上别人类似情况的提问，发现<code>npm</code>同样也无法使用。检查后发现是在<code>Windows</code>对应的<code>Path</code>内，<code>git</code>和<code>npm</code>本身没有<code>.exe</code>的后缀就能启动，而<code>wsl</code>内是可以执行<code>Windows</code>下的部分可执行文件的，因此<code>wsl</code>调用了基于<code>Windows</code>的环境变量，从而导致了换行符与<code>wsl</code>的<code>linux</code>格式不兼容。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>本来想的是怎么处理屏蔽<code>Windows</code>的相关<code>Path</code>，后面发现只需要在WSL上重新安装好<code>git</code>和<code>npm</code>后重启<code>wsl</code></p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ps">wsl <span class="hljs-literal">--shudown</span><br><span class="hljs-comment"># 或者仅关闭指定发行版，例如`Arch`</span><br>wsl <span class="hljs-literal">-t</span> Arch<br></code></pre></td></tr></table></figure><p>就可以解决问题了。之前在<code>Stack Overflow</code>上其他人能直接通过重启<code>wsl</code>解决问题，应该也是无意中自己已经覆盖安装过了对应的工具，然后重启才取得了效果，在这里做个记录以做备忘。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Actions自动部署Hexo</title>
    <link href="/p/7bfa5e14.html"/>
    <url>/p/7bfa5e14.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>之前博客一直用的都是<code>Jekyll</code>框架，在使用<code>Github Pages</code>进行部署的时候并不需要自己手动配置，不过在换了<code>Hexo</code>主题之后，每次写完了博客除了要<code>push</code>一次<code>commit</code>到博客的内容分支上，还需要自己手动<code>deploy</code>一次。虽然也不会很麻烦，不过用<code>Github Actions</code>来完成这个过程也要更顺畅一些。原本觉得这个需求应该很简单，直接在<code>Actions</code>上执行一次<code>hexo g -d</code>的指令就好，结果因为<code>Github</code>在<code>HTTPS</code>上对<code>Token</code>的验证，以及<code>Hexo</code>自带的<code>one-command-deployment</code>存在<a href="https://github.com/hexojs/hexo/issues/4757#issuecomment-901613964">BUG</a>，折腾到凌晨两三点才发现，并且通过<code>issues</code>里面提供的修改链接使用<code>oauth</code>进行<code>url</code>验证的方法还是失败了，最后花了半小时改成了<code>ssh</code>密钥验证很轻松就完成了。。下面为对<code>Hexo</code>的<code>Actions</code>的脚本的一个备份</p><h2 id="脚本备份"><a class="markdownIt-Anchor" href="#脚本备份"></a> 脚本备份</h2><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">ref:</span> <span class="hljs-string">hexo</span><br><br>    <span class="hljs-comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">cache</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-v2-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.os &#125;&#125;-node-v2</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">if:</span> <span class="hljs-string">steps.cache.outputs.cache-hit</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;true&#x27;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm ci</span><br><span class="hljs-string"></span><br>      <span class="hljs-comment"># Deploy hexo blog website.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">and</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.email &quot;halc-days@outlook.com&quot;</span><br><span class="hljs-string">          git config --global user.name &quot;HalcyonAzure&quot;</span><br><span class="hljs-string">          npx hexo g -d</span><br><span class="hljs-string">          rm -rf ~/.ssh/id_rsa</span><br></code></pre></td></tr></table></figure><p>整个脚本大致流程为</p><ol><li><p>检测到<code>hexo</code>的内容分支有<code>push</code>之后，<code>checkout</code>到内容分支。</p></li><li><p>判断是否有<code>nodejs</code>的<code>modules</code>缓存。</p><ul><li>如果检测到有效缓存则跳过安装步骤，直接进行下一步。</li><li>如果没有检测到有效缓存则对模块进行部署</li></ul></li><li><p>创建<code>id_rsa</code>密钥文件，并将仓库中<code>DEPLOY_KEY</code>的<code>secret</code>写入密钥文件，并且配置<code>github.com</code>的信任和全局帐号邮箱</p></li><li><p>对<code>hexo</code>进行<code>generate &amp; deploy</code>操作</p></li><li><p>删除写入的密钥文件</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Windows未使用端口被占用问题</title>
    <link href="/p/22453a61.html"/>
    <url>/p/22453a61.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://stackoverflow.com/questions/52212012/hortonworks-docker-sandbox-environment-cannot-start/">Hortonworks Docker Sandbox environment cannot start</a></li><li><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang">default-dynamic-port-range-tcpip-chang</a></li></ol><h2 id="问题产生"><a class="markdownIt-Anchor" href="#问题产生"></a> 问题产生</h2><p>在无脑跟着网上教材开启Windows的<code>SandBox</code>的时候开启了Hyper-V的功能，结果尝试在<code>6800</code>端口运行和往常一样的<code>Aria2</code>的<code>Docker</code>容器的时候出现了端口报错的情况，通过<code>netstat</code>排查也没发现<code>6800</code>端口被占用了，后面发现应该是Windows的动态端口在开了<code>Hyper-V</code>之后被修改了</p><p>通过以下指令可以分别查看<code>ipv4/ipv6</code>的<code>tcp/udp</code>起始端口</p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ps">netsh int ipv4 show dynamicport tcp<br>netsh int ipv4 show dynamicport udp<br>netsh int ipv6 show dynamicport tcp<br>netsh int ipv6 show dynamicport udp<br></code></pre></td></tr></table></figure><p>在我的情况下，起始端口从原本默认的<code>49152</code>被修改成了从<code>1024</code>开始，因此<code>6800</code>端口无法使用</p><h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2><p>在参考问题中找到了对应的解决方案</p><p>如果需要继续使用<code>windows Virtual platform form windows feature</code>（不确定这里是不是指Hyper-V，所以不翻译了）则</p><ol><li><p>关闭Windows服务上对应的功能，关闭后系统会请求重启</p></li><li><p>通过以下指令修改动态起始端口 <s>(<code>49152</code>是Windows默认设置)</s> 在使用<code>adb</code>连<code>WSA</code>的调试时，发现默认端口为<code>58526</code>，所以还是用<code>100000</code>把</p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ps">netsh int ipv4 <span class="hljs-built_in">set</span> dynamicport tcp <span class="hljs-built_in">start</span>=<span class="hljs-number">64536</span> num=<span class="hljs-number">1000</span><br>netsh int ipv4 <span class="hljs-built_in">set</span> dynamicport udp <span class="hljs-built_in">start</span>=<span class="hljs-number">64536</span> num=<span class="hljs-number">1000</span><br>netsh int ipv6 <span class="hljs-built_in">set</span> dynamicport tcp <span class="hljs-built_in">start</span>=<span class="hljs-number">64536</span> num=<span class="hljs-number">1000</span><br>netsh int ipv6 <span class="hljs-built_in">set</span> dynamicport udp <span class="hljs-built_in">start</span>=<span class="hljs-number">64536</span> num=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></li><li><p>重新启用对应的功能</p></li></ol><p>如果没有Hyper-V使用需求的情况下，可以尝试直接关闭Hyper-V，然后检查起始端口是否恢复，如果没有恢复的再通过上面的指令手动重新设置起始端口即可</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：系统API的调用</title>
    <link href="/p/264bf58c.html"/>
    <url>/p/264bf58c.html</url>
    
    <content type="html"><![CDATA[<h2 id="第十四章插叙内存操作api"><a class="markdownIt-Anchor" href="#第十四章插叙内存操作api"></a> 第十四章：插叙：内存操作API</h2><ol><li><p>执行<code>null</code>文件后并没有提示或报错，代码如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *pt = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">free</span>(pt); <span class="hljs-comment">// 释放空指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在执行完<code>gdb null</code>后的<code>run</code>后，提示了以下信息</p> <details> <summary>log</summary> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) run<br>Starting program: /home/halc/code/cpp/null<br>[Inferior 1 (process 9285) exited normally]<br></code></pre></td></tr></table></figure> </details></li><li><p>在使用<code>valgrind</code>检查后，可以得到以下输出信息</p><details><summary>log</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs log">==9579== Memcheck, a memory error detector<br>==9579== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.<br>==9579== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info<br>==9579== Command: ./null<br>==9579==<br>==9579==<br>==9579== HEAP SUMMARY:<br>==9579==     in use at exit: 0 bytes in 0 blocks<br>==9579==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated<br>==9579==<br>==9579== All heap blocks were freed -- no leaks are possible<br>==9579==<br>==9579== For lists of detected and suppressed errors, rerun with: -s<br>==9579== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure> </details><p>根据<a href="https://en.cppreference.com/w/c/memory/free">C/C++ Preference</a>上<code>free()</code>的介绍如下</p><blockquote><p>If is a null pointer, the function does nothing. ptr<br />当指针是空指针的时候，啥都不会发生，因此也理所当然的没有发生任何的内存泄露</p></blockquote></li><li><p>首先使用<code>malloc()</code>函数对内存空间进行分配，但是不使用<code>free()</code>对内存进行释放</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *pt = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-comment">// free(pt);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>gdb</code>对可执行文件进行调试如下</p> <details> <summary>gdb log</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs log">Starting program: /home/halc/code/cpp/null <br>[Inferior 1 (process 9978) exited normally]<br></code></pre></td></tr></table></figure> </details><p>使用<code>valgrind</code>对可执行文件调试入如下</p> <details> <summary>valgrind log</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs log">$ valgrind --leak-check=yes ./null<br>==9930== Memcheck, a memory error detector<br>==9930== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.<br>==9930== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info<br>==9930== Command: ./null<br>==9930==<br>==9930==<br>==9930== HEAP SUMMARY:<br>==9930==     in use at exit: 4 bytes in 1 blocks<br>==9930==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated<br>==9930==<br>==9930== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1<br>==9930==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==9930==    by 0x10915E: main (null.cpp:6)<br>==9930==<br>==9930== LEAK SUMMARY:<br>==9930==    definitely lost: 4 bytes in 1 blocks<br>==9930==    indirectly lost: 0 bytes in 0 blocks<br>==9930==      possibly lost: 0 bytes in 0 blocks<br>==9930==    still reachable: 0 bytes in 0 blocks<br>==9930==         suppressed: 0 bytes in 0 blocks<br>==9930==<br>==9930== For lists of detected and suppressed errors, rerun with: -s<br>==9930== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure> </details><p>这个时候通过<code>valgrind</code>工具即可检查出，在堆空间中有<code>definitely lost(确定的内存泄露)</code>为<code>4 bytes in 1 blocks</code>，正好对应了代码中<code>sizeof(int)</code>的大小和数量</p></li><li><p>首先使用<code>malloc()</code>函数分配100个<code>int</code>的空间给指针<code>data</code>，然后在<code>data[100]</code>的位置赋值</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>    data[<span class="hljs-number">100</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">free</span>(data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序直接运行的时候不会报错，没有任何提示。但是使用<code>valgrind</code>进行检查的时候有如下日志</p> <details> <summary>log</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs log">$ valgrind --leak-check=yes ./null<br>==10500== Memcheck, a memory error detector<br>==10500== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.<br>==10500== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info<br>==10500== Command: ./null<br>==10500==<br>==10500== Invalid write of size 4<br>==10500==    at 0x10918D: main (null.cpp:7)<br>==10500==  Address 0x4a4c1d0 is 0 bytes after a block of size 400 alloc&#x27;d<br>==10500==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==10500==    by 0x10917E: main (null.cpp:6)<br>==10500==<br>==10500==<br>==10500== HEAP SUMMARY:<br>==10500==     in use at exit: 0 bytes in 0 blocks<br>==10500==   total heap usage: 1 allocs, 1 frees, 400 bytes allocated<br>==10500==<br>==10500== All heap blocks were freed -- no leaks are possible<br>==10500==<br>==10500== For lists of detected and suppressed errors, rerun with: -s<br>==10500== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure> </details><p>可以看到<code>valgrind</code>成功检测出一个无效的写入，在内存分配之后，只有<code>data[0] - data[99]</code>是可以正常写入的，<code>data[100]</code>并不存在，因此出现了无效写入的错误</p></li><li><p>用和第五题相似的方法创建一个数组，然后通过<code>free()</code>函数对内存释放，然后对已经释放的空间进行读取</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">free</span>(data);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, data[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在本地电脑上直接运行的时候输出了<code>0</code>，使用<code>valgrind</code>工具进行检查的时候输出了如下日志</p> <details> <summary>log</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs log">==10682== Memcheck, a memory error detector<br>==10682== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.<br>==10682== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info<br>==10682== Command: ./null<br>==10682==<br>==10682== Invalid read of size 4<br>==10682==    at 0x1091B3: main (null.cpp:8)<br>==10682==  Address 0x4a4c040 is 0 bytes inside a block of size 400 free&#x27;d<br>==10682==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==10682==    by 0x1091AE: main (null.cpp:7)<br>==10682==  Block was alloc&#x27;d at<br>==10682==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==10682==    by 0x10919E: main (null.cpp:6)<br>==10682==<br>0<br>==10682==<br>==10682== HEAP SUMMARY:<br>==10682==     in use at exit: 0 bytes in 0 blocks<br>==10682==   total heap usage: 2 allocs, 2 frees, 1,424 bytes allocated<br>==10682==<br>==10682== All heap blocks were freed -- no leaks are possible<br>==10682==<br>==10682== For lists of detected and suppressed errors, rerun with: -s<br>==10682== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure> </details><p>可以看见检测出了无效的读写<code>Invalid read of size 4</code></p></li><li><p>对<code>data</code>数组中的<code>data[50]</code>进行内存释放，然后输出<code>data[0]</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>    <span class="hljs-comment">// free(data);</span><br>    <span class="hljs-built_in">free</span>(data + <span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, data[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在直接运行的时候会直接报错</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs warning">$ ./null<br>free(): invalid pointer<br>[1]    10986 abort      ./null<br></code></pre></td></tr></table></figure><p>不需要用<code>valgrind</code>也可以检查出此处有<code>free()</code>的问题</p><blockquote><p>根据 <a href="https://stackoverflow.com/a/20297598">c-free-invalid-pointer</a> 的回答，可以知道</p><p>When you have in fact allocated a block of memory, you can only free it from the pointer returned by. That is to say, only from the beginning of the block.</p><p>当我们分配了一块内存的时候，我们只能从返回的指针开始对这块内存进行释放，也就是说我们只能从内存块的开头对某一处内存进行释放</p></blockquote></li><li><p>通过<code>realloc()</code>函数实现一个类似<code>vector</code>的操作</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *pt = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 给指针pt分配1个int大小空间的内存</span><br>    *pt = <span class="hljs-number">10</span>; <span class="hljs-comment">// 对对应内存位置进行赋值</span><br>    pt = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(pt, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 将原本的变量扩容为2个int大小空间</span><br>    pt[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>; <span class="hljs-comment">// 对新扩大的内存位置进行赋值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d\n&quot;</span>, pt[<span class="hljs-number">0</span>], pt[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出pt对应的两个内存位置的结果</span><br>    <span class="hljs-built_in">free</span>(pt); <span class="hljs-comment">// 释放堆内存中的pt</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序编译可以成功通过，使用<code>valgrind</code>也正常通过，没有无效读写错误</p><p>通过这种操作实现的<code>vector</code>可以在访问的时候直接通过<code>index</code>进行访问，时间复杂度为O(1)，并且他并不需要和链表一样创建一个指向<code>next</code>的指针，不过在向后添加内容的时候依旧需要O(n)的时间复杂度来向后添加元素。</p><blockquote><p>顺便记录一个Tips， 在C中是允许<code>void *</code>类型进行任意转换的，因此即使没有(int *)也不会出现报错，而在<code>C++</code>中对类型转换的限制更多，并不允许直接进行这样的操作，必须要进行类型转换(通过static_cast转换运算符)才能分配空间给对应的指针。</p></blockquote></li><li><p><s>偷懒，懒得写</s></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：比例份额的调度策略</title>
    <link href="/p/13271c5f.html"/>
    <url>/p/13271c5f.html</url>
    
    <content type="html"><![CDATA[<h2 id="第八章调度比例份额"><a class="markdownIt-Anchor" href="#第八章调度比例份额"></a> 第八章：调度：比例份额</h2><p>在CPU资源进行调度的时候，有的时候我们很难让每个程序都尽量公平的分配到资源。“彩票调度<code>(lottery scheduling)</code>”通过给不同的任务分配不同的彩票数，再通过随机数和期望分布来对资源进行调度，实现一个类似于平均分配的调度方法</p><p>本章中文译本内缺少对<code>Linux</code>系统的<code>CFS</code>调度的说明，不过不影响课后练习</p><ol><li><p>完成随机种子1、2和3对应的习题计算</p><blockquote><p>该题目的主要思路即判断随机数取模后的数字和<code>tickets</code>的数量比较，然后依次逐步执行判断即可</p></blockquote></li><li><p>当彩票分布设计的十分极端的情况下，由于第一个<code>Job0 10:1</code>获得的票数太少，几乎不可能在<code>Job1 10:100</code>前完成任务，将会在结果上滞后<code>Job0</code>的完成</p></li><li><p>通过设立不同的<code>seed</code>，可以得到不同的情况如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./lottery.py -l 100:100,100:100 -s 1 -c<br>...<br>--&gt; JOB 1 DONE at time 196<br>...<br>--&gt; JOB 0 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -s 2 -c<br>...<br>--&gt; JOB 1 DONE at time 190<br>...<br>--&gt; JOB 0 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -s 3 -c<br>...<br>--&gt; JOB 0 DONE at time 196<br>...<br>--&gt; JOB 1 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -s 4 -c<br>...<br>--&gt; JOB 1 DONE at time 199<br>...<br>--&gt; JOB 0 DONE at time 200<br></code></pre></td></tr></table></figure><p>可以大致看出在任务的长度足够大的情况下，调度分布基本公平，最后的结果趋紧于类似RR切换任务的平均期望</p></li><li><p>在修改了<code>quantum</code>大小之后，由于时间片变大，相当于任务本身的长度缩短，整个任务的公平性会偏向不稳定和不公平，大致结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./lottery.py -l 100:100,100:100 -q 20 -c -s 1<br>...<br>--&gt; JOB 0 DONE at time 180<br>...<br>--&gt; JOB 1 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -q 20 -c -s 2<br>...<br>--&gt; JOB 1 DONE at time 180<br>...<br>--&gt; JOB 0 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -q 20 -c -s 3<br>...<br>--&gt; JOB 1 DONE at time 120<br>...<br>--&gt; JOB 0 DONE at time 200<br><br>$ ./lottery.py -l 100:100,100:100 -q 20 -c -s 4<br>...<br>--&gt; JOB 1 DONE at time 140<br>...<br>--&gt; JOB 0 DONE at time 200<br></code></pre></td></tr></table></figure></li><li><p>这题主要用来当Python练习了，模拟生成图像的代码如下（和<code>lottery.py</code>实验代码放于同一目录下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 执行彩票概率检查，返回概率结果</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">countLottery</span>(<span class="hljs-params">length, seed</span>):<br>   r = os.popen(<br>      <span class="hljs-string">&quot;./lottery.py -l &quot;</span> + length + <span class="hljs-string">&quot;:100,&quot;</span> + length + <span class="hljs-string">&quot;:100 -c&quot;</span> + <span class="hljs-string">&quot; -s &quot;</span> + seed)<br>   text = r.read()<br>   r.close()<br>   lottery_time = re.findall(<span class="hljs-string">r&quot;^--&gt; .*(\d*)&quot;</span>, text, re.M)<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(lottery_time[<span class="hljs-number">0</span>])/<span class="hljs-built_in">int</span>(lottery_time[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">length</span>):<br>   <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>   <span class="hljs-comment"># 调整重复</span><br>   time = <span class="hljs-number">20</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, time):<br>      <span class="hljs-built_in">sum</span> += countLottery(length, <span class="hljs-built_in">str</span>(i))<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> / (time - <span class="hljs-number">1</span>)<br><br>length = []<br>chance = []<br><br><span class="hljs-comment"># 设定工作长度和间隔</span><br><br>length_start = <span class="hljs-number">1</span><br>length_end = <span class="hljs-number">100</span><br>step = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(length_start, length_end, step):<br>   length.append(i)<br>   chance.append(average(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(i))))<br><br>plt.ylabel(<span class="hljs-string">&quot;Fairness&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Job Length&quot;</span>)<br><br>plt.plot(length, chance, <span class="hljs-string">&#x27;b-&#x27;</span>)<br><br>plt.savefig(<span class="hljs-string">&quot;./lottery.png&quot;</span>)<br></code></pre></td></tr></table></figure><p>最后生成的图片效果</p><p><img src="https://lsky.halc.top/ewA3BX.png" alt="模拟图像" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结：2022年3月</title>
    <link href="/p/18b05b6b.html"/>
    <url>/p/18b05b6b.html</url>
    
    <content type="html"><![CDATA[<h2 id="做了的事情"><a class="markdownIt-Anchor" href="#做了的事情"></a> 做了的事情</h2><h3 id="学习方面"><a class="markdownIt-Anchor" href="#学习方面"></a> 学习方面</h3><p>这个月直接写出的可以用的贡献不是很多，主要成就感应该就是来自<code>Python</code>的抓包和发包写一些打卡脚本的目标完成了，实现了学校的打卡自由和机场的签到流量自由。</p><p><code>Rust</code>的学习和<code>CS144</code>的学习在这个月成功被我换成了<code>C++</code>的学习和<code>OSTEP</code>的学习，写lab完成之后带来的快感感觉完全不亚于玩老头环成功挑战Boss后的成就感，<code>OSTEP</code>的学习笔记和答案也有一直在博客里面更新，希望自己这个学期能全部做完加深对操作系统的了解</p><p>这个学期也第一次写了一个能用的<code>repo</code>出来：<a href="https://github.com/HalcyonAzure/lsky-pro-docker">HalcyonAzure/lsky-pro-docker</a>。虽然整个<code>Dockerfile</code>还是抄袭了<code>issues</code>里面别人的劳动成果，但是在调试的过程中遇到的许多问题也加深了自己对<code>container</code>的了解，而且学会了用<code>dev container</code>来做一些临时开发，同时自己写<code>yaml</code>用<code>github actions</code>来自动部署一些项目（白嫖服务器的感觉是真的爽），总的来说成就感可以说是非常强了。</p><p>喔，对了，这个月还把博客重构了一下，改成了用<code>Hexo</code>的<code>Fluid</code>的主题，看着比原来<code>Jekyll</code>的<code>TeXt</code>花里胡哨了不少😉</p><h3 id="生活方面"><a class="markdownIt-Anchor" href="#生活方面"></a> 生活方面</h3><p>这个月由于都忙着<code>Coding</code>，没什么游戏时间。不过让我没想到的是南昌居然也会受到疫情的波及，连续上了近一整个月的网课，伙食方面不能吃烧烤或火锅来释放自己的多巴胺果然感觉还是很难受啊😢，希望能早点解封然后出去吃餐好的</p><p>核酸检测虽然说做的次数也满多，不过学校后面几次安排的时间都蛮合适的，整个流程下来不超过<code>30min</code>，因此也没什么怨言，同时托网课的福，自己也才有了那么多时间能做自己想做的事情，写自己想写的东西，这种无忧无虑不用考虑绩点和平时作业的时候如果多一些就好啦😣</p><h2 id="四月份要做的事情"><a class="markdownIt-Anchor" href="#四月份要做的事情"></a> 四月份要做的事情</h2><h3 id="学习计划"><a class="markdownIt-Anchor" href="#学习计划"></a> 学习计划</h3><ul><li>参加计算机设计大赛，看看能不能摸个奖回来，丰富下经历</li><li>OSTEP的Lab每个礼拜写两篇</li></ul><h3 id="生活计划"><a class="markdownIt-Anchor" href="#生活计划"></a> 生活计划</h3><ul><li>绝对、绝对绝对开始跑步或打排球，调整自己的生活质量</li><li>早睡早起！！！</li><li>水果封校已经不做指望了，就希望能控制住自己的饮食😥</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：通过多级反馈的调度策略</title>
    <link href="/p/b7974b6.html"/>
    <url>/p/b7974b6.html</url>
    
    <content type="html"><![CDATA[<h2 id="第八章多级反馈队列"><a class="markdownIt-Anchor" href="#第八章多级反馈队列"></a> 第八章：多级反馈队列</h2><p>优先级的规则：</p><ul><li>当任务刚进入操作系统的时候其优先级最高</li><li>优先级的切换：<ul><li>当任务运行的时间超过时间片，则优先级降低</li><li>当任务在时间片中暂停使用CPU，则优先级不变</li><li>一个任务在未达到时间片时放弃CPU则优先级不变</li></ul><blockquote><p>对于交互式任务来说，我们不希望降低它的优先级，而希望它在某一优先级反复执行</p></blockquote><ul><li>每个任务在某一优先级的总时间不超过一个时间片，达到后则强制降低优先级，并在Boost后重置所有任务优先级</li></ul></li></ul><p>根据以上规则完成以下练习：</p><ol><li><p>创建两个任务和队列，并且关闭IO的同时限制任务的长度。计算在MLFQ中的执行情况</p><p>运行的指令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mlfq.py -j 2 -n 2 -m 15 -M 0<br></code></pre></td></tr></table></figure><p>得到的结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">OPTIONS <span class="hljs-built_in">jobs</span> 2<br>OPTIONS queues 2<br>OPTIONS allotments <span class="hljs-keyword">for</span> queue  1 is   1<br>OPTIONS quantum length <span class="hljs-keyword">for</span> queue  1 is  10<br>OPTIONS allotments <span class="hljs-keyword">for</span> queue  0 is   1<br>OPTIONS quantum length <span class="hljs-keyword">for</span> queue  0 is  10<br>OPTIONS boost 0<br>OPTIONS ioTime 5<br>OPTIONS stayAfterIO False<br>OPTIONS iobump False<br><br>Job List:<br>Job  0: startTime   0 - runTime  12 - ioFreq   0<br>Job  1: startTime   0 - runTime   6 - ioFreq   0<br></code></pre></td></tr></table></figure><p>计算过程<br /><img src="https://lsky.halc.top/KSki0a.jpg" alt="MLFQ_1" /></p><p>实际答案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sh">Execution Trace:<br>[ time 0 ] JOB BEGINS by JOB 0<br>[ time 0 ] JOB BEGINS by JOB 1<br>[ time 0 ] Run JOB 0 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 11 (of 12) ]<br>[ time 1 ] Run JOB 0 at PRIORITY 1 [ TICKS 8 ALLOT 1 TIME 10 (of 12) ]<br>[ time 2 ] Run JOB 0 at PRIORITY 1 [ TICKS 7 ALLOT 1 TIME 9 (of 12) ]<br>[ time 3 ] Run JOB 0 at PRIORITY 1 [ TICKS 6 ALLOT 1 TIME 8 (of 12) ]<br>[ time 4 ] Run JOB 0 at PRIORITY 1 [ TICKS 5 ALLOT 1 TIME 7 (of 12) ]<br>[ time 5 ] Run JOB 0 at PRIORITY 1 [ TICKS 4 ALLOT 1 TIME 6 (of 12) ]<br>[ time 6 ] Run JOB 0 at PRIORITY 1 [ TICKS 3 ALLOT 1 TIME 5 (of 12) ]<br>[ time 7 ] Run JOB 0 at PRIORITY 1 [ TICKS 2 ALLOT 1 TIME 4 (of 12) ]<br>[ time 8 ] Run JOB 0 at PRIORITY 1 [ TICKS 1 ALLOT 1 TIME 3 (of 12) ]<br>[ time 9 ] Run JOB 0 at PRIORITY 1 [ TICKS 0 ALLOT 1 TIME 2 (of 12) ]<br>[ time 10 ] Run JOB 1 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 5 (of 6) ]<br>[ time 11 ] Run JOB 1 at PRIORITY 1 [ TICKS 8 ALLOT 1 TIME 4 (of 6) ]<br>[ time 12 ] Run JOB 1 at PRIORITY 1 [ TICKS 7 ALLOT 1 TIME 3 (of 6) ]<br>[ time 13 ] Run JOB 1 at PRIORITY 1 [ TICKS 6 ALLOT 1 TIME 2 (of 6) ]<br>[ time 14 ] Run JOB 1 at PRIORITY 1 [ TICKS 5 ALLOT 1 TIME 1 (of 6) ]<br>[ time 15 ] Run JOB 1 at PRIORITY 1 [ TICKS 4 ALLOT 1 TIME 0 (of 6) ]<br>[ time 16 ] FINISHED JOB 1<br>[ time 16 ] Run JOB 0 at PRIORITY 0 [ TICKS 9 ALLOT 1 TIME 1 (of 12) ]<br>[ time 17 ] Run JOB 0 at PRIORITY 0 [ TICKS 8 ALLOT 1 TIME 0 (of 12) ]<br>[ time 18 ] FINISHED JOB 0<br><br>Final statistics:<br>Job  0: startTime   0 - response   0 - turnaround  18<br>Job  1: startTime   0 - response  10 - turnaround  16<br>Avg  1: startTime n/a - response 5.00 - turnaround 17.00<br></code></pre></td></tr></table></figure></li><li><p>以下为每个章节的实例复现参数</p><ol><li><p>实例1:单个长工作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mlfq.py -l 0,200,0 -n 3 -q 10 -c<br></code></pre></td></tr></table></figure></li><li><p>实例2:来一个短工作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 150的运行时间是为了让任务经过两个时间片后保持在最低优先级运行</span><br>./mlfq.py -l 0,150,0:100,20,0 -n 3 -q 10 -c<br></code></pre></td></tr></table></figure></li><li><p>实例3:如果有I/O呢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 每次拥有io的进程完成了io操作后，总会先切换到io的任务进行完成</span><br>./mlfq.py -l 0,190,0:0,10,1 -n 2 -q 10 -i 10 -c<br></code></pre></td></tr></table></figure></li><li><p>拥有优先级提升的调度方式 - Boost</p><p><strong>不采用优先级提升时</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 通过-S参数，忽略强制降低优先级的规则</span><br>./mlfq.py -l 0,120,0:100,45,9:109,45,9 -i 9 -n 3 -q 10 -S -c<br></code></pre></td></tr></table></figure><p>执行后可以发现，在<code>Job1</code>和<code>Job2</code>执行完毕之前<code>Job0</code>无法执行，被饿死</p><p><strong>采用优先级提升时</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mlfq.py -l 0,120,0:100,45,9:109,45,9 -i 9 -n 3 -q 10 -S -B 40 -c<br></code></pre></td></tr></table></figure><p>增加了<code>Boost</code>时间后，<code>Job0</code>能够通过每次提升的间隙运行来避免被饿死的问题</p><blockquote><p>模拟这个实验的时候遇到了一个不清楚是否为BUG的情况，将<code>PRIORITY 0</code>的任务<code>Boost</code>之后只会升级到<code>PRIORITY 2</code>后运行<code>1 tick</code>的时间，立马降低到<code>PRIORITY 1</code>。不清楚具体原因</p></blockquote></li><li><p>更好的计时方式 - 强制降低优先级</p><p><strong>降低优先级前</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 在时间片前一时刻放弃CPU，并且I/O操作同样只执行一个时刻，会将另外一个进程几乎饿死</span><br>./mlfq.py -q 10 -l 0,50,0:1,100,9 -i 1 -S -c<br></code></pre></td></tr></table></figure><p><strong>强制降低优先级后</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 饿死的情况得到解决，两个任务依次执行平等的时间</span><br>./mlfq.py -q 10 -l 0,50,0:1,100,9 -i 1 -c<br></code></pre></td></tr></table></figure></li></ol></li><li><p>MLFQ相当于在RR的思想上加入了优先级的控制，因此如果希望最后呈现的效果和RR相似，只需要设置只有一个<code>queue</code>存在即可</p></li><li><p>在第二题的<code>拥有优先级提升的调度方式 - Boost</code>已经做了相关演示</p></li><li><p>至少得到<code>5%</code>的CPU占用就代表在每个<code>Boost</code>的时间区块内，一个时间片的长度就是<code>5%</code>，所以答案为<code>-B 200</code></p></li><li><p>使用<code>iodump</code>的情况对比如下</p><p>在不使用<code>iodump</code>的时候，执行队列有</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 此时的效果类似RR，任务会轮番运行</span><br> ./mlfq.py -l 0,20,0:0,20,10 -i 0 -c<br></code></pre></td></tr></table></figure><p>在使用了<code>iodump</code>之后，执行的队列有</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 由于io操作会立刻完成，并且更新优先级，因此另外一个进程将被饿死</span><br>./mlfq.py -l 0,20,0:0,20,10 -i 0 -I -c<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：进程的调度策略</title>
    <link href="/p/28ea7a49.html"/>
    <url>/p/28ea7a49.html</url>
    
    <content type="html"><![CDATA[<h2 id="第七章进程调度介绍"><a class="markdownIt-Anchor" href="#第七章进程调度介绍"></a> 第七章：进程调度/介绍</h2><blockquote><p>参数介绍：</p><p>Response：响应时间，即任务第一次运行的时间</p><p>Turnaround: 完成时刻（周转时间），即任务完成那一刻对应的时间</p><p>Wait: 等待中时间，即任务处于Ready状态，但当前CPU在执行其他任务的等待时间</p></blockquote><ol><li><p>执行结果如下</p><p>FIFO:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy FIFO<br>ARG jlist 200,200,200<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 200.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 200.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 0 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 200.00 )<br>[ time 200 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 400.00 )<br>[ time 400 ] Run job 2 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 200.00  Wait 0.00<br>Job   1 -- Response: 200.00  Turnaround 400.00  Wait 200.00<br>Job   2 -- Response: 400.00  Turnaround 600.00  Wait 400.00<br><br>Average -- Response: 200.00  Turnaround 400.00  Wait 200.00<br></code></pre></td></tr></table></figure><p>同时，对于SJF<code>(Short Job First)</code>，由于每个任务的执行时间相同，所以策略上的处理结果和<code>FIFO</code>相同，不额外列出</p></li><li><p>在按照<code>300</code>,<code>200</code>和<code>100</code>的顺序一次执行任务的时候，对于FIFO策略依次执行，而依据SJF策略，则会先执行时间短的<code>100</code>，依次到最常的<code>300</code>。具体结果如下</p><p>FIFO</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy FIFO<br>ARG jlist 300,200,100<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 300.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 100.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 0 <span class="hljs-keyword">for</span> 300.00 secs ( DONE at 300.00 )<br>[ time 300 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 500.00 )<br>[ time 500 ] Run job 2 <span class="hljs-keyword">for</span> 100.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 300.00  Wait 0.00<br>Job   1 -- Response: 300.00  Turnaround 500.00  Wait 300.00<br>Job   2 -- Response: 500.00  Turnaround 600.00  Wait 500.00<br><br>Average -- Response: 266.67  Turnaround 466.67  Wait 266.67<br></code></pre></td></tr></table></figure><p>SJF</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy SJF<br>ARG jlist 300,200,100<br><br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 300.0 )<br>Job 1 ( length = 200.0 )<br>Job 2 ( length = 100.0 )<br><br>**Solutions**<br><br>Execution trace:<br>[ time   0 ] Run job 2 <span class="hljs-keyword">for</span> 100.00 secs ( DONE at 100.00 )<br>[ time 100 ] Run job 1 <span class="hljs-keyword">for</span> 200.00 secs ( DONE at 300.00 )<br>[ time 300 ] Run job 0 <span class="hljs-keyword">for</span> 300.00 secs ( DONE at 600.00 )<br><br>Final statistics:<br>Job   2 -- Response: 0.00  Turnaround 100.00  Wait 0.00<br>Job   1 -- Response: 100.00  Turnaround 300.00  Wait 100.00<br>Job   0 -- Response: 300.00  Turnaround 600.00  Wait 300.00<br><br>Average -- Response: 133.33  Turnaround 333.33  Wait 133.33<br></code></pre></td></tr></table></figure><p>SJF的好处在于可以先执行时间短的程序，后执行时间长的程序，同时优化了程序的响应、完成和等待时间。缺点在于因为必须先完整的运行某个任务，后执行下一个任务。如果此时需要高频率执行某任务则无能为力（比如高频率的io输出）</p></li><li><p>采用RR策略，时间片设置为1，依次执行<code>10</code>、<code>20</code>和<code>30</code>有以下结果</p><details><summary>RR策略</summary> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs bash">ARG policy RR<br>ARG jlist 10,20,30<br>   <br>Here is the job list, with the run time of each job:<br>Job 0 ( length = 10.0 )<br>Job 1 ( length = 20.0 )<br>Job 2 ( length = 30.0 )<br><br><br>** Solutions **<br><br>Execution trace:<br>[ time   0 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   1 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   2 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   3 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   4 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   5 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   6 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   7 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   8 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time   9 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  10 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  11 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  12 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  13 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  14 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  15 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  16 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  17 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  18 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  19 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  20 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  21 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  22 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  23 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  24 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  25 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  26 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  27 ] Run job   0 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 28.00 )<br>[ time  28 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  29 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  30 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  31 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  32 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  33 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  34 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  35 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  36 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  37 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  38 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  39 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  40 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  41 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  42 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  43 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  44 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  45 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  46 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  47 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  48 ] Run job   1 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 49.00 )<br>[ time  49 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  50 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  51 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  52 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  53 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  54 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  55 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  56 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  57 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  58 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs<br>[ time  59 ] Run job   2 <span class="hljs-keyword">for</span> 1.00 secs ( DONE at 60.00 )<br><br>Final statistics:<br>Job   0 -- Response: 0.00  Turnaround 28.00  Wait 18.00<br>Job   1 -- Response: 1.00  Turnaround 49.00  Wait 29.00<br>Job   2 -- Response: 2.00  Turnaround 60.00  Wait 30.00<br><br>Average -- Response: 1.00  Turnaround 45.67  Wait 25.67<br></code></pre></td></tr></table></figure> </details><p>采用<code>RR</code>策略的时候通过轮转运行三个程序，达到类似&quot;同时&quot;运行程序的效果，缩短了任务的反应时间。缺点是由于轮询过程会同时运行其他任务，因此总体的完成时刻和等待时间都会延长。</p></li><li><p>由于SJF是“短任务优先”的调度策略，因此当到达的任务顺序为先短时间的任务，后长时间任务的时候，SJF和FIFO的周转时间是相同的</p></li><li><p>当RR策略的量子时间大于等于SJF的单个任务最长工作时间时，SJF和RR可以提供相同的响应时间</p></li><li><p>当工作长度逐渐增加的时候，SJF的响应时间会逐渐增加，因为SJF必须要完成一个完整的任务才会运行下一个任务，因此后面的任务响应时间必须等待前一个任务的完成，模拟省略。</p></li><li><p>假定所有任务的长度都大于量子长度，且完成任务的时间都为量子长度的倍数，则可推得以下公式</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>i</mi><mi>Q</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>Q</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>i</mi></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>Q</mi><mo>∗</mo><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><mi>N</mi></mfrac><mo>=</mo><mfrac><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{\sum_{i=1}^{N-1} iQ}{N}=\frac{Q \sum_{i=1}^{N-1} i}{N}=\frac{Q * \frac{N(N-1)}{2}}{N}=\frac{Q(N-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.356941em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.670941em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897100000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.356941em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.670941em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897100000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.431em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.745em;"><span style="top:-2.324em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.2399999999999998em;"><span class="pstrut" style="height:3.01em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.745em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：程序上下文切换的开销</title>
    <link href="/p/4b65fa48.html"/>
    <url>/p/4b65fa48.html</url>
    
    <content type="html"><![CDATA[<h2 id="第六章受限制直接执行上下文切换"><a class="markdownIt-Anchor" href="#第六章受限制直接执行上下文切换"></a> 第六章：受限制直接执行/上下文切换</h2><h3 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h3><p>由于该实验要求在单个CPU上运行两个进程并在他们两个UNIX管道，而书中介绍的<code>sche_affinity()</code>函数的具体调用不是很清楚，所以这里通过<code>Docker</code>的参数限制，创建了一个只使用宿主机一个CPU资源的容器进行实验。</p><p>单核<code>Docker</code>容器的创建</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -it -d --cpuset-cpus=<span class="hljs-string">&quot;0&quot;</span> --name=os ubuntu:latest</span><br></code></pre></td></tr></table></figure><blockquote><p>注：在以上环境中如果使用函数查询CPU核心数依旧可以发现为<code>16</code>或其他多核，但是在通过指令<code>stress -c 4</code>实际测试后，性能只会在宿主机的单一CPU核心上运行，不影响实验。但是如果在创建<code>Docker</code>容器的时候使用的是<code>--cpus=1</code>，由于负载均衡，并不能达到单核进行实验的目的。</p></blockquote><h3 id="测量思路"><a class="markdownIt-Anchor" href="#测量思路"></a> 测量思路</h3><ol><li><p>通过<code>gettimeofday()</code>增加时间戳函数，获取执行时间</p></li><li><p>创建10个管道，循环5次，每次循环的时候分别在两个管道之间反复通信，并输出上下文切换时间差</p></li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-comment">// 标记时间戳</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">getTimeTick</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span>;</span><br>    gettimeofday(&amp;tv, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> tv.tv_usec;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建十个管道用于读写测试</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">10</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(fd[i]) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">char</span> timeWrite[<span class="hljs-number">256</span>], timeRead[<span class="hljs-number">256</span>];<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> rc = fork();<br>        <span class="hljs-keyword">switch</span> (rc)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <span class="hljs-comment">// error</span><br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-comment">// 从管道一中读取数据，如果管道一中没有数据，则阻塞等待</span><br>            read(fd[i][<span class="hljs-number">0</span>], timeRead, <span class="hljs-keyword">sizeof</span>(timeRead));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read - Write %d: %lu\n&quot;</span>, i, getTimeTick() - atol(timeRead));<br>            <span class="hljs-comment">// 将时间写入管道二</span><br>            <span class="hljs-built_in">sprintf</span>(timeWrite, <span class="hljs-string">&quot;%lu&quot;</span>, getTimeTick());<br>            write(fd[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], timeWrite, <span class="hljs-keyword">sizeof</span>(timeWrite));<br>            <span class="hljs-comment">// 从管道一中读取数据，并计算进程切换的总时间</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 将时间写入管道一</span><br>            <span class="hljs-built_in">sprintf</span>(timeWrite, <span class="hljs-string">&quot;%lu&quot;</span>, getTimeTick());<br>            write(fd[i][<span class="hljs-number">1</span>], timeWrite, <span class="hljs-keyword">sizeof</span>(timeWrite));<br>            <span class="hljs-comment">// 由于在执行完write之后会继续执行主进程，下方的read也会运行，因此最后结果中奇数进程的结果时间会比偶数进程的时间长，正确答案应该靠近偶数</span><br>            <span class="hljs-comment">// 从管道二读取数据，如果管道二中没有数据，则阻塞等待</span><br>            read(fd[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], timeRead, <span class="hljs-keyword">sizeof</span>(timeRead));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read - Write %d: %lu\n&quot;</span>, i + <span class="hljs-number">1</span>, getTimeTick() - atol(timeRead));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测量结果"><a class="markdownIt-Anchor" href="#测量结果"></a> 测量结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Read - Write 0: 24<br>Read - Write 1: 7<br>Read - Write 2: 16<br>Read - Write 3: 6<br>Read - Write 4: 17<br>Read - Write 5: 7<br>Read - Write 6: 17<br>Read - Write 7: 6<br>Read - Write 8: 18<br>Read - Write 9: 9<br></code></pre></td></tr></table></figure><h3 id="结果差错"><a class="markdownIt-Anchor" href="#结果差错"></a> 结果差错</h3><p>由于在执行完write之后会继续执行主进程，下方的read也会运行，因此最后结果中奇数进程的结果时间会比偶数进程的时间长，正确答案应该靠近偶数（已经在代码中用注释写明）。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：进程的简单使用</title>
    <link href="/p/897b63ef.html"/>
    <url>/p/897b63ef.html</url>
    
    <content type="html"><![CDATA[<h2 id="第五章进程api"><a class="markdownIt-Anchor" href="#第五章进程api"></a> 第五章：进程API</h2><ol><li><p>子进程和父进程的变量<code>x</code>的值内容相互独立。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// child process</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child: %d\n&quot;</span>, x);<br>        <span class="hljs-comment">// 子进程变量增加100</span><br>        x += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child + 100: %d\n&quot;</span>, x);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 父进程在子进程执行完毕后执行</span><br>        <span class="hljs-type">int</span> wc = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// parent process</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent: %d\n&quot;</span>, x);<br>        <span class="hljs-comment">// 父进程变量增加100</span><br>        x += <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent + 100: %d\n&quot;</span>, x);<br>    &#125;<br>    <span class="hljs-comment">// 分别再次输入最后的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Final Address: %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">Child: 100<br>Child + 100: 200<br>Final Address: 200<br>Parent: 100<br>Parent + 100: 200<br>Final Address: 200<br></code></pre></td></tr></table></figure></li><li><p>同时打开文件<code>p4.output</code>并且分别写入<code>Child process</code>和<code>Parent Process</code>，可以正常并发写入。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// close stdout and open output file</span><br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0700</span>);<br><br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果（p4.output文件）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Child process<br>Parent process<br></code></pre></td></tr></table></figure><p>或（并发输出的先后顺序不同）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">Parent process<br>Child process<br></code></pre></td></tr></table></figure></li><li><p>题目要求的是在不适用<code>wait()</code>函数下实现子进程和父进程的先后，通过<code>vfork()</code>函数可以实现</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// close stdout and open output file</span><br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./p4.output&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0700</span>);<br>    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">vfork</span>();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据结果可以参考题目2的第一个情况。不过这里插入<a href="https://stackoverflow.com/a/50005978">Stack Overflow</a>上书原作者的话作为备注：</p><blockquote><p>Without calling wait() is hard, and not really the main point. What you did – learning about signals on your own – is a good sign, showing you will seek out deeper knowledge. Good for you!</p><p>Later, you’ll be able to use a shared memory segment, and either condition variables or semaphores, to solve this problem.</p></blockquote></li><li><p>针对不同的调用和变种，写了一篇详细的博客进行解析：<a href="2022-3-19-exec-in-cpp.md">区分不同exec()形式</a></p></li><li><p>在父进程使用<code>wait()</code>，等待子进程完成后，<code>wait()</code>会返回子进程的<code>pid</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fork failed&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Return Value of wait() is %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">I am child process 4878<br>I am parent process 4873<br>Return Value of <span class="hljs-built_in">wait</span>() is 4878<br></code></pre></td></tr></table></figure><p>在子进程中使用wait()则会返回<code>-1</code>，并且在失败后依旧会执行当前子进程</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fork failed&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> fake_ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fake_ws = %d\n&quot;</span>, fake_ws);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent process %d\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Return Value of wait() is %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">I am child process 5011<br>fake_ws = -1<br>Test<br>I am parent process 5006<br>Return Value of <span class="hljs-built_in">wait</span>() is 5011<br></code></pre></td></tr></table></figure></li><li><p>针对<code>waitpid()</code>的使用，总结了笔记：<a href="2022-3-23-wait-in-linux.md">waitpid()调用</a></p></li><li><p>子进程中关闭标准输出，父进程输出子进程和本身<code>pid</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rc = fork();<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from child\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> ws = <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from parent, child exited with status %d\n&quot;</span>, ws);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果，子进程中的输出被关闭，只有父进程输出。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello from parent, child exited with status 1326<br></code></pre></td></tr></table></figure></li><li><p>通过pipe()管道进行传输数据</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 创建两个文件标示符</span><br>    <span class="hljs-type">int</span> rc_pipe = <span class="hljs-built_in">pipe</span>(fd); <span class="hljs-comment">// 创建管道</span><br><br>    <span class="hljs-type">char</span> msg[] = <span class="hljs-string">&quot;Hello_World!&quot;</span>; <span class="hljs-comment">// 用于输出的字符串</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">100</span>];              <span class="hljs-comment">// 用于输出的缓冲区</span><br><br>    <span class="hljs-type">int</span> rc_1 = fork(); <span class="hljs-comment">// 创建第一个进程</span><br><br>    <span class="hljs-keyword">if</span> (rc_1 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process 1: %d\n&quot;</span>, i);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);               <span class="hljs-comment">// 为防止文件读写出现问题，关闭读取端，只允许写入</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>], STDOUT_FILENO); <span class="hljs-comment">// 将标准输出重定向到管道的写入端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg);          <span class="hljs-comment">// 输出字符串到标准输出，然后重定向至管道的写入端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);               <span class="hljs-comment">// 关闭管道的写入端</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                    <span class="hljs-comment">// 结束当前进程</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> rc_2 = fork();<br><br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 即使通过sleep()让第二个进程等待，由于第一个进程的输入管道没有内容，所以第二个进程的scanf会等待至第一个进程将数据写入缓冲区</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child Process 2: %d\n&quot;</span>, i);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);              <span class="hljs-comment">// 为防止文件读写出现问题，关闭写入端，只允许读取</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>], STDIN_FILENO); <span class="hljs-comment">// 将标准输入重定向到管道的读取端</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buff);         <span class="hljs-comment">// 从标准输入读取字符串，然后重定向至管道的读取端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);              <span class="hljs-comment">// 关闭管道的读取端</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buff);        <span class="hljs-comment">// 输出由管道传输的字符串</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                   <span class="hljs-comment">// 结束当前进程</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Child Process 1: 0<br>Child Process 2: 0<br>Child Process 2: 1<br>Child Process 1: 1<br>Child Process 2: 2<br>Child Process 1: 2<br>Child Process 1: 3  <span class="hljs-comment"># 从这个时候开始，rc_2在等待rc_1通过管道传入&quot;Hello World!&quot;</span><br>Child Process 1: 4<br>Hello_World!        <span class="hljs-comment"># rc_2通过管道读取到了内容，进行输出</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统中waitpid函数的使用实例</title>
    <link href="/p/840f43e7.html"/>
    <url>/p/840f43e7.html</url>
    
    <content type="html"><![CDATA[<p>在写完<code>OSTEP</code>第五章课后习题之后，通过第八题的答案记录一下自己目前对<code>waitpid()</code>的尝试结果，目前的尝试仅限于进程执行的阻塞和等待，轮询和非阻塞的状态暂时没有遇到，日后补充。</p><h2 id="进程等待"><a class="markdownIt-Anchor" href="#进程等待"></a> 进程等待</h2><p><code>waitpid()</code>不能用于子进程等待更早的另外一个子进程，如果尝试运行则会返回<code>-1</code>。（在父进程中则等待并返回子进程对应的<code>pid</code>)</p><p>这里举例说明，以下为一个不包含任何<code>waitpid()</code>的原始代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建第一个子进程</span><br>    <span class="hljs-type">int</span> rc_1 = fork(); <br>    <span class="hljs-keyword">if</span> (rc_1 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建第二个子进程</span><br>    <span class="hljs-type">int</span> rc_2 = fork();<br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码通过<code>waitpid()</code>函数可以实现在<code>rc_1</code>和<code>rc_2</code>都执行完毕之后，再执行主进程的内容，修改如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建第一个子进程</span><br>    <span class="hljs-type">int</span> rc_1 = fork();<br>    ...<br><br>    <span class="hljs-comment">// 创建第二个子进程</span><br>    <span class="hljs-type">int</span> rc_2 = fork();<br>    ...<br><br>    <span class="hljs-built_in">waitpid</span>(rc_1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待第一个进程(pid为rc_1的进程)结束</span><br>    <span class="hljs-built_in">waitpid</span>(rc_2, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待第二个进程(pid为rc_2的进程)结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在子进程中调用<code>waitpid()</code>是不能做到让<code>rc_2</code>等待<code>rc_1</code>的。<a href="https://stackoverflow.com/questions/17330182/what-happens-if-i-use-wait-in-child-process">参考:stackoverflow</a></p><p>比如修改<code>rc_2</code>的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rc_2 = fork();<br>    <span class="hljs-keyword">if</span> (rc_2 == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> wr = <span class="hljs-built_in">waitpid</span>(rc_1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过以上的代码并不能让<code>rc_2</code>等待<code>rc_1</code>，如果尝试输出<code>wr</code>会得到<code>wr == -1</code>（在父进程中则应该是等待进程的pid）</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中不同版本exec函数区分</title>
    <link href="/p/b9e46cb4.html"/>
    <url>/p/b9e46cb4.html</url>
    
    <content type="html"><![CDATA[<p>该问题为<code>OSTEP</code>第五章<code>进程API</code>上的一个问题，在搜<code>Stack overflow</code>的时候发现一个很好记的答案，单独写一个博客记录一下</p><h2 id="参考回答"><a class="markdownIt-Anchor" href="#参考回答"></a> 参考回答</h2><ol><li><a href="https://stackoverflow.com/a/5769803">what-are-the-different-versions-of-exec-used-for-in-c-and-c</a></li></ol><h2 id="翻译摘抄"><a class="markdownIt-Anchor" href="#翻译摘抄"></a> 翻译摘抄</h2><p>对于<code>exec()</code>函数，在C/C++中有以下几个不同的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>其中不同版本的区别通过函数名可以分为以下几个大类：</p><h3 id="l和v"><a class="markdownIt-Anchor" href="#l和v"></a> L和V</h3><ul><li><p>L：L在这里指的是<code>list</code>，执行的时候的将参数以类似如下方式传入：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">execl</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)<br></code></pre></td></tr></table></figure><p>其中省略号代表了后续分别独立传入的参数，其中，第一个参数应是正在执行的文件关联的文件名，并且参数以<code>空字符NULL</code>作为结尾的判定。</p></li><li><p>V: V在这里指的是<code>vector</code>，执行的时候以<code>char*</code>的形式传入执行指令</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br></code></pre></td></tr></table></figure><p>对于不确定传入参数的个数的时候，可以使用<code>vector</code>来执行程序。使用带<code>v</code>的函数的时候，首先传入的第一个<code>pathname</code>是指向可执行文件的路径，后面传入的<code>argv[]</code>中，第一个<code>argv</code>的位置上按习惯为可执行文件的名字，后面<code>argv+1</code>等参数则是实际需要调用的可执行文件的参数、</p></li></ul><p>有的命令执行的时候，我们并不知道要传入的参数有几个，而有的命令则必须要一定数量的参数才能运行。通过分别调用带<code>l</code>或带<code>v</code>的函数，在不同的情况下执行某些特定命令很有用</p><h3 id="e"><a class="markdownIt-Anchor" href="#e"></a> E</h3><p>E在这里指代的是<code>Environment</code>，在结尾带<code>e</code>的<code>exec()</code>调用的时候的环境变量<code>env</code>与父进程的<code>env</code>并非一定相同，通过带<code>e</code>的函数即可在调用<code>exec()</code>的同时传入一个<code>env</code>供子进程使用</p><h3 id="p"><a class="markdownIt-Anchor" href="#p"></a> P</h3><p>P在这里指的是系统环境变量中的<code>PATH</code>，含有<code>p</code>的<code>exec()</code>在调用的时候会在系统变量的<code>PATH</code>当中寻找对应的可执行文件，而缺少<code>p</code>的<code>exec()</code>在执行的时候，如果在当前目录下没有对应的文件名字，则需要传入目标可执行文件的绝对或相对路径。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Python提交ncu每日健康信息</title>
    <link href="/p/cf0fd528.html"/>
    <url>/p/cf0fd528.html</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><ol><li>该方法目前稳定性尚不确定，<code>Token</code>有概率会不定时失效，如果使用后果自负</li><li>该方法仅作<code>Python</code>学习使用，了解原理后使用后果自负</li><li>疫情期间请以实际情况打卡汇报，切勿身体有状况而依旧以无状况打卡。</li></ol><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/24180606?theme=dark">简单三步，用 Python 发邮件 - 知乎 (zhihu.com)</a></li><li><a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">github action获取仓库secrets</a></li></ol><h2 id="实现的效果"><a class="markdownIt-Anchor" href="#实现的效果"></a> 实现的效果</h2><p>​通过Github Actions，在每天通过<code>cron</code>设定的时间实现企业微信打卡</p><h2 id="运行环境"><a class="markdownIt-Anchor" href="#运行环境"></a> 运行环境</h2><p>Github Actions</p><h2 id="需要准备的东西"><a class="markdownIt-Anchor" href="#需要准备的东西"></a> 需要准备的东西</h2><p>QQ号以及QQ的SMTP密码</p><h2 id="获取token"><a class="markdownIt-Anchor" href="#获取token"></a> 获取Token</h2><ol><li><p>在打卡界面中&quot;复制链接&quot;，并在电脑上打开</p><p><img src="https://lsky.halc.top/DH7lVf.png" alt="企业微信" /></p></li><li><p>电脑浏览器打开链接，按F12，此时可能是电子ID，不用管，在右上角找到<code>Network</code>，并打开。</p><p>(如果提示要按Ctrl+R，按就行)</p><p><img src="https://lsky.halc.top/Xl1nNE.png" alt="Network" /></p></li><li><p>在<code>Network</code>下方找到<code>loginByToken</code>，并且找到右边的<code>Token</code>信息，复制保存。</p><p><img src="https://lsky.halc.top/IpnCQJ.png" alt="TokenGet" /></p></li></ol><h2 id="获取qq邮箱的smtp密码"><a class="markdownIt-Anchor" href="#获取qq邮箱的smtp密码"></a> 获取QQ邮箱的SMTP密码</h2><p><a href="https://www.baidu.com/s?wd=%E8%8E%B7%E5%8F%96QQ%E9%82%AE%E7%AE%B1%E7%9A%84SMTP%E5%AF%86%E7%A0%81">百度搜索：获取QQ邮箱的SMTP密码</a></p><h2 id="编辑python脚本"><a class="markdownIt-Anchor" href="#编辑python脚本"></a> 编辑Python脚本</h2><p>大致思路就是通过对应接口抓包后发包即可，更新<code>Token</code>通过接口<code>LoginByToken</code>实现，打卡通过<code>SignIn</code>接口实现。<br />参考脚本：<a href="https://github.com/HalcyonAzure/Scripts/blob/master/python/ncu.py">Scripts/ncu.py</a></p><h2 id="运行脚本并测试"><a class="markdownIt-Anchor" href="#运行脚本并测试"></a> 运行脚本并测试</h2><p>为了仓库的信息安全，所有的密码通过Github仓库下secrets来进行设置，然后参考 <a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">github action获取仓库secrets</a> 中提及的方法修改设置即可。</p><h2 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h2><p><em><strong>每个人都有义务在疫情大环境下对自己的真实信息负责</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github的PAT口令的密码记录和保存方案</title>
    <link href="/p/a126ef4d.html"/>
    <url>/p/a126ef4d.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ul><li><a href="https://stackoverflow.com/a/51505417">Where to store my Git personal access token?</a></li><li><a href="https://github.com/GitCredentialManager/git-credential-manager/blob/main/docs/credstores.md">GitCreadentitalManager</a></li><li><a href="https://git-scm.com/docs/gitcredentials">GitCredential</a></li></ul><h2 id="简单方案"><a class="markdownIt-Anchor" href="#简单方案"></a> 简单方案</h2><p>最简单的方案是讲自己的配置文件用明文保存，在<a href="https://git-scm.com/docs/gitcredentials">文档</a>中查询可知道指令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>在设置<code>credential.helper</code>为全局<code>store</code>之后，下一次的验证会出现提示并保存，之后则会使用存在<code>~/.git-credentials</code>的明文帐号密码进行登入</p><h2 id="加密方案"><a class="markdownIt-Anchor" href="#加密方案"></a> 加密方案</h2><p>为了更好的管理Github的Token，需要一个Git凭证助手来帮我们记忆用户名和对应的PAT，以下为<code>Git-Credential-Manager-Core</code>引导</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>安装<a href="https://github.com/microsoft/Git-Credential-Manager-Core/releases/">Lateset Release</a>的GCM，并初始化设置</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i &lt;path-to-package&gt;<br>git-credential-manager-core configure<br></code></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>在Linux上使用GCM需要额外设置<code>credential.credentialStore</code>，其中包含的设置方法如下：</p><h4 id="通过secret-service-api来存储"><a class="markdownIt-Anchor" href="#通过secret-service-api来存储"></a> 通过<a href="https://specifications.freedesktop.org/secret-service/latest/">Secret Service API</a>来存储</h4><p><em><strong>该方法需要系统有GUI显示功能</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=secretservice<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore secretservice<br></code></pre></td></tr></table></figure><p>这个办法通过<code>libsecret</code>库来和<code>Secret Service</code>进行交互，所有的凭证都存储在“collections”当中。如果要查看的话，可以通过<code>secret-tool</code>或<code>seahorse</code>来进行查看。注：在请求用户帐号信息的时候会通过GUI来进行交互。</p><h4 id="通过git自带的凭证缓存机制来存储"><a class="markdownIt-Anchor" href="#通过git自带的凭证缓存机制来存储"></a> 通过Git自带的凭证缓存机制来存储</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=cache<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore cache<br></code></pre></td></tr></table></figure><p>这种方法保存的密码不会以可长期读取的文件形式存在硬盘上，如果是需要链接一些临时性的服务可以用这个方法。默认来说<code>git credential-cache</code>会储凭证900s，可以通过如下指令修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_CACHE_OPTIONS=<span class="hljs-string">&quot;--timeout 300&quot;</span><br><span class="hljs-comment"># or</span><br>git config --global credential.cacheOptions <span class="hljs-string">&quot;--timeout 300&quot;</span><br></code></pre></td></tr></table></figure><h4 id="通过纯文本的形式进行保存"><a class="markdownIt-Anchor" href="#通过纯文本的形式进行保存"></a> 通过纯文本的形式进行保存</h4><p><em><strong>这办法不安全</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=plaintext<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore plaintext<br></code></pre></td></tr></table></figure><p>这种办法保存的密码默认会存在<code>~/.gcm/store</code>目录下，目录可通过<code>GCM_PLAINTEXT_STORE_PATH</code>环境变量来进行修改，如果文件不存在则会被创建新创建的文件权限为<code>700</code>.</p><h4 id="通过gpgpass进行存储"><a class="markdownIt-Anchor" href="#通过gpgpass进行存储"></a> 通过GPG/pass进行存储</h4><p><em><strong>这种方法需要有一对GPG密钥</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GCM_CREDENTIAL_STORE=gpg<br><span class="hljs-comment"># or</span><br>git config --global credential.credentialStore gpg<br></code></pre></td></tr></table></figure><p>这种办法主要使用了<a href="https://www.passwordstore.org/">pass</a>工具，默认情况下文件会保存在<code>~/.password-store</code>文件下，该目录可以通<code>PASSWORD_STORE_DIR</code>来进行修改。在使用这种办法进行凭证管理之前，首先需要通过一对GPG密钥对<code>pass</code>进行初始化操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pass init &lt;gpg-id&gt;<br></code></pre></td></tr></table></figure><p>这里的&lt;gpg-id&gt;指的是当前使用gpg密钥对的用户的系统id。通过以下指令可以创建一个自己的gpg密钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --gen-key<br><span class="hljs-comment"># and follow prompts</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP：进程的概念理解</title>
    <link href="/p/e328a303.html"/>
    <url>/p/e328a303.html</url>
    
    <content type="html"><![CDATA[<h2 id="第四章进程"><a class="markdownIt-Anchor" href="#第四章进程"></a> 第四章：进程</h2><p>作业来自: <a href="https://github.com/remzi-arpacidusseau/ostep-homework">ostep-homework</a></p><ol><li><p>两个程序都只使用CPU，所以CPU的利用率是100%，测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1        RUN:cpu         READY             1          <br>  2        RUN:cpu         READY             1          <br>  3        RUN:cpu         READY             1          <br>  4        RUN:cpu         READY             1          <br>  5        RUN:cpu         READY             1          <br>  6           DONE       RUN:cpu             1          <br>  7           DONE       RUN:cpu             1          <br>  8           DONE       RUN:cpu             1          <br>  9           DONE       RUN:cpu             1          <br>10           DONE       RUN:cpu             1          <br><br>Stats: Total Time 10<br>Stats: CPU Busy 10 (100.00%)<br>Stats: IO Busy  0 (0.00%)<br></code></pre></td></tr></table></figure></li><li><p>总共使用了11 ticks的时间，测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1        RUN:cpu         READY             1          <br>  2        RUN:cpu         READY             1          <br>  3        RUN:cpu         READY             1          <br>  4        RUN:cpu         READY             1          <br>  5           DONE        RUN:io             1          <br>  6           DONE       WAITING                           1<br>  7           DONE       WAITING                           1<br>  8           DONE       WAITING                           1<br>  9           DONE       WAITING                           1<br>10           DONE       WAITING                           1<br>11*          DONE   RUN:io_done             1        <br></code></pre></td></tr></table></figure></li><li><p>交换顺序后，在PID0进行io操作的时候，PID1会切换成RUNNING的状态，提高了CPU的利用效率，所以交换顺序重要。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING       RUN:cpu             1             1<br>  3        WAITING       RUN:cpu             1             1<br>  4        WAITING       RUN:cpu             1             1<br>  5        WAITING       RUN:cpu             1             1<br>  6        WAITING          DONE                           1<br>  7*   RUN:io_done          DONE             1          <br></code></pre></td></tr></table></figure></li><li><p>由于加上了<code>SWITCH_ON_END</code>的标签，此时PID0进行IO操作的时候CPU会空闲等待至IO操作完成，浪费了一定的时间。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING         READY                           1<br>  3        WAITING         READY                           1<br>  4        WAITING         READY                           1<br>  5        WAITING         READY                           1<br>  6        WAITING         READY                           1<br>  7*   RUN:io_done         READY             1          <br>  8           DONE       RUN:cpu             1          <br>  9           DONE       RUN:cpu             1          <br>10           DONE       RUN:cpu             1          <br>11           DONE       RUN:cpu             1  <br></code></pre></td></tr></table></figure></li><li><p>由于这次会在等待IO的时候进行进程的切换，所以在io操作时，CPU没有等待，而是切换到了另外一个进程上继续工作，提高了利用率。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1           CPU           IOs<br>  1         RUN:io         READY             1          <br>  2        WAITING       RUN:cpu             1             1<br>  3        WAITING       RUN:cpu             1             1<br>  4        WAITING       RUN:cpu             1             1<br>  5        WAITING       RUN:cpu             1             1<br>  6        WAITING          DONE                           1<br>  7*   RUN:io_done          DONE             1   <br></code></pre></td></tr></table></figure></li><li><p>由于IO操作的优先级不是最高的，即使io操作的WAITING结束了，也会等待CPU先将其他进程执行之后，再对IO进行切换，由于IO操作需要消耗比较多的额外时间，而这部分时间没有被CPU利用，所以系统资源没有得到有效利用。测试可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs<br>  1         RUN:io         READY         READY         READY             1          <br>  2        WAITING       RUN:cpu         READY         READY             1             1<br>  3        WAITING       RUN:cpu         READY         READY             1             1<br>  4        WAITING       RUN:cpu         READY         READY             1             1<br>  5        WAITING       RUN:cpu         READY         READY             1             1<br>  6        WAITING       RUN:cpu         READY         READY             1             1<br>  7*         READY          DONE       RUN:cpu         READY             1          <br>  8          READY          DONE       RUN:cpu         READY             1          <br>  9          READY          DONE       RUN:cpu         READY             1          <br>10          READY          DONE       RUN:cpu         READY             1          <br>11          READY          DONE       RUN:cpu         READY             1          <br>12          READY          DONE          DONE       RUN:cpu             1          <br>13          READY          DONE          DONE       RUN:cpu             1          <br>14          READY          DONE          DONE       RUN:cpu             1          <br>15          READY          DONE          DONE       RUN:cpu             1          <br>16          READY          DONE          DONE       RUN:cpu             1          <br>17    RUN:io_done          DONE          DONE          DONE             1          <br>18         RUN:io          DONE          DONE          DONE             1          <br>19        WAITING          DONE          DONE          DONE                           1<br>20        WAITING          DONE          DONE          DONE                           1<br>21        WAITING          DONE          DONE          DONE                           1<br>22        WAITING          DONE          DONE          DONE                           1<br>23        WAITING          DONE          DONE          DONE                           1<br>24*   RUN:io_done          DONE          DONE          DONE             1          <br>25         RUN:io          DONE          DONE          DONE             1          <br>26        WAITING          DONE          DONE          DONE                           1<br>27        WAITING          DONE          DONE          DONE                           1<br>28        WAITING          DONE          DONE          DONE                           1<br>29        WAITING          DONE          DONE          DONE                           1<br>30        WAITING          DONE          DONE          DONE                           1<br>31*   RUN:io_done          DONE          DONE          DONE             1 <br></code></pre></td></tr></table></figure></li><li><p>在使用了IMMEDIATE标签后，每次io_done之后CPU都会先切换io操作，然后用io处理的时间来处理其他进程，提高了系统资源的利用率。测试如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh">Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs<br>  1         RUN:io         READY         READY         READY             1          <br>  2        WAITING       RUN:cpu         READY         READY             1             1<br>  3        WAITING       RUN:cpu         READY         READY             1             1<br>  4        WAITING       RUN:cpu         READY         READY             1             1<br>  5        WAITING       RUN:cpu         READY         READY             1             1<br>  6        WAITING       RUN:cpu         READY         READY             1             1<br>  7*   RUN:io_done          DONE         READY         READY             1          <br>  8         RUN:io          DONE         READY         READY             1          <br>  9        WAITING          DONE       RUN:cpu         READY             1             1<br>10        WAITING          DONE       RUN:cpu         READY             1             1<br>11        WAITING          DONE       RUN:cpu         READY             1             1<br>12        WAITING          DONE       RUN:cpu         READY             1             1<br>13        WAITING          DONE       RUN:cpu         READY             1             1<br>14*   RUN:io_done          DONE          DONE         READY             1          <br>15         RUN:io          DONE          DONE         READY             1          <br>16        WAITING          DONE          DONE       RUN:cpu             1             1<br>17        WAITING          DONE          DONE       RUN:cpu             1             1<br>18        WAITING          DONE          DONE       RUN:cpu             1             1<br>19        WAITING          DONE          DONE       RUN:cpu             1             1<br>20        WAITING          DONE          DONE       RUN:cpu             1             1<br>21*   RUN:io_done          DONE          DONE          DONE             1          <br></code></pre></td></tr></table></figure></li><li><p>开放题随机，和前七题大致相同。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结：2022年2月</title>
    <link href="/p/ba5740b2.html"/>
    <url>/p/ba5740b2.html</url>
    
    <content type="html"><![CDATA[<p>这个月因为游戏的问题，我又犯了拖延症的老毛病，导致计划中的学习任务没有一个完成。玩起游戏的时候总会高估自己的效率，导致就想着一直玩到通关为止。规划的二月份的学习计划没有一个完成的事实，让我感到挺沮丧的。但我还是觉得要写一篇总结来记录这个月的所做所为。</p><h2 id="做了的事情"><a class="markdownIt-Anchor" href="#做了的事情"></a> 做了的事情</h2><h3 id="学习方面"><a class="markdownIt-Anchor" href="#学习方面"></a> 学习方面</h3><p>尝试了用Postman工具进行抓包，不过由于自己偷懒没仔细看文档以及对代理设置的不当配置，前前后后断断续续折腾了四五天还是换回Wireshark进行数据抓包，Python抓包发包本身学习倒是简单不少，一到两个小时就完成了学习，Appium目前也还没有开始接触。Rust相关的课程完全搁置没有进度。CS144的lab搭建好环境并在别人现成已有的Blog下完成了第一个实验，但是由于照葫芦画瓢，成就感很低并且了解不彻底，需要重新完成。力扣打卡断断续续持续了半个月，在2.25艾尔登法环发售到3.6通关群星结局过程没有其他进度。</p><h3 id="游戏方面"><a class="markdownIt-Anchor" href="#游戏方面"></a> 游戏方面</h3><p>虽然二月份就学习内容上来说摆烂几乎没有进度，但是用了一个礼拜的高强度游戏来感悟宫崎老贼的“魂系”游戏也完全不会让我觉得是在浪费时间。超大的世界观框架+完全自由的探索+五花八门的怪物+永远可以带来惊喜的各种武器，在初高中的时候总幻想一个所有人都可以一起探索的世界，这个世界在玩艾尔登法环的时候完全能够切身体验。在目前的开荒时期，除了自己推图可以发现各种各样的东西，同时最让人流连于其中的则是在目前世界观巨大的情况下，还没有完备的攻略来引导玩家“必须/流水线”的一套教程，同时全网玩家又在一起对这个世界进行发掘，让这个本来“单机”的游戏在某种意义上又变成了全网大家一起探索的异次元，这种开荒的乐趣加上老头环本身庞大的世界观绝对能称为我心中的“年度游戏”。</p><h2 id="三月份要做的事情"><a class="markdownIt-Anchor" href="#三月份要做的事情"></a> 三月份要做的事情</h2><h3 id="学习内容"><a class="markdownIt-Anchor" href="#学习内容"></a> 学习内容</h3><ul><li>无，完成之前二月份的任务就算成功</li></ul><h3 id="生活方面"><a class="markdownIt-Anchor" href="#生活方面"></a> 生活方面</h3><ul><li>在不下雨的天气每天跑至少1.2km，同时保持良好的作息习惯</li><li>饮食上一个礼拜只吃一次非常规饮食，同时定期吃水果，改掉只吃维生素药片的习惯</li></ul><p>这几天玩游戏的时候一直觉得这个月做的事情太少了，心里很不舒服。看到知乎一些“焦虑推送文”的时候也总觉得自己不务正业。造成这种情况的主要原因还是对玩艾尔登法环的时候一心想着开荒，对时间分配及其不合理导致状态的失衡，不过就取舍来说，作为几年难得一遇的优质游戏，和好兄弟一起联机攻克boss和开荒的快感不知下次得等几年，并不觉得这一个礼拜的时间有所亏欠，只是需要在这个月加把劲，把二月欠的任务完成！</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu上开启内核BBR算法来提高TCP吞吐性能</title>
    <link href="/p/2f2e6810.html"/>
    <url>/p/2f2e6810.html</url>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="https://wiki.crowncloud.net/?How_to_enable_BBR_on_Ubuntu_20_04">How to enable BBR on Ubuntu 20.04</a></p><h2 id="拥塞控制算法"><a class="markdownIt-Anchor" href="#拥塞控制算法"></a> 拥塞控制算法</h2><p>默认情况下Linux 使用 Reno 和 CUBIC 拥塞控制算法，Linux kernal 4.9以上版本的内核已经自带该功能，由于Ubuntu 20.04的为5.4.0 kernel，我们可以直接启用</p><p>通过以下指令检查目前可选择的拥塞控制算法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_available_congestion_control<br></code></pre></td></tr></table></figure><p>输出大致为（可用的算法有reno和cubic两种）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_available_congestion_control<br>net.ipv4.tcp_available_congestion_control = reno cubic<br></code></pre></td></tr></table></figure><p>通过以下指令检查目前的拥塞控制算法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_congestion_control<br></code></pre></td></tr></table></figure><p>输出大致为（目前是cubic)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_congestion_control<br>net.ipv4.tcp_congestion_control = cubic<br></code></pre></td></tr></table></figure><h2 id="在ubuntu中启用tcp-bbr"><a class="markdownIt-Anchor" href="#在ubuntu中启用tcp-bbr"></a> 在Ubuntu中启用TCP BBR</h2><ol><li><p>在文件<code>etc/sysctl.conf</code>中写入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">net.core.default_qdisc=fq<br>net.ipv4.tcp_congestion_control=bbr<br></code></pre></td></tr></table></figure><p>保存并退出</p></li><li><p>重置<code>sysctl</code>设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sysctl -p<br></code></pre></td></tr></table></figure><p>此时会有大致输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl -p<br>net.core.default_qdisc = fq<br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure></li><li><p>检查BBR是否在系统中正确启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_congestion_control<br></code></pre></td></tr></table></figure><p>大致输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vps:~## sysctl net.ipv4.tcp_congestion_control<br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure></li></ol><p>完成</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结： 2022年1月</title>
    <link href="/p/9130a701.html"/>
    <url>/p/9130a701.html</url>
    
    <content type="html"><![CDATA[<p>当我回顾这个月的所做所为时，我发现自己虽然有些困难和拖延，但还是完成了一些有意义的事情。学习了 Rust 的初级语法。虽然考完试后完全松懈没有进度，但我对 Rust 的学习充满了信心，希望在未来能够深入学习。</p><p>另外，也把家里的 Homelab 更换迁移成了 ESXi 基础的虚拟机，并在此之上将之前服务器上的服务器重新分开部署，每次折腾家里的<code>HomeLab</code>总能让我感觉成就感很足。此外，我还尝试了自己投稿文章，虽然初次尝试，但在机核的反馈中感觉有希望继续写下去。</p><h2 id="做了的事情"><a class="markdownIt-Anchor" href="#做了的事情"></a> 做了的事情</h2><p>虽然说是说这个月没有为本来的计划和目标努力，但还算是折腾了一些有意思的东西：</p><ul><li>学习了Rust的初级语法，在期末考试前完成了<a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Microsoft Learning上入门Rust</a>的40%内容，考完试后完全松懈没有进度。</li><li>把家里的Homelab更换迁移成了EXSi基础的虚拟机，并在此之上将之前服务器上的服务器重新分开部署</li><li>第一次尝试自己<a href="https://www.gcores.com/articles/146815">投稿文章</a>，在机核的反馈感觉有希望继续写下去</li></ul><p>在之外就是通宵熬夜生死存亡的期末考试复习了。</p><h2 id="二月份要做的事情"><a class="markdownIt-Anchor" href="#二月份要做的事情"></a> 二月份要做的事情</h2><h3 id="学习内容"><a class="markdownIt-Anchor" href="#学习内容"></a> 学习内容</h3><ul><li>学习一下Python对于网页抓包数据的一些模拟，和对于Appium的使用</li><li>完成Rust整个的入门课程</li><li>CS144的6个lab至少完成2个（考虑拖延的情况下），有时间充裕就完成3-4个</li><li>力扣每天题库非困难题打卡</li></ul><h3 id="折腾着自己玩玩"><a class="markdownIt-Anchor" href="#折腾着自己玩玩"></a> 折腾着自己玩玩</h3><ul><li>完成家里面Homelab关于流媒体服务器的部署</li><li>通过Python+Appium的组合，看看能不能全自动化学校企业微信打卡内容</li></ul><h3 id="生活方面"><a class="markdownIt-Anchor" href="#生活方面"></a> 生活方面</h3><ul><li>找2-3部电影看完，内容随意</li><li>开学前每天锻炼半小时，睡眠作息开始调整为十一点睡觉，六点到七点起床</li></ul><p>整个流程下来还是感觉和记流水帐一样吧，不过这样记录了以后感觉负罪感也强了一些，也算是最自己的一个监督。希望能离年初的目标越来越近。</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux通过alternatives切换程序版本环境</title>
    <link href="/p/afb272ac.html"/>
    <url>/p/afb272ac.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考帖子"><a class="markdownIt-Anchor" href="#参考帖子"></a> 参考帖子</h2><ol><li><a href="https://medium.com/analytics-vidhya/how-to-install-and-switch-between-different-python-versions-in-ubuntu-16-04-dc1726796b9b">How to install and switch between different python versions in ubuntu 16.04</a></li></ol><h2 id="具体操作"><a class="markdownIt-Anchor" href="#具体操作"></a> 具体操作</h2><p>在切换Java版本的时候，通过<code>update-alternatives</code>可以很方便的进行版本之间的切换，而在Python里面，如果用<code>Ubuntu</code>自己的<code>apt</code>包管理器同时下载了多个版本的<code>Python</code>的话，则需要自己手动对<code>Python</code>的版本进行切换设定（切换版本还有alias等方法，这里不提及）。指令如下：</p><ol><li><p>在安装了多个版本的Python之后（其他语言同理），通过类似以下指令的格式添加对应的程序优先级：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2<br></code></pre></td></tr></table></figure></li><li><p>由上面设置的程序指令为<code>python</code>，接下来通过以下指令对<code>python</code>的版本进行切换：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --config python<br></code></pre></td></tr></table></figure><p>输入之后可以见到类似如下的选择：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">There are 2 choices for the alternative python (providing /usr/bin/python).<br><br>Selection    Path                Priority   Status<br>------------------------------------------------------------<br>* 0            /usr/bin/python3.8   2         auto mode<br>1            /usr/bin/python2.7   1         manual mode<br>2            /usr/bin/python3.8   2         manual mode<br><br>Press &lt;enter&gt; to keep the current choice[*], or type selection number:<br></code></pre></td></tr></table></figure><p>只需要在number后面输入对应需要的优先级，即可对<code>python</code>的版本进行切换。</p></li></ol><blockquote><p>每次都会忘记是<code>update alternatives</code>还是<code>alternatives-update</code>，所以写一篇博客记录一下…自己还是太Native了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年度总结</title>
    <link href="/p/1153f279.html"/>
    <url>/p/1153f279.html</url>
    
    <content type="html"><![CDATA[<h2 id="开头"><a class="markdownIt-Anchor" href="#开头"></a> 开头</h2><p>往年本来都没有在年初或者年末的时候写一个一年总结的习惯，今年也算是突发奇想，打算写一篇博客稍微记录下自己的学习和生活。希望能在2022年里面养成时不时记录一下自己生活的习惯，养成正视自己的一个态度。</p><h2 id="性格变化"><a class="markdownIt-Anchor" href="#性格变化"></a> 性格变化</h2><p>从2020年高三高考结束，到2021年大一升大二，也算是对大学生活有了一些认知和了解。整个大一的时间不能说浑浑噩噩，但总觉得自己心里缺了点什么。</p><p>现在仔细想想感觉就是缺少对自己的一个自视，总觉得心里空空的，不自在。刚上大学的时候就对“信息差”这个词很敏感，整个大一的过程也感觉一直在忙忙碌碌的处理各种各样的“信息”。无论是平时上课、考试还是处理一些生活中的问题，也总是把能搜罗到的各种信息的优先级置于自己“能力”的优先级之上，对外界环境的信任远高于对自己的信任。</p><p>这种自己信任上的缺乏感在最近听<code>Daniel Sloss</code>的<code>Jigsaw(拼图)</code>的<a href="https://www.bilibili.com/video/BV1Qi4y1s72w?p=1">Live Show</a>之后，感觉悟到自己经常总是忽视自己，一直感觉空虚因而不断的向外界索取信息，大抵也就是自己尚且不能适应孤独的感觉。上了大学以后本来觉得能聊的人多了，孤独的感觉应该弱化了，但现在想想过去一年里面反而应该是越来越强了。想过也许是不是谈恋爱就能让自己生活不那么孤独，但现在想想，问题应该还是出在自己对自己的不信任上。</p><blockquote><p><em><strong>连自己都不能做到100%爱自己的话，也很难爱其他人</strong></em></p></blockquote><p>总之，希望在将来到的2022年里面，能增加自己正视自己的态度。争取每个月写一个总结，来达到”给自己泼一盆冷水醒一醒“的作用。</p><p><em><strong>有的话，说出来了才有力量警醒自己</strong></em></p><h2 id="能力技能"><a class="markdownIt-Anchor" href="#能力技能"></a> 能力技能</h2><p>这个学期除了学校本身的内容，学习密度最大的时候应该是年初倒腾软路由的时候开始的。从最初依赖带有GUI界面的<code>openwrt</code>的<code>luci</code>界面，到现在已经习惯了<code>terminal</code>的方式进行各种操作，这种对<code>Linux</code>一类命令行态度的转变有一种拿到了普罗米修斯的火把的感觉，一切原来觉得”麻烦“或者难以折腾的东西，突然都明朗了起来，即使遇到了问题，相比原来无脑cp各路解决方案的脚本指令，现在会下意识的思考和提前验证其中的原理和造成的影响了。</p><p>对于项目而言，去年算是或多或少接触或者熟悉了Nginx、Docker、MySQL等等零零碎碎的知识和技术，也搭建了一台以家里电脑为处理服务器，香港云服务器作为跳板的公网服务器，在上门也尝试部署过许多不同的demo或者项目，其中也通过对<code>ZeroTier</code>一类的工具的深入研究，也算是对计算机网络的学习和经验埋下了兴趣。</p><p>不过去年一年中，也和性格相关，大部分时候只是在通过搜刮各种”信息“，来搭建各种别人的项目然后进行一些很小的改动，一直在重复着<code>”遇到问题“-&gt;”寻找别人的解决方案“-&gt;”不断选择最优解并且排错“-&gt;”解决问题“</code>的过程，而总是不会把**”自己创造解决方案“排在首要位置。今年的博客内容也能体现我目前”知识密度“低下的严重不足，大部分时候只是写个机械性的总结草草了事，缺少很多思考和加工的过程。</p><h2 id="生活"><a class="markdownIt-Anchor" href="#生活"></a> 生活</h2><p>平时在学校一个人虽然自在，但也还是和在家里一样一直倾向于变化越少越好，很少出门，出门吃饭也都只是找平时能难得线下面对面聊的比较多的同学，线上聊的比较多的同学和学长就经常”社恐“了。</p><p>在今年年末的时候，高考那会的储蓄也算是消耗殆尽了，钱的概念也越来越深刻了。不过还算幸运的是有需要的东西基本上也都备齐了，之后需要的东西开销应该也不会很大，目前的电子产品和设备就足够我把玩好一阵子了。</p><p>今年上半年的时候一直在忙忙碌碌的在不同的互联网上”冲浪”，一直在到处寻找已有的工具和服务然后不断上手和试验。看上去很忙但实际上也都学的是一些花时间，而不用花精力就能学会的“三脚猫”功夫。下半年的话反而玩了好几款3A大作而觉得整一年都充实了不少（手柄玩游戏是真的闲适），总的效率上虽然没做什么事情，但情绪要比上半年积极快乐多了。</p><h2 id="目标和计划"><a class="markdownIt-Anchor" href="#目标和计划"></a> 目标和计划</h2><p>2022年也到了，之前也没做过啥新年计划，今年也算是第一年尝试看看了，姑且列出以下几个目标，看看年末的时候能实现多少吧：</p><ul><li>每个月写一篇总结，大致总结一下这个月发生了什么，就当是自己对自己态度的一个正视，也算是自己和自己对话了。</li><li>减肥，希望能减到<code>BMI</code>标准的水平。</li><li>接触至少三种不同的编程语言，了解相关的项目，并提交出自己的第一个PR</li><li>游戏开发入门，制作自己的一个游戏demo</li><li>学习一门额外的技能，目前的计划包括但不限于：<ul><li>日语入门（问就是二次元）</li><li>拾回Adobe全家桶</li><li>系统性学习建模软件</li></ul></li><li>争取能参加一次GameJam</li></ul><p>以上应该算是对2021年的一个缺胳膊少腿的总结吧，其中也发生了很多值得纪念和回味的细节事情，包括和不同的人相识又或者和第一次和同学去旅游，在旅游的时候又和曾经的同学见面…写博客的目的还是希望能把那些原来不会对别人，也不会对自己说的话记录下来，也是对自己的一个警示了。</p><p>2022年1月7号 - 凌晨3:14</p><p>（感冒还没好全 &amp; 期末预习备战中… 希望这学期别挂XD)</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快慢指针</title>
    <link href="/p/76495b47.html"/>
    <url>/p/76495b47.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容仅为刷题总结，只记录目前遇到过的情况，如果后面遇到了更多可能性再做记录。</p></blockquote><h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2><p>快慢指针的主要思想有点类似追击问题，通过让两个不同的小人以不同的速度在线性路径上行进，来招到某个特殊的相对位置。通常可以用来解决大致一下两类问题：</p><ol><li>线性路径上某特殊点的位置和对应的操作</li><li>判断链表中是否存在循环（以及循环的点位置）</li></ol><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>一般的思路是让两个不同的小人先以某一个相对的路径进行移动，之后再以一定倍率的相对速度进行继续移动，如果发生了『追击』、『相遇』或者『触底』等特殊事件的时候，就可以作为解题需要的特殊位置来进行处理。</p><h3 id="举例一回文链表"><a class="markdownIt-Anchor" href="#举例一回文链表"></a> 举例一：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h3><p>如何判断出链表的中点位置？</p><p>答：通过两个速度分别为<code>v</code>和<code>2v</code>的指针同时从表头开始出发，当<code>2v</code>速度的指针『触底』的时候，以速度<code>v</code>前进的指针指向的位置理应为中点。</p><blockquote><p>如果链表的长度为偶数的话，具体是停留在中间位置的左边还是右边要结合具体情况进行判断</p></blockquote><h3 id="举例二环形链表"><a class="markdownIt-Anchor" href="#举例二环形链表"></a> 举例二：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jbex5/">环形链表</a></h3><p>如何判断链表内是否有循环？</p><p>答：让两个不同速度的指针分别出发，如果有环存在的话，则必然会有两个指针在环内相遇。</p><h3 id="举例三环形链表-ii"><a class="markdownIt-Anchor" href="#举例三环形链表-ii"></a> 举例三：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jjhf6/">环形链表 II</a></h3><p>如何判断链表内开始进入环的位置？</p><p>答：让两个指针分别以速度<code>v</code>和<code>2v</code>出发，相遇则说明环存在。这个时候假入环前的长度为D，设环的长度为C，入环点到相遇点的距离为S1，相遇点重新回到入环点的距离则为S2。</p><ul><li>此时快指针比慢指针多走n圈，所以走的距离必然为<code>D+S1+nC</code></li><li>慢指针走一圈的时候，快指针能走两圈。所以相遇必然发声在第一个环内，所以慢指针走的距离为<code>D+S1</code></li><li>由于<code>2 * (D + S1) == D + S1 + nC</code>和<code>C = S1 + S2</code>，所以不难得出<code>D = (n - 1)(S1 + S2) + S2</code>，即<code>D = (n - 1)C + S2</code>的结论，翻译一下则为，入环点前面的长度D即为<strong>慢指针再走S2，到达入环点之后，再走n-1圈的长度</strong>。</li><li>所以这个时候只需要再设定一个指针，让它从头开始走，当走到入环点D的时候，理论上来说慢指针也将走完第<code>n-1</code>圈，所以他们会相遇，同时慢指针的步数即为进入环的长度！</li></ul><h2 id="举例四倒数第n个节点"><a class="markdownIt-Anchor" href="#举例四倒数第n个节点"></a> 举例四：<a href="https://leetcode-cn.com/leetbook/read/linked-list/jf1cc/">倒数第N个节点</a></h2><p>如何删除链表中的倒数第N个节点？</p><p>答：让两个起始位置相差n的指针以同样的速度运动，当前面的指针『触底』的时候，后面的指针自己就是「倒数第n个」节点了。</p><blockquote><p>实际操作的时候，由于单向链表需要知道前一个节点才能对后一个节点进行操作，所以通常会让走的快的节点比自己先走一步。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/p/2362a8ea.html"/>
    <url>/p/2362a8ea.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容仅为刷题总结，只记录目前遇到过的情况，如果后面遇到了更多可能性再总结</p></blockquote><h2 id="链表定义"><a class="markdownIt-Anchor" href="#链表定义"></a> 链表定义</h2><p>在链式存储当中，对于节点是使用指针指向的方式进行数据的存储，其结点定义类似如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    LinkNode *next;<br>    <span class="hljs-built_in">LinkNode</span>() &#123;&#125;<br>    <span class="hljs-built_in">LinkNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>链表的好处是在添加或者删除特定节点的时候时间复杂度比顺序存储要小。在经常需要删除和添加操作节点的时候，通过直接修改节点的指针，可以快捷的对节点进行对应操作。</p><h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2><p>链表划分为三个部分，头+中间的数据节点+尾。</p><h3 id="头结点"><a class="markdownIt-Anchor" href="#头结点"></a> 头结点</h3><p>其中头节点有两种常见的处理方式，一种是通过一个虚拟的<code>dummyhead</code>来当作头结点，之后才是真实的数据节点。这样的好处是可以在对实际含有意义的头节点进行操作的时候，不需要有额外的特判就可以完成，通过增加一个头结点在部分题目中有的时候可以有很好的效果。</p><h3 id="尾节点"><a class="markdownIt-Anchor" href="#尾节点"></a> 尾节点</h3><p>尾节点和头结点一样，也有实际意义上存在的数据节点和最后指向的一个尾巴节点，不过根据节点的定义来看，可以知道尾节点后面通常都跟有一个无意义的<code>nullptr</code>。在有的时候需要对尾节点进行处理的时候，增加一个虚拟的<code>dummytail</code>也许也能起到很好的效果。<em>(p.s. 比如在写双向链表的时候)</em></p><h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2><p>创建链表的时候，通常会创建一个指针节点来表示整个链表的头节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LinkNode *ListA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();<br></code></pre></td></tr></table></figure><p>以上代码的含义即为创建一个LinkNode的节点，同时创建一个叫做<code>List</code></p><p><code>A</code>的指针，指向的是这个节点的内存。</p><p>而在对单向链表的进行操作的时候，如果我们移动了链头，很多时候意味着操作都是不可逆的。因此如果需要对链表中某个特定节点进行操作的时候，往往都会创建一个指向需要节点的指针来进行单独操作，操作完毕后将指针释放即可。</p><p>以下举例，阐明节点和节点指针之间的关系：<em>(感觉有点废话)</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LinkNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();  <span class="hljs-comment">// 创建一个cur指针</span><br>LinkNode *A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>(<span class="hljs-number">114</span>);  <span class="hljs-comment">// 创建节点A</span><br>LinkNode *B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>(<span class="hljs-number">115</span>);  <span class="hljs-comment">// 创建节点B</span><br>cout&lt;&lt;<span class="hljs-string">&quot;cur addr:&quot;</span>&lt;&lt;cur&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;A addr:&quot;</span>&lt;&lt;A&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;B addr:&quot;</span>&lt;&lt;B&lt;&lt;endl;<br><span class="hljs-comment">// 此时cur、A和B表示的内存地址</span><br>cur = A;<br>LinkNode *tmp = A;<br>cout&lt;&lt;tmp&lt;&lt;endl;<br><span class="hljs-comment">// 让cur指向A之后cur的内存地址</span><br>A = B;  <span class="hljs-comment">// 让A指向B</span><br><span class="hljs-comment">// delete tmp;  // 是否删除原本A代表的节点对应内存</span><br>cout&lt;&lt;<span class="hljs-string">&quot;cur addr:&quot;</span>&lt;&lt;cur&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;A addr:&quot;</span>&lt;&lt;A&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;B addr:&quot;</span>&lt;&lt;B&lt;&lt;endl;<br>cout&lt;&lt;cur-&gt;val&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在注释了<code>delete tmp</code>的时候，最后输出的<code>cur-&gt;val</code>会依旧是114这个A曾经的值，而如果执行了对应的<code>delete</code>操作，由于原本A对应内存上的结构体被释放了，所以这个时候<code>cur</code>就没有指向一个有效的节点。</p><h2 id="算法题"><a class="markdownIt-Anchor" href="#算法题"></a> 算法题</h2><h3 id="链表的终止条件"><a class="markdownIt-Anchor" href="#链表的终止条件"></a> 链表的终止条件</h3><p>常用的终止条件有三种：</p><ol><li><code>cur != nullptr</code> 指针会停留在<code>nullptr</code>的尾节点上</li><li><code>cur-&gt;next != nullptr</code> 指针会停留在最后一个有效节点上</li><li><code>cur != nullptr &amp;&amp; cur-&gt;next != nullptr</code>多用于快慢指针，用于判断快指针是否到队尾。之所以两种情况都判断为循环跳出的条件原因：由于<code>nullptr</code>本身相当于最后一个有效节点的附加尾巴。类比于线段上有区间(a, b)和区间[a,b]，快指针的目的是为了判断长度，而这两种区间长度都是<code>b - a</code>，只是对于第一种情况(a, b)如果不将b节点本身纳入有效节点则会出现区间长度变为<code>a -&gt; (b - 1)</code>的情况。</li></ol><p>对于第三种终止条件，还可以类比为：</p><ul><li><code>cur == nullptr</code>终止的情况就是区间(a, b)，此时cur在走到b的时候快指针已经越界，刚好碰壁</li><li><code>cur-&gt;next == nullptr</code>终止的情况就是区间[a, b]，此时cur在走到b时，刚好到达边界，也同样碰壁。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序main函数入口arg参数的用处</title>
    <link href="/p/98326a13.html"/>
    <url>/p/98326a13.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li><a href="https://blog.csdn.net/LYJ_viviani/article/details/51873961">关于int main( int argc, char* argv[] ) 中arg和argv参数的解析及调试</a></li></ul><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>今天在看一些代码的时候偶然看到自己刚开始学C的时候，<code>main()</code>函数中都会有一个<code>(int argc,char* argv[],char **env)</code>的传参。但是到现在依旧不理解这几个参数的意义和它们代表的作用，在稍微查阅了一下以后，浅显的总结一下。</p><h2 id="具体意义"><a class="markdownIt-Anchor" href="#具体意义"></a> 具体意义</h2><p>如果要使用<code>argc</code>和<code>argv</code>的话（<code>char **env</code>暂时没遇到，不做记录），只需要在<code>main</code>函数当中添加这两个参数即可，大致参考写法类似如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释</h3><p><code>argc</code>是一个整形的参数，代表了程序运行的时候发送给<code>main()</code>函数的参数个数。</p><p><code>argv</code>则是一个字符串的数组，用来指向存放对应参数的字符串。</p><p>其中，<code>argv[]</code>数组中的元素有<code>argc</code>个，并且有：</p><ul><li><code>argv[0]</code>包含的是程序运行的路径名字</li><li><code>argv[1]</code>包含的是程序命名后的第一个字符串</li><li><code>argv[2]</code>包含的是程序命名后的第二个字符串</li><li>…</li><li><code>argv[argc]</code>为NULL</li></ul><h2 id="演示方法"><a class="markdownIt-Anchor" href="#演示方法"></a> 演示方法</h2><p>为让以上解释更加形象，这里引入示例代码进行解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Argument&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; is &quot;</span>&lt;&lt;argv[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设代码文件存放于<code>./b.cpp</code>文件当中，通过编译器编译后的可执行文件为<code>b</code>。在执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./b<br></code></pre></td></tr></table></figure><p>返回的内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Argument0 is ./b<br></code></pre></td></tr></table></figure><p>在执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./b oneString twoString threeString<br></code></pre></td></tr></table></figure><p>返回的内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Argument0 is ./b<br>Argument1 is oneString<br>Argument2 is twoString<br>Argument3 is threeString<br></code></pre></td></tr></table></figure><p>对应了上文中的<code>argc</code>的元素个数和<code>argv</code>的字符串内容，即<code>./b</code>后面的<code>oneString</code>、<code>twoString</code>和<code>threeString</code>。</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装Oh My Zsh引导</title>
    <link href="/p/80f884dc.html"/>
    <url>/p/80f884dc.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li><a href="https://segmentfault.com/a/1190000015283092">Ubuntu 下 Oh My Zsh 的最佳实践「安装及配置」 - SegmentFault 思否</a></li><li><a href="https://www.mokeyjay.com/archives/2685">用 zsh-proxy 一键配置常用代理</a></li></ul><h2 id="安装oh-my-zsh"><a class="markdownIt-Anchor" href="#安装oh-my-zsh"></a> 安装Oh My Zsh</h2><h3 id="安装zsh"><a class="markdownIt-Anchor" href="#安装zsh"></a> 安装Zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install zsh -y<br>chsh -s /bin/zsh<br>echo $SHELL  ## 如果输出bash则需要重启SHELL<br></code></pre></td></tr></table></figure><h3 id="脚本安装"><a class="markdownIt-Anchor" href="#脚本安装"></a> 脚本安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh<br></code></pre></td></tr></table></figure><h2 id="zsh的配置"><a class="markdownIt-Anchor" href="#zsh的配置"></a> Zsh的配置</h2><h3 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h3><p>字体安装（Hack NF）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install fonts-hack<br></code></pre></td></tr></table></figure><p>其他字体：<a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis/nerd-fonts</a></p><h3 id="主题切换"><a class="markdownIt-Anchor" href="#主题切换"></a> 主题切换</h3><ol><li><p>编辑zsh配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>修改主题（以<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>为例）</p><ol><li><p>拉取主题仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure></li><li><p>在<code>~/.zshrc</code>下修改主题内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="插件配置"><a class="markdownIt-Anchor" href="#插件配置"></a> 插件配置</h3><ol><li><p>安装<code>zsh-autosuggestions</code>、<code>zsh-syntax-highlighting</code>、<code>zsh-proxy</code>和<code>z</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br>git clone https://github.com/sukkaw/zsh-proxy.git ~/.oh-my-zsh/custom/plugins/zsh-proxy<br></code></pre></td></tr></table></figure></li><li><p>配置插件，编辑<code>.zshrc</code>文件，在<code>plugins</code>处添加，类似效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 根据官方文档，zsh-syntax-highlighting 插件需放在最后</span></span><br>plugins=(<br>  git extract zsh-autosuggestions z zsh-proxy zsh-syntax-highlighting <br>)<br></code></pre></td></tr></table></figure></li><li><p><code>zshrc</code>完整文件配置帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 以下内容去掉注释即可生效：</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 启动错误命令自动更正</span></span><br>ENABLE_CORRECTION=&quot;true&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br>COMPLETION_WAITING_DOTS=&quot;true&quot;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习记录 - const限定符</title>
    <link href="/p/d08cfaf4.html"/>
    <url>/p/d08cfaf4.html</url>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a class="markdownIt-Anchor" href="#指针和引用"></a> 指针和引用</h2><blockquote><p>总结自C++ Primer，仅供自己学习参考</p></blockquote><h3 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h3><ol><li><p>引用本身只是目标对象的一个别名，自己本身并不是对象</p></li><li><p>变量引用可以间接对变量进行修改</p></li><li><p>常量别名代表的<strong>只能是常量</strong>，如果常量别名一个变量，也是先通过创建一个<em>临时量</em>，然后对这个<em>临时量</em>创建别名</p></li><li><p>变量别名不能指向一个<strong>常量</strong>，也不能指向<em>运算后的值</em>后的结果，e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> pi = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PI = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">//当对象为变量时</span><br><span class="hljs-type">int</span> &amp;revPI = pi;  <span class="hljs-comment">//正确，变量的别名代表的是一个变量</span><br><span class="hljs-type">int</span> &amp;revPIt = pi *<span class="hljs-number">2</span>; <span class="hljs-comment">//错误，不能指向变量运算后的结果（即返回的是一个常量值）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cRevPI = pi; <span class="hljs-comment">//正确，常量别名可以指向一个变量，通过临时量代替</span><br><br><span class="hljs-comment">//当对象为常量时</span><br><span class="hljs-type">int</span> &amp;cstRevPI = PI; <span class="hljs-comment">//错误,变量别名必须指向一个变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cstcRevPI = PI;<span class="hljs-comment">//正确，常量别名可以指向一个常量</span><br></code></pre></td></tr></table></figure></li><li><p>引用在<code>decltype</code>出并非是对象的同义词，而表示的是对应类型的引用</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">//x的类型是const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">//y的类型是const int&amp;，必须要设定为一个const int的引用</span><br><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">//错误，缺少引用代表的对象</span><br></code></pre></td></tr></table></figure><p>而对于表达式，在使用<code>decltype</code>关键词的时候，由于表达式本身可以返回一个值，所以会被识别为一个引用类型</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">//错误，d是一个int&amp;，需要初始化</span><br><span class="hljs-keyword">decltype</span>(i) e; <span class="hljs-comment">//正确，e是一个int，没有初始化</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h3><ol><li>指针本身是一个对象，其含义为指向目标对象的地址</li><li><code>void</code>指针可以指向任意一种变量代表的地址</li><li>常量指针<strong>必须初始化</strong>，其中通过const关键词有两种表达意思：<ul><li><code>int *const ptr</code>指的是<strong>常量指针，地址不可改变，指向一个<code>int</code>类型的变量</strong></li><li><code>const int *ptr</code>指的是<strong>常量的指针是常量类型，地址可改变，指向的是<code>const int</code>类型的常量</strong></li></ul></li><li>对于<code>*const</code>关键词修改的指针，虽然地址不能改变，但是依旧可以<strong>通过这个指针修改对应变量的值</strong>。</li></ol><h2 id="对于const限定符"><a class="markdownIt-Anchor" href="#对于const限定符"></a> 对于const限定符</h2><blockquote><p>顶层const：指针本身是一个常量</p><p>底层const：指针所指的对象是一个常量</p></blockquote><ul><li><p>对于顶层const中，在常量对象中的拷贝操作几乎不受什么影响</p></li><li><p>对于底层const中，只有两个对象有相同的底层const才能进行拷贝操作，举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> ci = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> cptr = &amp;i;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cptr2 = cptr <span class="hljs-comment">//正确，因为*cptr2和*cptr指向的都是常量的指针</span><br><span class="hljs-type">int</span> *p = p3; <span class="hljs-comment">//错误，因为*p不是指向常量的指针，所以不能拷贝p3</span><br></code></pre></td></tr></table></figure><p>其中对于引用也同样成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>;<br><br><span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">//由于ci本身是常量，和&amp;r代表的底层const不同，所以错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = ci; <span class="hljs-comment">//正确，底层const相同</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上通过Scoop管理和安装软件</title>
    <link href="/p/f15c20eb.html"/>
    <url>/p/f15c20eb.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://sspai.com/post/52496">「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件</a></li><li><a href="https://p3terx.com/archives/scoop-the-best-windows-package-manager.html">Scoop - 最好用的 Windows 包管理器 - P3TERX ZONE</a></li></ol><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在知道并安装Scoop的时候只是稍微听说过<code>winget-cli</code>一类的工具，不过由于一直对Windows系统的软件管理早就绝望，下意识的认为对Windows来说，这种终端的程序管理应该几乎没什么用。但在前几天偶然希望在<code>Windows Terminal</code>上寻找一个类似<code>Linux</code>的<code>sudo</code>的程序，发现了Scoop这个神器，并且在使用了一两天尝到甜头后，决定写一篇博客把大概的使用功能都记录一下。</p><h2 id="scoop的安装"><a class="markdownIt-Anchor" href="#scoop的安装"></a> Scoop的安装</h2><h3 id="前置条件"><a class="markdownIt-Anchor" href="#前置条件"></a> 前置条件</h3><p>安装在联网的情况下有直接的指令，但是安装之前需要保证环境满足以下要求：</p><ul><li>Windows 的版本不低于 Windows 7</li><li>Windows 的 PowerShell 版本不低于 PowerShell 3</li><li>拥有能自由前往Github，保证传输稳定的网络环境</li><li>Windows的用户名为<strong>英文或者数字（非中文）用户名</strong></li></ul><h3 id="装前须知"><a class="markdownIt-Anchor" href="#装前须知"></a> 装前须知</h3><h4 id="默认安装路径"><a class="markdownIt-Anchor" href="#默认安装路径"></a> 默认安装路径</h4><p>Scoop默认情况下和Linux中一样，只有普通用户的权限，其中Scoop本身和他默认安装的软件，会安装在<code>%USERPROFILE\scoop</code>目录下，使用管理员权限进行全局安装的软件会在<code>C:\ProgramData\scoop</code>目录下。</p><h4 id="修改路径"><a class="markdownIt-Anchor" href="#修改路径"></a> 修改路径</h4><ol><li><p>打开<code>PowerShell</code></p></li><li><p>设置用户的安装路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP</span>=<span class="hljs-string">&#x27;\PathTo\&#x27;</span>  <span class="hljs-comment">## 这里填需要设置的路径</span><br>[<span class="hljs-type">Environment</span>]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env:SCOOP</span>, <span class="hljs-string">&#x27;User&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>设置全局安装的路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:SCOOP_GLOBAL</span>=<span class="hljs-string">&#x27;\PathToGlobal\&#x27;</span>  <span class="hljs-comment">## 这里填需要设置的全局安装路径</span><br>[<span class="hljs-type">Environment</span>]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP_GLOBAL&#x27;</span>, <span class="hljs-variable">$env:SCOOP_GLOBAL</span>, <span class="hljs-string">&#x27;Machine&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>然后就可以开始愉快的安装了。</p><h3 id="开始安装"><a class="markdownIt-Anchor" href="#开始安装"></a> 开始安装</h3><ol><li><p>在PowerShell中输入以下内容，来保证本地脚本的执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">set-executionpolicy</span> remotesigned <span class="hljs-literal">-scope</span> currentuser<br></code></pre></td></tr></table></figure></li><li><p>用下面的命令来安装<code>Scoop</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">iex</span> (<span class="hljs-built_in">new-object</span> net.webclient).downloadstring(<span class="hljs-string">&#x27;https://get.scoop.sh&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>安装完成，可以通过以下指令来查询帮助</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop help<br></code></pre></td></tr></table></figure></li></ol><h2 id="网络设置"><a class="markdownIt-Anchor" href="#网络设置"></a> 网络设置</h2><p>由于网络可能有的时候不稳定，大部分Scoop的软件在安装的时候可能会出现安装失败的情况，就需要我们自己手动进行代理的设置，设置代理的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop config proxy [<span class="hljs-type">IP</span>/<span class="hljs-type">DNS</span>]:[端口]<br></code></pre></td></tr></table></figure><h2 id="使用手册"><a class="markdownIt-Anchor" href="#使用手册"></a> 使用手册</h2><h3 id="常用需安装软件"><a class="markdownIt-Anchor" href="#常用需安装软件"></a> 常用需安装软件</h3><ol><li><p>aria2</p><p>常用的强力下载工具，设置好<code>aria2</code>的<code>conf</code>文件并创建<code>session</code>文件，配合以下vbs脚本，创建快捷方式以后，在Win+R后运行<code>Shell:Common Startup</code>,将快捷方式放于其中，就可以当日用的下载工具了。</p><p>VBScript:</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;WScript.Shell&quot;</span>).Run <span class="hljs-string">&quot;aria2c.exe --conf-path=aria2.conf&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在安装完毕aria2后，scoop会默认用aria2来下载所有其他的软件，如果有的时候发现aria2下载不好使了，可以通过下面的指令来禁用aria2下载</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop config aria2<span class="hljs-literal">-enabled</span> false<br></code></pre></td></tr></table></figure><p>另外参考<code>P3TERX</code>大佬的博客中，其他选项可以按如下设置：</p><blockquote><p>单任务最大连接数设置为 <code>32</code>，单服务器最大连接数设置为 <code>16</code>，最小文件分片大小设置为 <code>1M</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;scoop config aria2<span class="hljs-operator">-split</span> <span class="hljs-number">32</span><br>&gt;scoop config aria2<span class="hljs-literal">-max-connection-per-server</span> <span class="hljs-number">16</span><br>&gt;scoop config aria2<span class="hljs-literal">-min-split-size</span> <span class="hljs-number">1</span>M<br></code></pre></td></tr></table></figure></blockquote></li><li><p>sudo</p><p>一个提权工具，可以让Windows下实现和Linux类似的提权效果</p></li><li><p>git</p><p>应该没啥好说的，必备安装。</p></li><li><p>nerd-fonts字体</p><p>在终端美化中常见的一种Powerline字体，使用以下指令添加库然后就能安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop bucket add nerd<span class="hljs-literal">-fonts</span><br></code></pre></td></tr></table></figure><p>查询可以用的所有字体</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scoop search <span class="hljs-string">&quot;-NF&quot;</span><br></code></pre></td></tr></table></figure><p>因为安装字体需要管理员权限，所以需要添加sudo，指令如下（以Hack NF为例）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sudo scoop install Hack<span class="hljs-literal">-NF</span><br></code></pre></td></tr></table></figure></li><li><p>LANDrop 局域网文件分享</p><p>一个很好用的局域网文件共享工具，可以高速在不同系统平台之间分享文件。</p></li></ol><h3 id="查阅手册"><a class="markdownIt-Anchor" href="#查阅手册"></a> 查阅手册</h3><p>大部分的使用帮助通过<code>scoop help</code>命令都可以直接列出并查看，常见的<code>search</code>、<code>install</code>、<code>update</code>和<code>uninstall</code>等指令不多做赘述。这里提供一些常见自己需要查阅的指令，以供日后使用参考。</p><blockquote><h4 id="清理安装包缓存"><a class="markdownIt-Anchor" href="#清理安装包缓存"></a> 清理安装包缓存</h4><p>Scoop 会保留下载的安装包，对于卸载后又想再安装的情况，不需要重复下载。但长期累积会占用大量的磁盘空间，如果用不到就成了垃圾。这时可以使用 <code>scoop cache</code> 命令来清理。</p><ul><li><code>scoop cache show</code> - 显示安装包缓存</li><li><code>scoop cache rm &lt;app&gt;</code> - 删除指定应用的安装包缓存</li><li><code>scoop cache rm *</code> - 删除所有的安装包缓存</li></ul><p>如果你不希望安装和更新软件时保留安装包缓存，可以加上 <code>-k</code> 或 <code>--no-cache</code> 选项来禁用缓存：</p><ul><li><code>scoop install -k &lt;app&gt;</code></li><li><code>scoop update -k *</code></li></ul><h4 id="删除旧版本软件"><a class="markdownIt-Anchor" href="#删除旧版本软件"></a> 删除旧版本软件</h4><p>当软件被更新后 Scoop 还会保留软件的旧版本，更新软件后可以通过 <code>scoop cleanup</code> 命令进行删除。</p><ul><li><code>scoop cleanup &lt;app&gt;</code> - 删除指定软件的旧版本</li><li><code>scoop cleanup *</code> - 删除所有软件的旧版本</li></ul><p>与安装软件一样，删除旧版本软件的同时也可以清理安装包缓存，同样是加上 <code>-k</code> 选项。</p><ul><li><code>scoop cleanup -k &lt;app&gt;</code> - 删除指定软件的旧版本并清除安装包缓存</li><li><code>scoop cleanup -k *</code> - 删除所有软件的旧版本并清除安装包缓存</li></ul><h4 id="全局安装"><a class="markdownIt-Anchor" href="#全局安装"></a> 全局安装</h4><p>全局安装就是给系统中的所有用户都安装，且环境变量是系统变量，对于需要设置系统变量的一些软件就需要全局安装，比如 Node.js、Python ，否则某些情况会出现无法找到命令的问题。</p><p>使用 <code>scoop install &lt;app&gt;</code> 命令加上 <code>-g</code> 或 <code>--global</code> 选项可对软件进行全局安装，全局安装需要管理员权限，所以需要提前以管理员权限运行的 Pow­er­Shell 。更简单的方式是先安装 <code>sudo</code>，然后用 <code>sudo</code> 命令来提权执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">scoop install sudo<br>sudo scoop install -g &lt;app&gt;<br></code></pre></td></tr></table></figure><blockquote><p>达成在 Win­dows 上使用<code>sudo</code>的成就</p></blockquote><p>使用 <code>scoop list</code> 命令查看已装软件时，全局安装的软件末尾会有 <code>*global*</code> 标志。</p><p>此外对于全局软件的更新和卸载等其它操作，都需要加上 <code>-g</code> 选项：</p><ul><li><code>sudo scoop update -g *</code> - 更新所有软件（且包含全局软件）</li><li><code>sudo scoop uninstall -g &lt;app&gt;</code> - 卸载全局软件</li><li><code>sudo scoop uninstall -gp &lt;app&gt;</code> - 卸载全局软件（并删除配置文件）</li><li><code>sudo scoop cleanup -g *</code> - 删除所有全局软件的旧版本</li><li><code>sudo scoop cleanup -gk *</code> - 删除所有全局软件的旧版本（并清除安装包包缓存）</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows字体切换的两种方法</title>
    <link href="/p/87ec6922.html"/>
    <url>/p/87ec6922.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ol><li><a href="https://github.com/Tatsu-syo/noMeiryoUI">Tatsu-syo/noMeiryoUI</a></li><li><a href="https://www.zhihu.com/question/263863102/answer/1999360871">如何更换win10系统的字体</a></li></ol><h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2><h3 id="通过nomeiryoui进行修改推荐"><a class="markdownIt-Anchor" href="#通过nomeiryoui进行修改推荐"></a> 通过<code>noMeiryoUI</code>进行修改（推荐）</h3><ol><li>在网站上找到自己喜欢的字体，通常为<code>ttf</code>、<code>otf</code>或<code>fnt</code>等文件。</li><li>在<code>noMeiryoUI</code>的repo中下载该工具：<a href="https://github.com/Tatsu-syo/noMeiryoUI/releases">Tatsu-syo/noMeiryoUI</a></li><li>解压后启动其中的<code>noMeiryoUI.exe</code>程序</li><li>选择自己想要的字体并更改，应用的时候可能会较为卡顿，耐心等待生效即可。</li></ol><h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2><h3 id="通过命令行替换windows官方字体达到应用自己字体的效果"><a class="markdownIt-Anchor" href="#通过命令行替换windows官方字体达到应用自己字体的效果"></a> 通过命令行替换Windows官方字体达到应用自己字体的效果</h3><p><em><strong>该方法存在一定风险，在替换Windows原本字体之前，请务必备份</strong></em></p><ol><li><p>下载自己想要用于替换的日用字体，并根据类型分别命名为<code>msyh.ttc</code>、<code>msyhbd.ttc</code>和<code>msyhl.ttc</code></p></li><li><p>在C盘根目录新建文件夹<code>TempFonts</code>用于临时存放需要替换的字体</p></li><li><p>打开Windows的设置，找到&quot;更新与安全&quot;-&gt;“恢复”-&gt;“高级启动”，在高级启动之后，选择&quot;高级选项&quot;，选择&quot;命令提示符&quot;，选择自己的帐号登入</p></li><li><p>输入以下指令，将C盘下<code>TempFonts</code>文件夹内的字体替换为系统默认字体。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">xcopy C:\TempFonts\* C:\Windows\Fonts\<br></code></pre></td></tr></table></figure><p>回车后按下A来全部覆盖替换（<em><strong>一定要备份好之前的系统文件再执行这一步</strong></em>）</p></li><li><p>输入<code>exit</code>回车后进入Windows系统，即可看到自己的字体应用生效，同理，如果想要将字体恢复，只需要用备份的字体文件进行覆盖操作即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oh My Posh美化Windows Terminal引导</title>
    <link href="/p/d26abad0.html"/>
    <url>/p/d26abad0.html</url>
    
    <content type="html"><![CDATA[<!-- markdownlint-disable MD033--><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li><a href="https://techcommunity.microsoft.com/t5/windows-powershell/how-to-install-and-update-powershell-6-one-liner/m-p/364948">[How to Install and Update PowerShell 6 - Thomas Maurer]</a></li><li><a href="https://blog.csdn.net/weixin_44490152/article/details/113854767">Windows Terminal + oh-my-posh模块美化官方教程集锦以及常见问题_想追头头の疾风的博客</a></li></ul><h2 id="更新powershell"><a class="markdownIt-Anchor" href="#更新powershell"></a> 更新PowerShell</h2><p>​    更新PowerShell本身和Windows Terminal没啥直接关系，单纯做个提醒放一个一键更新指令在这里：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">iex</span> <span class="hljs-string">&quot;&amp; &#123; <span class="hljs-variable">$</span>(irm https://aka.ms/install-powershell.ps1) &#125; -UseMSI&quot;</span><br></code></pre></td></tr></table></figure><p>这条命令的作用是安装最新版本的PowerShell，截至发博客为止可用于安装<code>PowerShell 7</code></p><h2 id="windows-terminal的安装美化"><a class="markdownIt-Anchor" href="#windows-terminal的安装美化"></a> Windows Terminal的安装&amp;美化</h2><h3 id="windows-terminal安装"><a class="markdownIt-Anchor" href="#windows-terminal安装"></a> Windows Terminal安装</h3><ol><li>打开Microsoft Store</li><li>搜索<code>Windows Terminal</code></li><li>安装</li></ol><h2 id="windows-terminal的配置和使用"><a class="markdownIt-Anchor" href="#windows-terminal的配置和使用"></a> Windows Terminal的配置和使用</h2><h3 id="windows-terminal的使用"><a class="markdownIt-Anchor" href="#windows-terminal的使用"></a> Windows Terminal的使用</h3><ul><li>在<code>Win+R</code>中输入<code>wt</code>回车即可呼出<code>Windows Terminal</code></li><li><code>Windows Terminal</code>中链接了一些Linux下可用的指令，诸如<code>ls</code>等</li><li>如果要在<code>Windows Terminal</code>下使用<code>vim</code>编辑器，只需要在安装了<code>Git</code>的前提下将<code>C:\Program Files\Git\usr\bin</code>设置为环境变量即可。(如果<code>Git</code>安装在其他目录下进行相对应的调整就好，设置好了以后重启一次<code>Windows Terminal</code>即可)</li></ul><h3 id="windows-terminal的个性化配置"><a class="markdownIt-Anchor" href="#windows-terminal的个性化配置"></a> Windows Terminal的个性化配置</h3><blockquote><p>如未特别说明，接下来将用<code>wt</code>作为<code>Windows Terminal</code>的简写</p></blockquote><p>注：本文个性化配置包括：</p><ul><li><p>修改<code>Windows Terminal</code>的配色</p></li><li><p>安装<code>posh-git</code>和<code>oh-my-posh</code></p></li><li><p>安装<code>Nerd Font</code>字体</p></li><li><p>配置<code>oh-my-posh</code>来修改<code>wt</code>的配色和样式</p></li></ul><p>不包括（以下设置在最新版的<code>wt</code>设置中已经包含）：</p><ul><li>毛玻璃和背景设置</li><li>光标形状、大小修改等</li></ul><h4 id="配色修改"><a class="markdownIt-Anchor" href="#配色修改"></a> 配色修改</h4><ol><li><p>在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes">mbadolato/iTerm2-Color-Schemes</a>下滑，找到自己喜欢的配色的截图，在截图的左上方会有该配色的代号。</p></li><li><p>在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal">iTerm2-Color-Schemes/windowsterminal</a>上找到配色对应的json文件并复制所有的内容。</p></li><li><p>在<code>wt</code>中打开设置，以下图为例：</p><img src="https://lsky.halc.top/XsycIz.png" alt="打开设置.png" style="zoom: 33%;" /></li><li><p>打开JSON设置，以图下为例：</p><img src="https://lsky.halc.top/FGEI3J.png" alt="打开JSON文件.png" style="zoom: 25%;" /></li><li><p>将刚刚复制的代码粘贴到有<code>scheme</code>字样的配置目录下，以下图为例：</p><img src="https://lsky.halc.top/XURWMD.png" alt="添加主题.png" style="zoom: 33%;" /></li><li><p>保存后，回到<code>wt</code>的设置，选择平时主要使用的窗口界面（e.g.<code>PowerShell</code>）然后选择外观，然后选择自己添加的主题，以下图为例：</p><img src="https://lsky.halc.top/8SSNzA.png" alt="修改config" style="zoom: 25%;" /></li></ol><h4 id="安装-nerd-fonts-字体"><a class="markdownIt-Anchor" href="#安装-nerd-fonts-字体"></a> 安装 Nerd-Fonts 字体</h4><blockquote><p>教程以<code>Hack NF</code>字体为例，如果需要使用其他字体请自行选择。</p></blockquote><ol><li><p>在这个页面下载的<code>Hack.zip</code>：</p><p><a href="https://github.com/ryanoasis/nerd-fonts">ryanoasis/nerd-fonts</a></p></li><li><p>解压<code>Hack.zip</code>，然后全选所有文件，右键点击安装</p></li><li><p>在<code>wt</code>中需要的终端，按<strong>配色修改</strong>第6步修改字体为<code>Hack NF</code>即可。</p></li></ol><h4 id="安装post-git和oh-my-posh"><a class="markdownIt-Anchor" href="#安装post-git和oh-my-posh"></a> 安装post-git和oh-my-posh</h4><blockquote><p>以下教程需要电脑上安装了Git才能使用</p></blockquote><ol><li><p>使用<code>PowerShell</code>安装<code>post-git</code>和<code>oh-my-posh</code></p><p>指给当前用户(非Administrator)安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> CurrentUser<br><span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure><p>给所有用户安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> AllUsers<br><span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> <span class="hljs-literal">-Scope</span> AllUsers<br></code></pre></td></tr></table></figure></li><li><p>列出所有可用主题</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-PoshThemes</span><br></code></pre></td></tr></table></figure></li><li><p>找到自己喜欢的主题，然后使用指令预览（这里以spaceship为例）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-PoshPrompt</span> <span class="hljs-literal">-Theme</span> spaceship<br></code></pre></td></tr></table></figure></li><li><p>在预览结束以后，为了让主题每次启动都生效，需要创建一个脚本。</p><ol><li><p>输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>vim $profile<br></code></pre></td></tr></table></figure></li><li><p>按下按键i，进入插入模式，然后填入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Import-Module posh-git<br>Import-Module oh-my-posh<br>Set-PoshPrompt -Theme spaceship #[这里填你选的主题名字，用spaceship做示范]<br></code></pre></td></tr></table></figure></li><li><p>键盘键入<code>:wq</code>然后回车，代表保存并退出。</p></li></ol></li><li><p>重新启动<code>wt</code>即可看到自己个性化配置的<code>Windows Terminal</code>界面了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier的私有DNS服务器ZeroNSD搭建引导</title>
    <link href="/p/447b77e9.html"/>
    <url>/p/447b77e9.html</url>
    
    <content type="html"><![CDATA[<h2 id="翻译来源"><a class="markdownIt-Anchor" href="#翻译来源"></a> 翻译来源</h2><ul><li><a href="https://github.com/zerotier/zeronsd/blob/main/docs/quickstart.md">zeronsd/quickstart.md</a></li></ul><blockquote><p>翻译的时间为2021-9-9，其中部分内容有删改，只提取了主观认为有用的信息，仅供参考</p></blockquote><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li>这个功能目前还在Beta测试当中</li><li>这个功能将会内嵌在未来将出现的<code>ZeroTier 2.0</code>当中，不过目前它是一个独立的软件</li><li>接下来的步骤将会有一定困难</li></ol><h3 id="概念须知"><a class="markdownIt-Anchor" href="#概念须知"></a> 概念须知</h3><ol><li>当<code>ZeroTier</code>加入了一个网络后，它将会创建一个虚拟网口</li><li>当<code>ZeroTier</code>加入了多个网络后，也会有多个虚拟网口</li><li>当<code>ZeroNSD</code>启动了之后，它将绑定在某一个特定的网口上</li><li>如果你需要对多个网络都使用<code>ZeroNSD</code>，那你也需要创建多个<code>ZeroNSD</code>服务绑定在它对应的网口上</li></ol><h2 id="安装环境"><a class="markdownIt-Anchor" href="#安装环境"></a> 安装环境</h2><p>​    该教程使用了两台不同的机器，一台是在云上的Ubuntu虚拟机，另外一台为Windows笔记本，如果要跟着来完成这个快速上手，最好使用相同的平台，如果使用了不同的平台，你最好要有能力弄清楚自己要做什么。</p><h2 id="搭建教程"><a class="markdownIt-Anchor" href="#搭建教程"></a> 搭建教程</h2><h3 id="zerotier-网络创建"><a class="markdownIt-Anchor" href="#zerotier-网络创建"></a> ZeroTier 网络创建</h3><ol><li><p>按正常流程创建、链接并授权一个以在<a href="my.zerotier.com">ZeroTier官网</a>创建的<code>network</code></p></li><li><p>在自己的帐号的<code>Account</code>页面下创见一个新的<code>API Token</code>，<code>ZeroNSD</code>将会利用这个<code>token</code>来获取对应网络下设备的不同名字，来达到自动分配dns的效果。</p></li><li><p>创建一个文件来让<code>ZeroNSD</code>能够以文件的方式读取<code>token</code>，参考指令如下 <strong>需要修改token为自己的token</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo bash -c &quot;echo ZEROTIER_CENTRAL_TOKEN &gt; /var/lib/zerotier-one/token&quot;<br>sudo chown zerotier-one:zerotier-one /var/lib/zerotier-one/token<br>sudo chmod 600 /var/lib/zerotier-one/token<br></code></pre></td></tr></table></figure></li><li><p>安装<code>ZeroTier</code>的进程管理应用</p><p><code>zerotier-systemd-manager</code>的<code>rpm</code>和<code>deb</code>安装包发布在这个网站：<a href="https://github.com/zerotier/zerotier-systemd-manager/releases">https://github.com/zerotier/zerotier-systemd-manager/releases</a>，请自行替换下面指令为最新的安装包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/zerotier/zerotier-systemd-manager/releases/download/v0.2.1/zerotier-systemd-manager_0.2.1_linux_amd64.deb<br>sudo dpkg -i zerotier-systemd-manager_0.2.1_linux_amd64.deb<br></code></pre></td></tr></table></figure></li><li><p>重启所有的ZeroTier服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart zerotier-one<br>sudo systemctl enable zerotier-systemd-manager.timer<br>sudo systemctl start zerotier-systemd-manager.timer<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装zeronsd"><a class="markdownIt-Anchor" href="#安装zeronsd"></a> 安装ZeroNSD</h3><blockquote><p>ZeroNSD针对每一个网络需要都创建一个独立的服务，对DNS来说延迟是很敏感的，所以最好让客户端和服务端尽可能接近</p></blockquote><ol><li><p>安装<code>ZeroNSD</code>，它的安装包发布在<a href="https://github.com/zerotier/zeronsd/releases">这里</a>，请自行替换下面指令为最新的安装包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/zerotier/zeronsd/releases/download/v0.1.7/zeronsd_0.1.7_amd64.deb<br>sudo dpkg -i zeronsd_0.1.7_amd64.deb<br></code></pre></td></tr></table></figure><blockquote><p>如果默认发布的地方没有对应平台的安装包，可以通过Cargo自行编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo /usr/bin/apt-get -y install net-tools librust-openssl-dev pkg-config cargo</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo /usr/bin/cargo install zeronsd --root /usr/local</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>对于你希望启用DNS服务的网络，执行类似以下的命令：</p><blockquote><p><code>/var/lib/zerotier-one/token</code>为token文件所在路径 （在上文设置token中有提及）</p><p><code>beyond.corp</code>为你希望的域名后缀</p><p><code>af78bf94364e2035</code>为你自己的网络ID</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zeronsd supervise -t /var/lib/zerotier-one/token -w -d beyond.corp af78bf94364e2035<br>sudo systemctl start zeronsd-af78bf94364e2035<br>sudo systemctl enable zeronsd-af78bf94364e2035<br></code></pre></td></tr></table></figure></li></ol><h3 id="检查可用性"><a class="markdownIt-Anchor" href="#检查可用性"></a> 检查可用性</h3><h4 id="网络需求"><a class="markdownIt-Anchor" href="#网络需求"></a> 网络需求</h4><ul><li>服务器需要开放53端口，让客户端可以请求到DNS</li><li>客户端需要启用<code>Allow DNS</code>的选项（安卓等平台默认启用，可以无视）</li></ul><h4 id="连通性检查"><a class="markdownIt-Anchor" href="#连通性检查"></a> 连通性检查</h4><p>​    假设笔记本的设备名为<code>laptop</code>，那么此时就可以通过设备名和dns后缀<code>ping</code>通设备了（不考虑防火墙）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">PS C:\Users\AzureBird&gt; ping laptop.beyond.corp<br><br>正在 Ping zephy.sak [172.28.120.138] 具有 32 字节的数据:<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br>来自 172.28.120.138 的回复: 字节=32 时间&lt;1ms TTL=128<br></code></pre></td></tr></table></figure><h4 id="指令更新"><a class="markdownIt-Anchor" href="#指令更新"></a> 指令更新</h4><p>​    如果后续需要更新配置（比如TLD），使用类似如下指令即可。（记得修改为自己设置的ID等参数）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo zeronsd supervise -t /var/lib/zerotier-one/token -w -d beyond.corp af78bf94364e2035<br>sudo systemctl daemon-reload<br>sudo systemctl enable zeronsd-af78bf94364e2035<br></code></pre></td></tr></table></figure><h2 id="额外说明"><a class="markdownIt-Anchor" href="#额外说明"></a> 额外说明</h2><p>​    <code>ZeroNSD</code>还可以添加本地的<code>hosts</code>作为私有的DNS服务，不过由于该部分内容并不复杂，且属于进阶内容，故不做教程，此贴仅作入门参考使用的快速手册。</p>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下修改网络优先级广播ZeroTier进行游戏</title>
    <link href="/p/aa5ce7f4.html"/>
    <url>/p/aa5ce7f4.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>​    经常能遇到需要和朋友联机玩一些P2P的联机游戏，但游戏服务器总是因为各种原因延迟很高或者连不上的情况。在使用诸如<code>ZeroTier</code>等一类软件进行组网的时候，在此给出能够让<code>Windows</code>提高虚拟网卡的优先级，让游戏能够在一些无法输入IP的游戏中扫描到同一虚拟局域网下用户的方法。</p><h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2><h3 id="创建zerotier网络"><a class="markdownIt-Anchor" href="#创建zerotier网络"></a> 创建ZeroTier网络</h3><blockquote><p>在谷歌搜索“创建<code>ZeroTier</code>网络”关键词即可找到许多对应教程，在此不多赘述</p><p>在有条件的情况下，可以自己搭建<code>Moon中转</code>节点来加速（非必须），教程：<a href="https://halc.top/2021/03/24/Moon-Server-of-ZeroTier.html">ZeroTier下Moon服务器的搭建</a></p></blockquote><h3 id="修改windows设置"><a class="markdownIt-Anchor" href="#修改windows设置"></a> 修改Windows设置</h3><blockquote><p>该教程以Windows10为例，其他版本的Windows可参考设置</p></blockquote><ol><li><p>在电脑右下角打开“<strong>网络和Internet</strong>”选项</p><p><img src="https://lsky.halc.top/NeXLax.png" alt="网络和Internet" /></p></li><li><p>打开&quot;<strong>更改适配器选项</strong>&quot;</p><p><img src="https://lsky.halc.top/pBsuTe.png" alt="更改适配器选项" /></p></li><li><p>打开对应ZeroTier的ID的网络属性</p><p><img src="https://lsky.halc.top/oXOE9l.png" alt="网络属性" /></p></li><li><p>打开&quot;<strong>Internet 协议版本 4</strong>&quot;下的&quot;<strong>属性</strong>&quot;</p><p><img src="https://lsky.halc.top/dOUiQS.png" alt="IPv4的属性" /></p></li><li><p>打开属性中的“<strong>高级</strong>”</p><p><img src="https://lsky.halc.top/13fbHK.png" alt="高级" /></p></li><li><p>修改自动跃点</p><blockquote><p>​    自动跃点的修改就笔者目前看来对日常使用影响不大，介意的可以在和好友联机结束以后重新勾选即可。并且由测试来看，只要重新连接了网络，Windows都会设置回为“自动跃点”</p></blockquote><p><img src="https://lsky.halc.top/A217p1.png" alt="自动跃点" /></p><blockquote><p>将优先级设置为1如果不放心的话可以设置为小一点的数字，不过也许有概率无法自动扫描局域网内其他游戏玩家。</p></blockquote></li></ol><h2 id="游戏内"><a class="markdownIt-Anchor" href="#游戏内"></a> 游戏内</h2><p>​     在进行了上面的操作，并且两个用户都处于同一ZeroTier的网络下之后，直接打开游戏存档并进入，应该就能在局域网联机中自动扫描到对方。目前已经测试的游戏有：无主之地3、GTFO等，理论上所有可以使用局域网加入的游戏应该都能用相同的方法进行操作。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将OpenClash设置为Adguard Home的上级DNS</title>
    <link href="/p/690287f9.html"/>
    <url>/p/690287f9.html</url>
    
    <content type="html"><![CDATA[<h2 id="设置步骤"><a class="markdownIt-Anchor" href="#设置步骤"></a> 设置步骤</h2><blockquote><p>参考<a href="https://github.com/vernesong/OpenClash/issues/99">结合adguard home 使用 DNS 设置求教 · Issue #99</a>中hankclc和icyleaf的回答，总结一下设置步骤作为参考</p></blockquote><ol><li><p>将AdGuard Home的上游DNS设置为OpenClash的DNS地址</p><blockquote><p>OpenClash的DNS地址可以在全局设置中看到，一般为<code>127.0.0.1:7874</code></p></blockquote></li><li><p>关闭OpenClash的本地DNS劫持</p></li><li><p>AdGuard Home的重定向模式选择使用53端口替换dnsmasq</p></li></ol><p><em><strong>OpenClash不要用TUN或TUN混合模式（还未自己测试）</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rsync使用方法摘抄</title>
    <link href="/p/6d032e05.html"/>
    <url>/p/6d032e05.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程</a></li><li><a href="https://www.jianshu.com/p/b0157e4ab801">RSYNC备份服务</a></li></ol><h2 id="rsync介绍"><a class="markdownIt-Anchor" href="#rsync介绍"></a> Rsync介绍</h2><p>​    Remote-Sync，意味远程动态同步，可以在不同的主机之间进行同步操作，相比一般将文件一次性全部备份而不同的好处是，Rsync可以做到每次增量同步，只对部分文件进行修改，目前个人主要用来和<code>WebDAV</code>挂载的本地目录进行配合使用，对服务器进行备份处理</p><h2 id="常见用法"><a class="markdownIt-Anchor" href="#常见用法"></a> 常见用法</h2><h3 id="本地使用"><a class="markdownIt-Anchor" href="#本地使用"></a> 本地使用</h3><ul><li><p>增量同步</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># [SRC]为源目录</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># [DEST]为目标目录</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -a：优于-r的递归参数，会同步文件的元信息（时间和权限等，在增量更新中有重要作用）</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -v：将结果或过程打印在控制台内</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -z 同步时压缩数据</span></span><br></code></pre></td></tr></table></figure></li><li><p>镜像同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># --delete：当检测到源文件中某个文件被删除的同时，将删除操作也同样进行同步，变成目标镜像</span></span><br></code></pre></td></tr></table></figure></li><li><p>排除文件</p><blockquote><p>这里以排除掉所有带<code>.log</code>字样的文件为例</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete --exclude &#x27;*.log&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># --exclude为字符过滤，其中这个过滤也包括了隐藏文件</span></span><br></code></pre></td></tr></table></figure><p>当有多个排除模式的时候，可以使用多个<code>--exclude</code>参数，也可以使用<code>Bash</code>的大括号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用多个--exclude参数</span></span><br>rsync -avz --delete --exclude &#x27;*.log&#x27; &#x27;*.txt&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用Bash</span></span><br>rsync -avz --delete --exclude=&#123;&#x27;*.log&#x27;,&#x27;*.txt&#x27;&#125; [SRC] [DEST]<br></code></pre></td></tr></table></figure><p>排除隐藏文件，以及排除目录中所有文件的同时保存目录本身</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 排除隐藏文件，在Linux中即类似`.ssh`一类以&#x27;.&#x27;开头的文件，这个时候忽略&#x27;.*&#x27;即可</span></span><br>rsync -avz --delete --exclude &#x27;.*&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 排除目录中所有文件的同时保存目录本身</span></span><br>rsync -avz --delete --exclude &#x27;dir/*&#x27; [SRC] [DEST]<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 可以做到保存dir目录的同时，不保存dir下的所有文件</span></span><br></code></pre></td></tr></table></figure><p>排除的同时又强制锁定</p><blockquote><p>如果需要排除所有&quot;*.log&quot;的同时，又希望保存所有demo.log的文件，则可以配合<code>--include</code>参数一起使用，以下为例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync -avz --delete --include=&quot;demo.log&quot; --exclude=&quot;*.log&quot; [SRC] [DEST]<br></code></pre></td></tr></table></figure></li></ul><h3 id="远程使用"><a class="markdownIt-Anchor" href="#远程使用"></a> 远程使用</h3><p>TODO</p><h2 id="基准目录备份"><a class="markdownIt-Anchor" href="#基准目录备份"></a> 基准目录备份</h2><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux通过修改init.d脚本自启动脚本</title>
    <link href="/p/f3eca903.html"/>
    <url>/p/f3eca903.html</url>
    
    <content type="html"><![CDATA[<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2><ol><li><p>创建脚本文件，这里以<code>startup.sh</code>示例</p></li><li><p>给脚本添加可执行权限，并移动脚本位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x startup.sh<br>sudo mv startup.sh /etc/init.d/<br></code></pre></td></tr></table></figure></li><li><p>设置为开机脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d /etc/init.d/startup.sh defaults 100<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 这里的100指的是脚本的优先级，数字越大执行越晚，可以为0</span></span><br></code></pre></td></tr></table></figure><p>如果需要删除脚本，用<code>remove</code>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-rc.d /etc/init.d/startup.sh remove<br>sudo rm /etc/init.d/startup.sh<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker传递操作进容器内的不同方式</title>
    <link href="/p/14cd2588.html"/>
    <url>/p/14cd2588.html</url>
    
    <content type="html"><![CDATA[<h2 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h2><ol><li><p>使用<code>docker exec -it</code>命令进入容器（推荐）</p><p>假设操作的容器ID为<code>icontainer</code>，如果想要进入<code>icontainer</code>执行指令，只需要输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it icontainer /bin/bash<br></code></pre></td></tr></table></figure><p>如果需要退出容器，输入<code>exit</code>或者<code>Ctrl+C</code>即可</p></li><li><p>使用<code>docker attach</code>命令进入</p><p>同样以<code>icontainer</code>举例，则需要输入以下指令来进入容器终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach icontainer<br></code></pre></td></tr></table></figure><p><em><strong>但这样有缺点，即退出终端的同时，该容器也会同样退出，所以推荐使用<code>exec</code>的方法进入容器</strong></em></p></li></ol><h2 id="文件传递"><a class="markdownIt-Anchor" href="#文件传递"></a> 文件传递</h2><p>​    先直接上指令，以容器<code>icontainer</code>为例，我需要将该容器下的<code>/opt/demo/demo.zip</code>拷贝到宿主机的<code>/opt/Backup/</code>下，那么我的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp icontainer:/opt/demo/demo.zip /opt/Backup/<br></code></pre></td></tr></table></figure><p>​    同理，如果我需要将<code>Backup</code>下的<code>demo.zip</code>传递到容器内，我也可以使用如下指令传输到容器的<code>recover</code>文件夹内：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /opt/Backup/demo.zip icontainer:/opt/recover/<br></code></pre></td></tr></table></figure><blockquote><p>备注：文件传递和容器是否启动无关，都会直接对文件进行修改</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Samba使用说明</title>
    <link href="/p/87299c69.html"/>
    <url>/p/87299c69.html</url>
    
    <content type="html"><![CDATA[<h1 id="linux-服务端部署"><a class="markdownIt-Anchor" href="#linux-服务端部署"></a> Linux 服务端部署</h1><h2 id="安装服务"><a class="markdownIt-Anchor" href="#安装服务"></a> 安装服务</h2><ol><li><p>更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-gets upgrade <br>sudo apt-get update <br>sudo apt-get dist-upgrade<br></code></pre></td></tr></table></figure></li><li><p>安装samba服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install samba samba-common -y<br></code></pre></td></tr></table></figure></li><li><p>创建Samba共享文件夹，如共享已存在文件夹则可忽略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /mnt/Files<br></code></pre></td></tr></table></figure></li><li><p>按需设置文件夹的访问权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod 777 /mnt/Files<br></code></pre></td></tr></table></figure></li><li><p>创建名为[username]的Samba用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo smbpasswd -a [username]<br></code></pre></td></tr></table></figure></li><li><p>创建或修改Samba服务端配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/samba/smb.conf<br></code></pre></td></tr></table></figure><p>在配置文件最后添加类似以下模板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[shareFolderName]<br>comment = Commit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">是否能浏览</span><br>browseable = yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">路径</span><br>path = /mnt/Files<br>create mask = 0777<br>directory mask = 0777<br>valid users = [username]<br>force user = root <br><span class="hljs-meta prompt_">#</span><span class="language-bash">是否以root操作路径内的文件</span><br>force group = root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">是否公开</span><br>public = yes<br>available = yes<br>writable = yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 不允许guest</span></span><br>guest ok = no<br></code></pre></td></tr></table></figure></li><li><p>关闭Ubuntu 防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ufw disable <br>sudo ufw status //查看ufw状态<br></code></pre></td></tr></table></figure></li><li><p>重启Samba服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service smbd restart<br></code></pre></td></tr></table></figure></li><li><p>安装完毕，在Windows+R下连接</p><p><code>按Windows+R，然后输入&quot;\\IP地址&quot;检查是否能连接</code></p></li></ol><h1 id="linux-客户端连接"><a class="markdownIt-Anchor" href="#linux-客户端连接"></a> Linux 客户端连接</h1><ol><li><p>安装必要的软件包（如果尚未安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install cifs-utils<br></code></pre></td></tr></table></figure></li><li><p>创建一个本地挂载点（如果尚不存在）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /root/samba<br></code></pre></td></tr></table></figure></li><li><p>创建凭证文件（如果您尚未创建）： 为了安全起见，最好使用一个凭证文件而不是直接在<code>fstab</code>中存储用户名和密码。创建一个文件（例如<code>/root/.smbcredentials</code>），并添加您的用户名和密码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">username</span><span class="hljs-operator">=</span>username<br><span class="hljs-attribute">password</span><span class="hljs-operator">=</span>password<br></code></pre></td></tr></table></figure><p>然后修改该文件的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 600 /root/.smbcredentials<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>/etc/fstab</code>文件： 打开<code>/etc/fstab</code>文件进行编辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>fstab<br></code></pre></td></tr></table></figure><p>在文件的末尾添加以下行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>path<span class="hljs-regexp">/to/</span>smb <span class="hljs-regexp">/root/</span>samba cifs credentials=<span class="hljs-regexp">/root/</span>.smbcredentials,iocharset=utf8 <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里，<code>iocharset=utf8</code>确保了正确的字符编码，特别是对于非英文文件名。</p></li><li><p>挂载测试：可以通过以下命令手动挂载：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo mount -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="补充说明"><a class="markdownIt-Anchor" href="#补充说明"></a> 补充说明</h1><ul><li><p>Samba客户端无法访问软链接，提示没有权限：</p><p>和权限没有关系，需要修改的是<code>[global]</code>当中的设置，添加以下三行代码即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wide links = yes<br>symlinks = yes<br>unix extensions = no<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker指令和配置手册</title>
    <link href="/p/abf1d877.html"/>
    <url>/p/abf1d877.html</url>
    
    <content type="html"><![CDATA[<p>参考链接:</p><ol><li><a href="https://blog.csdn.net/weixin_44070676/article/details/106942848">CSDN-Ubuntu 18.04 DOCKER的安装</a></li><li><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images">停止、删除所有的docker容器和镜像</a></li><li><a href="https://docs.docker.com/">Docker官网文档</a></li></ol><h2 id="docker用户组配置"><a class="markdownIt-Anchor" href="#docker用户组配置"></a> Docker用户组配置</h2><p>设置用户组<code>docker</code>，让用户不需要sudo也可以使用docker相关命令</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br>sudo gpasswd -a <span class="hljs-variable">$USER</span> docker<br>newgrp docker<br>docker ps<br></code></pre></td></tr></table></figure><ul><li><p>查看当前所有在运行的Docker容器</p><p><code>docker ps -a</code></p></li><li><p>在库内搜索需要的docker容器运行</p><p><code>docker search [name]</code></p></li><li><p>获取需要的容器</p><p><code>docker pull [name]</code></p></li><li><p>停止所有的容器</p><p><code>docker stop $(docker ps -aq)</code></p></li><li><p>删除所有的容器</p><p><code>docker rm $(docker ps -aq)</code></p><ul><li><p>删除所有目前没有在运行的容器</p><p><code>docker container prune</code></p></li></ul></li><li><p>删除所有的镜像</p><p><code>docker rmi $(docker images -q)</code></p><ul><li><p>删除所有未被使用的镜像</p><p><code>docker image prune</code></p></li></ul></li><li><p>删除所有未被引用的容器，镜像和各种cache</p><p><code>docker system prune</code></p></li><li><p>重命名容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rename [Docker的Name] [修改后的Name]<br></code></pre></td></tr></table></figure></li></ul><h2 id="运行docker的指令"><a class="markdownIt-Anchor" href="#运行docker的指令"></a> 运行Docker的指令</h2><blockquote><p>Docker在运行的过程中有许多额外设置，其中包括不同的网络结构，不同的运行模式，交互方法等，目前在这里只记录一些简单用得上的，后续如果还有比较常用的指令再进行补充添加。</p></blockquote><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><p><code>docker run -d --restart=always --network host --name CloudMusic nondanee/unblockneteasemusic</code></p><ol><li><p><code>docker run</code></p><p>运行docker容器</p></li><li><p><code>-d</code></p><p>以后台模式运行</p></li><li><p><code>--restart-always</code></p><p>每次docker如果重启了的话也总是自动运行</p></li><li><p><code>--network host</code></p><p>以<code>host</code>网络模式运行docker容器，而不是以默认的NAT分布</p></li><li><p><code>--name CloudMusic</code></p><p>给这个容器命名为CloudMusic</p></li></ol><ul><li>进入容器<ol><li><code>docker attach &lt;ID&gt;</code></li><li><code>docker -it &lt;ID&gt; /bin/bash</code>或者<code>docker -it &lt;ID&gt; /bin/sh</code></li></ol></li></ul><h2 id="docker设置开机自启动"><a class="markdownIt-Anchor" href="#docker设置开机自启动"></a> Docker设置开机自启动</h2><ol><li><p>通过systemctl设置docker开机自启动</p><p><code>systemctl enable docker.service</code></p></li><li><p>docker容器使用<code>--restart=always</code>参数启动</p><ul><li>如果已经启动了可以通过<code>docker update --restart=always &lt;ID&gt;</code>添加参数</li></ul></li><li><p>重启系统以后通过<code>docker ps -a</code>可以看到服务已经在正常运行了</p></li></ol><h2 id="docker容器参数配置"><a class="markdownIt-Anchor" href="#docker容器参数配置"></a> Docker容器参数配置</h2><ol><li><p>用命令修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container update --help<br></code></pre></td></tr></table></figure><blockquote><p>使用这个指令可以在不停止容器的情况下更新部分内容，比如容器的启动方式</p></blockquote></li><li><p>配置文件修改</p><ul><li><em><strong>首先要停止容器，才能对容器的配置文件进行修改</strong></em></li><li>配置路径为<code>/var/lib/docker/containers/容器ID</code>下的<code>hostconfig.json</code>就是配置文件</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下有关用户和组的文件权限变动</title>
    <link href="/p/be72c31c.html"/>
    <url>/p/be72c31c.html</url>
    
    <content type="html"><![CDATA[<p>参考文章</p><p>1.<a href="https://segmentfault.com/a/1190000024532631">Ubuntu群组管理</a></p><h2 id="linux用户和群组"><a class="markdownIt-Anchor" href="#linux用户和群组"></a> Linux用户和群组</h2><p>​        Linux下拥有着不同的用户和群组，群组可以是一个用户的集群，通过修改Linux的用户和对应的群的权限可以较为安全的对文件进行操作。</p><h2 id="群组管理"><a class="markdownIt-Anchor" href="#群组管理"></a> 群组管理</h2><p><em><strong>接下来所有的内容都是基于<code>Ubuntu 20.04 LTS</code></strong></em></p><h3 id="新增群组"><a class="markdownIt-Anchor" href="#新增群组"></a> 新增群组</h3><p>在我们需要对多个用户进行相同的权限管理的时候，可以通过创建对应群组来进行管理，这里以<code>demog</code>为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">addgroup demog<br></code></pre></td></tr></table></figure><h4 id="用户和组的关系"><a class="markdownIt-Anchor" href="#用户和组的关系"></a> 用户和组的关系</h4><h5 id="修改用户账户"><a class="markdownIt-Anchor" href="#修改用户账户"></a> 修改用户账户</h5><p>以<code>demo</code>用户为例，在有<code>root</code>权限的情况下输入以下指令来设置<code>demo</code>的初始组为<code>demog</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g demog demo<br></code></pre></td></tr></table></figure><p><strong>首先是<code>组</code>然后才是<code>用户</code></strong></p><h5 id="查看用户当前的组"><a class="markdownIt-Anchor" href="#查看用户当前的组"></a> 查看用户当前的组</h5><p>要查询当前用户所在的组信息，可以使用类似如下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groups demo<br></code></pre></td></tr></table></figure><p>如果要把一个用户添加到多个群组可以用如下指令（先去除后添加，请勿直接尝试指令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groups -G demog1 demog2 demog3 demo<br></code></pre></td></tr></table></figure><blockquote><p>配合<code>-g</code>或者<code>-G</code>参数的时候，会把用户从原本的组里面剔除，然后加入到新的组里面，如果需要的是<code>-a</code>的参数，表示的是“追加”</p></blockquote><h4 id="删除群组"><a class="markdownIt-Anchor" href="#删除群组"></a> 删除群组</h4><p>指令很简单，如下格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">delgroup demog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux通过davfs2挂载WebDav网盘</title>
    <link href="/p/39b9efc1.html"/>
    <url>/p/39b9efc1.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：已改用rclone作为较优方案</p></blockquote><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a href="https://blog.csdn.net/u013401853/article/details/113094734">davfs挂载与使用缺陷</a></li></ol><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><ol><li><p>输入以下指令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install davfs2<br></code></pre></td></tr></table></figure></li></ol><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2><ol><li><p>创建需要挂载的硬盘，这里以<code>/opt/Backup</code>为例，挂载网址为<code>http://localhost:8080/dav/</code>，账号为<code>admin</code>，密码为<code>123456</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /opt/Backup/<br></code></pre></td></tr></table></figure></li><li><p>将硬盘挂载到对应路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount.davfs http://locaohost:8080/dav/ /opt/Backup/<br></code></pre></td></tr></table></figure></li><li><p>输入账号密码并手动连接</p></li></ol><h2 id="保存密码"><a class="markdownIt-Anchor" href="#保存密码"></a> 保存密码</h2><ol><li><p>编辑<code>/etc/davfs2/davfs2.conf</code>，找到其中的<code>use_lock</code>取消注释，并修改值为<code>0</code></p></li><li><p>修改<code>/etc/davfs2/secrets</code>，在末尾添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://localhost:8080/dav/ admin 123456<br></code></pre></td></tr></table></figure></li></ol><h2 id="自动挂载"><a class="markdownIt-Anchor" href="#自动挂载"></a> 自动挂载</h2><ol><li><p>编辑<code>/etc/fstab</code>，在最后一行添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://localhost:8080/dav/ /opt/Backup/ davfs defaults 0 0<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>以上的<a href="http://localhost:8080/dav/%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BA%E7%A4%BA%E4%BE%8B%EF%BC%8C%E8%AF%B7%E5%9C%A8%E4%BA%86%E8%A7%A3WebDav">http://localhost:8080/dav/和用户名密码均为示例，请在了解WebDav</a>之后替换为自己需要的值</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下通过硬盘UUID进行挂载</title>
    <link href="/p/c9fc3bb5.html"/>
    <url>/p/c9fc3bb5.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><ol><li><a href="https://support.huaweicloud.com/ecs_faq/ecs_faq_1125.html">重启后盘符发生变化解决办法</a></li></ol><h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2><ol><li><p>将硬盘接入系统</p></li><li><p>使用以下指令查询目前磁盘分区的盘符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure></li><li><p>使用以下指令查询特定盘符的UUID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">blkid /dev/sda1  ## 这里的sda1要看具体情况填<br></code></pre></td></tr></table></figure></li><li><p>在<code>/etc/fstab/</code>内编辑类似以下内容挂载磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">UUID=c26cfce4-xxxx-xxxx-xxxx-403439946c8c    /opt    ext4    defaults 0 0  ## /opt为具体挂载的目录,ext4为磁盘格式<br></code></pre></td></tr></table></figure></li><li><p>使用以下指令检查是否设置成功，如果成功则不会返回任何异常信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -a<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minecraft服务器配置域名SRV记录隐藏端口</title>
    <link href="/p/1dcf9daa.html"/>
    <url>/p/1dcf9daa.html</url>
    
    <content type="html"><![CDATA[<h2 id="记录"><a class="markdownIt-Anchor" href="#记录"></a> 记录</h2><p>​    目前对于SRV记录了解还不清楚，没有查询具体可以使用的服务等。目前需要的也只是达到转发MC的端口，达到隐藏端口的目的，所以只是一个无脑式记录。</p><h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2><ol><li><p>拥有一个域名，并且指向了一个带有端口的MC服务器，比如<code>rpg.vastl.icu:25566</code></p></li><li><p>在DNS控制台添加解析记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">主机记录：_minecraft._tcp.xx  ## xx为子域名<br>记录类型：SRV<br>记录值：5 0 端口号 域名  ## 举例：5 0 25566 rpg2.vastl.icu.<br></code></pre></td></tr></table></figure></li><li><p>最后应用即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier搭建Planet服务器引导</title>
    <link href="/p/1e0fb80b.html"/>
    <url>/p/1e0fb80b.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://gotz.co/2019/02/17/mpls-over-zerotier-pt-1/">Running MPLS over ZeroTier Part 1 · Gotz Networks</a></li></ol><h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2><ol><li><p>把ZeroTier的项目在本地克隆一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zerotier/ZeroTierOne.git<br></code></pre></td></tr></table></figure></li><li><p>打开在<code>attic</code>文件夹下的<code>world</code>文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ZeroTierOne/attic/world<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>mkworld.cpp</code>文件，把<code>ZeroTier Controller默认的IP删除，添加自己的IP上去。</code></p></li><li><p>编译文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ./build.sh<br></code></pre></td></tr></table></figure></li><li><p>运行<code>mkworld</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mkworld<br></code></pre></td></tr></table></figure></li><li><p>应该会产生一个新的<code>world.bin</code>文件，这个文件需要在所有自己的客户端添加</p></li><li><p>将这个<code>world.bin</code>文件复制到<code>ZeroTier</code>的文件夹下，在Linux中的指令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp world.bin /var/lib/zerotier-one/planet<br></code></pre></td></tr></table></figure></li><li><p>重启<code>ZeroTier</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart zerotier-one.service<br></code></pre></td></tr></table></figure></li><li><p>重复第七步和第八步，在所有希望使用自己<code>Planet</code>服务器的客户端中添加这个节点</p></li></ol><h2 id="实现的效果"><a class="markdownIt-Anchor" href="#实现的效果"></a> 实现的效果</h2><p>​    完全使用自己的服务器，数据等不通过ZeroTier自己的官网。</p>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu删除无用的包和垃圾文件</title>
    <link href="/p/77f84830.html"/>
    <url>/p/77f84830.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考网站"><a class="markdownIt-Anchor" href="#参考网站"></a> 参考网站</h2><ol><li><a href="https://www.iteye.com/blog/fox-leon-1305501">Ubuntu删除无用缓存及垃圾文件</a></li></ol><h2 id="常用的清理指令"><a class="markdownIt-Anchor" href="#常用的清理指令"></a> 常用的清理指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get autoclean  ## 清理旧版本的软件缓存<br>sudo apt-get clean  ## 清理所有软件缓存<br>sudo apt-get autoremove  ## 删除系统不再使用的孤立软件<br></code></pre></td></tr></table></figure><p>这三个指令主要是用于清理升级时候产生的缓存和无用的包</p><h2 id="包管理的临时文件目录"><a class="markdownIt-Anchor" href="#包管理的临时文件目录"></a> 包管理的临时文件目录</h2><ul><li>包在<code>/var/cache/apt/archives</code></li><li>没有下载完毕的在<code>/var/cache/apt/archives/partial</code></li></ul><h2 id="卸载软件"><a class="markdownIt-Anchor" href="#卸载软件"></a> 卸载软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove --purge [软件名字]  ## 卸载某个软件<br>dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P  ## 删除系统上多余的配置文件<br></code></pre></td></tr></table></figure><h2 id="删除孤立的包"><a class="markdownIt-Anchor" href="#删除孤立的包"></a> 删除孤立的包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install deborphan -y<br></code></pre></td></tr></table></figure><h2 id="删除内核"><a class="markdownIt-Anchor" href="#删除内核"></a> 删除内核</h2><p>​    见博客：<a href="https://halc.top/2021/04/24/ubuntu_kernel_manage/">删除多余的Ubuntu内核,解决因grub无法正常启动的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu通过systemd禁用系统睡眠</title>
    <link href="/p/2f594679.html"/>
    <url>/p/2f594679.html</url>
    
    <content type="html"><![CDATA[<h2 id="参考网址"><a class="markdownIt-Anchor" href="#参考网址"></a> 参考网址</h2><ol><li><a href="https://www.unixtutorial.org/disable-sleep-on-ubuntu-server/">How To: Disable Sleep on Ubuntu Server (unixtutorial.org)</a></li></ol><h2 id="查看系统休眠的记录"><a class="markdownIt-Anchor" href="#查看系统休眠的记录"></a> 查看系统休眠的记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status sleep.target<br></code></pre></td></tr></table></figure><blockquote><p>理论上会返回类似如下的内容，里面会注明系统休眠的时间等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## systemctl status sleep.target<br>● sleep.target - Sleep<br>     Loaded: loaded (/lib/systemd/system/sleep.target; static; vendor preset: enabled)<br>     Active: inactive (dead)<br>       Docs: man:systemd.special(7)<br><br>May 07 18:54:58 azhal systemd[1]: Reached target Sleep.<br>May 07 20:19:14 azhal systemd[1]: Stopped target Sleep.<br>May 07 20:39:14 azhal systemd[1]: Reached target Sleep.<br>May 07 20:52:35 azhal systemd[1]: Stopped target Sleep.<br></code></pre></td></tr></table></figure></blockquote><h2 id="关闭系统休眠"><a class="markdownIt-Anchor" href="#关闭系统休眠"></a> 关闭系统休眠</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target<br></code></pre></td></tr></table></figure><blockquote><p>[引用文章原话] This is obviously a very simple way of disabling power management, but I like it because it’s standard and logical enough – there’s no need to edit config files or create cronjobs manually controlling sleep functionality.</p><p>大概翻译过来就是指这样的操作标准且合理，因为这样省去了编辑任何文件的麻烦，并且也达到了禁用休眠的目的。</p><p>禁用以后大致会变成这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## systemctl status sleep.target<br>● sleep.target<br>     Loaded: masked (Reason: Unit sleep.target is masked.)<br>     Active: inactive (dead)<br><br>May 07 18:54:58 azhal systemd[1]: Reached target Sleep.<br>May 07 20:19:14 azhal systemd[1]: Stopped target Sleep.<br>May 07 20:39:14 azhal systemd[1]: Reached target Sleep.<br>May 07 20:52:35 azhal systemd[1]: Stopped target Sleep.<br></code></pre></td></tr></table></figure></blockquote><h2 id="恢复系统休眠服务器"><a class="markdownIt-Anchor" href="#恢复系统休眠服务器"></a> 恢复系统休眠服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下7zip的使用手册</title>
    <link href="/p/cc7f9b10.html"/>
    <url>/p/cc7f9b10.html</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><ol><li><p>直接使用<code>apt</code>安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install p7zip<br></code></pre></td></tr></table></figure></li></ol><h2 id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h2><ol><li><p>压缩文件/文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">7za a -t7z -r MyTest.7z FolderToZip/*<br></code></pre></td></tr></table></figure><p>将<code>FolderToZip</code>文件夹下所有文件压缩到当前目录的<code>MyTest.7z</code>文件中</p><blockquote><p>a 代表添加文件/文件夹到压缩包<br />-t(7z) -t参数是指定压缩类型，这里是7z，也可以不指定，因为7za默认的压缩类型就是7z<br />-r 表示递归所有的子文件夹</p></blockquote></li><li><p>解压缩文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">7za x MyTest.7z -r -o./<br></code></pre></td></tr></table></figure><p>将<code>MyTest.7z</code>解压到当前目录</p><blockquote><p>x 代表解压缩文件，并且是以原本文件夹的方式解压（还有一个参数是e，会直接把所有文件从根目录解压）<br />-r 递归解压缩的所有子文件夹<br />-o 指定解压缩的目录，并且-o后面是没有空格的，这一点需要注意。</p></blockquote></li></ol><p>参考文章:</p><ol><li><a href="https://blog.csdn.net/whatday/article/details/50157273">linux下安装7z命令及7z命令的使用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloudflare Partner的CDN配置</title>
    <link href="/p/6a6a7409.html"/>
    <url>/p/6a6a7409.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过dnspod解析域名"><a class="markdownIt-Anchor" href="#通过dnspod解析域名"></a> 通过Dnspod解析域名</h2><p>​    由于服务器本身搭建使用的是香港的服务器，建站不需要域名备案。为了不使用Cloudflare默认的海外CDN，而使用我们需求的自定义CDN，需要把域名托管到一个非Cloudflare的平台下，这里直接托管到腾讯云Dnspod的解析下。</p><ol><li><p>备份Cloudflare下的解析信息</p></li><li><p>在控制台下修改Name Server为Dnspod控制台提供的NS服务器</p></li><li><p>将之前备份的解析信息再次添入</p><p>（这里没找到Dnspod的导入域名信息，所以手动添入）</p></li><li><p>开启&quot;域名设置&quot;下的CNAME加速，减少CNAME的解析次数</p></li></ol><h2 id="设置cloudflare-cname"><a class="markdownIt-Anchor" href="#设置cloudflare-cname"></a> 设置CloudFlare CNAME</h2><ol><li><p>注册Cloudflare邮箱，这里不做解释</p></li><li><p>在 <a href="https://cdn.ink/">楠格</a>(或者类似Cloudflare Partner网站) 登入自己的Cloudflare账号</p></li><li><p>将自己需要使用CDN的域名添加到控制台下，TTL设置两分钟，CDN设置为开启</p><p><img src="https://lsky.halc.top/hIWDDR.png" alt="域名添加" /></p></li><li><p>添加完毕以后在CNAME接入处可以看到主机名对应的CNAME信息，在Dnspod设置对应的解析就可以使用CDN的解析服务。</p><p><img src="https://lsky.halc.top/C0TJFQ.png" alt="域名添加" /></p><!-- markdownlint-disable MD033 --><div align=center>CNAME信息 </div><p><img src="https://lsky.halc.top/zI17lg.png" alt="Dnspod设置" /></p><div align=center>Dnspod设置 </div></li></ol><h2 id="自定义cdn节点"><a class="markdownIt-Anchor" href="#自定义cdn节点"></a> 自定义CDN节点</h2><p>​    通过参考网上的IP表，在Dnspod的控制台中再次添加域名对应的A记录解析，可以设置不同的运营商解析不同的IP，来达到让流量走自定义加速的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs plain">172.64.32.1/24 （推荐移动，走香港）<br>104.28.14.0/24 （推荐移动，走新加坡）<br>104.23.240.0-104.23.243.254 （推荐联通、移动，线路未知）<br>108.162.236.1/24 （推荐联通，走美国）<br>104.20.157.0/24 （推荐联通，走日本）<br>104.16.160.1/24 （推荐电信，走洛杉矶）<br>172.64.0.0/24 （推荐电信，走旧金山）<br>172.64.32.* （走欧洲）<br> <br>108.162.236.1/24 联通 走美国<br>172.64.32.1/24 移动 走香港<br>104.16.160.1/24 电信 走美国洛杉矶<br>172.64.0.0/24 电信 美国旧金山<br>104.20.157.0/24 联通 走日本<br>104.28.14.0/24 移动 走新加坡<br> <br>104.18.62.1/24 香港hkix.net<br>104.16.35.1/24 香港hkix.net<br>104.16.36.1/24 香港hkix.net<br>104.18.35.1/24 香港hkix.net<br>104.18.36.1/24 香港hkix.net<br>104.16.54.1/24 香港<br>104.16.55.1/24 香港<br>104.18.128.1/24 香港<br>104.18.129.1/24 香港<br>104.18.130.1/24 香港<br>104.18.131.1/24 香港<br>104.18.132.1/24 香港<br>104.19.195.1/24 香港<br>104.19.196.1/24 香港<br>104.19.197.1/24 香港<br>104.19.198.1/24 香港<br>104.19.199.1/24 香港<br>#适合电信的节点<br>104.23.240.*<br>#走欧洲各国出口 英国德国荷兰等 延迟比美国高一些 适合源站在欧洲的网站<br>172.64.32.*<br>#虽然去程走新加坡，但是回程线路的绕路的，实际效果不好，不推荐<br>104.16.160.*<br>#圣何塞的线路，比洛杉矶要快一点，推荐<br>108.162.236.*<br>#亚特兰大线路，延迟稳定，但是延迟较高<br>#适合移动的节点<br>162.158.133.* <br>#走的丹麦，这一段ip只有部分能用，可以自己试一下，绕美国<br>198.41.214.*<br>198.41.212.*<br>198.41.208.*<br>198.41.209.*<br>172.64.32.*<br>141.101.115.*<br>#移动走香港的IP段有很多，以上并不是全部。CF移动走香港的分直连和走ntt的效果都挺不错的，不过部分地区晚上还是会丢包。<br>172.64.0. *<br>#这是走圣何塞的，一般用香港的就行<br>172.64.16.* <br>#欧洲线路.绕<br>#1.0.0.1效果较好<br>电信部分<br>大多数省直接使用1.0.0.0即可，延迟低，丢包少，<br>## 移动部分<br>#新加坡<br>104.18.48.0-104.18.63.255<br>104.24.112.0-104.24.127.255<br>104.27.128.0-104.27.143.255<br>104.28.0.0-104.28.15.255<br>## 移动部分<br>#圣何塞 <br>104.28.16.0-31.255<br>104.27.144.0-243.254<br>104.23.240.0-243.254<br>#香港cloudflare1-100g.hkix.net<br>1.0.0.0-254<br>1.1.1.0-254<br>#香港直连<br>104.16.0.0-79.255<br>104.16.96.0-175.254<br>104.16.192.0-207.255<br></code></pre></td></tr></table></figure><p>设置了对应的A记录后保存退出，可通过<code>ping example.com</code>来测试是否设置成功。</p><p>参考网站:</p><ol><li><a href="https://www.wbolt.com/optimization-for-cn-websites-using-cloudflare.html">针对使用Cloudflare CDN国内网站的速度优化方案 - 闪电博 (wbolt.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多个不同版本内核卸载管理</title>
    <link href="/p/24f916f9.html"/>
    <url>/p/24f916f9.html</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu删除多余的内核"><a class="markdownIt-Anchor" href="#ubuntu删除多余的内核"></a> Ubuntu删除多余的内核</h2><ol><li><p>查看当前的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## uname -a<br>Linux azhal 5.11.16-xanmod1-cacule #0~git20210421.d9591de SMP PREEMPT Wed Apr 21 17:44:04 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure></li><li><p>查看当前系统中所有的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@azhal:~## dpkg --get-selections |grep linux<br>binutils-x86-64-linux-gnu                       install<br>console-setup-linux                             install<br>libselinux1:amd64                               install<br>libselinux1-dev:amd64                           install<br>linux-base                                      install<br>linux-firmware                                  install<br>linux-headers-5.11.16-xanmod1-cacule            install<br>linux-image-5.11.16-xanmod1-cacule              install<br>linux-image-5.4.0-72-generic                    install<br>linux-image-generic                             install<br>linux-libc-dev:amd64                            install<br>linux-modules-5.4.0-72-generic                  install<br>linux-modules-extra-5.4.0-72-generic            install<br>linux-xanmod-cacule                             install<br>util-linux                                      install<br></code></pre></td></tr></table></figure></li><li><p>移除多余的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove &lt;name of kernel&gt;<br></code></pre></td></tr></table></figure></li><li><p>再次检查内核是否为<code>deinstall</code>状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg --get-selections |grep linux<br></code></pre></td></tr></table></figure></li><li><p>更新系统引导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-grub<br></code></pre></td></tr></table></figure></li></ol><p>参考文章</p><ol><li><a href="https://www.cnblogs.com/yangzhaon/p/12911716.html">Ubuntu删除多余的内核 - 阳光与叶子 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置CDN回源重定向导致的无法访问问题</title>
    <link href="/p/a2277ea0.html"/>
    <url>/p/a2277ea0.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>​    在部署好了CloudReve和Nginx以后，想通过Cloudflare的免费的CDN服务来达到一个节省流量的目的，但是在直接开启CDN代理之后发现原本的网站一直出现Network Error的问题，在此记录一下解决方案。</p><p>​    首先记录一下现状：</p><ul><li>CloudReve部署在自己家的服务器上，通过ZeroTier和香港的服务器虚拟局域网相连，并且通过Nginx反代</li><li>Nginx配置好了SSL证书，开启了强制使用HTTPS链接</li></ul><p>​    测试的现状：</p><ul><li>在开启强制HTTPS链接的时候使用CDN加速，连接CloudReve的时候会出现Network Error，网页控制台报错重定向次数过多。</li><li>关闭强制HTTPS链接使用CDN加速并且通过HTTPS进行链接的时候正常。</li></ul><blockquote><p>参考了的可能有帮助的解决方案</p><ol><li><a href="https://www.dyxmq.cn/uncategorized/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%9Acdn%E5%BC%80%E5%90%AF%E5%BC%BA%E5%88%B6https%E4%B9%8B%E5%90%8E%E8%BF%94%E5%9B%9E%E9%87%8D%E5%AE%9A%E5%90%91%E6%AC%A1%E6%95%B0%E8%BF%87%E5%A4%9A%E7%9A%84.html">踩坑记录：CDN开启强制https之后返回重定向次数过多的问题</a></li></ol></blockquote><h2 id="尝试了的解决办法"><a class="markdownIt-Anchor" href="#尝试了的解决办法"></a> 尝试了的解决办法</h2><ol><li><p>由于CDN是先到香港的服务器，是https访问，然后香港的服务器到自己的网盘是http访问，根据上方参考的&quot;踩坑记录&quot;方案一，给家里的服务器的cloudreve加了一个ssl证书再次尝试代理，问题依旧。</p></li><li><p>同根据“踩坑记录”，在nginx的配置文件中添加以下配置</p><p><code>proxy_set_header X-Forwarded-Proto $scheme;</code></p><p>附上解释原因：</p><blockquote><p>设置http头部<code>X-Forwarded-Proto</code>，这个头部的作用是用于识别协议（HTTP 或 HTTPS），主要针对内部访问重定向时的协议。因此，只要在反向代理时添加以上配置就好了</p><p><code>$scheme</code>是nginx的内部变量，表明当前访问的协议，当前如果是https，那么转发到后台服务的时候就是https。这样问题就解决了。</p></blockquote><p><strong>但是问题依旧</strong></p><p>之后认为问题不出在香港服务器到家中服务器，寻找其他的解决方案。</p></li></ol><h2 id="在非cloudflare的cdn上的解决方案"><a class="markdownIt-Anchor" href="#在非cloudflare的cdn上的解决方案"></a> 在非Cloudflare的CDN上的解决方案</h2><p>​    在查询和强制HTTPS有关词条的时候查询到这是CDN云加速很容易遇到的一个问题，解决方案主要有三种。</p><ol><li>设置CDN的回源端口为443端口，让CDN回源的时候以HTTPS请求源站，这样就不会触发源站的强制跳转的逻辑了。</li><li>在CDN的控制台中设置回源设置为“跟随”（一般会有三个选项，分别是“回源”，“HTTP”和“HTTPS”。）</li><li>放弃强制跳转HTTPS，在Nginx关闭强制。</li></ol><h2 id="最后在cloudflare上的解决方案"><a class="markdownIt-Anchor" href="#最后在cloudflare上的解决方案"></a> 最后在Cloudflare上的解决方案</h2><p>​    由于没有找到Cloudflare上有类似CDN控制台的地方（感觉毕竟是免费的，没有正常。不过也可能是我太菜了不知道在哪里），于是上面的三种办法都不得不作罢，只能另寻其他办法。</p><ol><li>香港的服务器上关闭Nginx的强制https</li><li>在cloudflare的&quot;Rules&quot;里面添加Page Rules，设置里面添加对应的域名，然后开启始终使用HTTPS</li></ol><blockquote><p>有一说一，结果是启用了免费的CDN以后速度还是比较慢，而且多线程下载也没有缓存很多文件，后期还是试试Cloudflare Partner或者其他的项目比较好。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google镜像站创建引导</title>
    <link href="/p/15b685e1.html"/>
    <url>/p/15b685e1.html</url>
    
    <content type="html"><![CDATA[<p>步骤如下:</p><ol><li><p>在Nginx中创建Google的Nginx反代<code>www.google.com.hk</code></p></li><li><p>配置SSL证书并保存，启用HTTPS</p></li><li><p>配置upstream设置</p><ul><li><p>通过如下方式获取google的不同ip</p><p><code>dig www.google.com @8.8.8.8 +short</code></p></li><li><p>将类似如下配置文件配置好</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> www.google.com.hk &#123;<br>     ip_hash;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">108.177.125.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">64.233.189.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">74.125.23.199:443</span>;<br>     <span class="hljs-attribute">server</span> <span class="hljs-number">172.217.24.35:443</span>;<br>     &#125;<br><br><span class="hljs-section">server</span><br>&#123;...&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在server中配置防爬虫和禁止IP访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span><br>&#123;<br><br>    ...<br><br>    <span class="hljs-comment"># 防止网络爬虫</span><br>    <span class="hljs-comment">#forbid spider</span><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_user_agent</span> <span class="hljs-regexp">~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo!</span> Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot<span class="hljs-string">&quot;) </span><br><span class="hljs-string">    &#123; </span><br><span class="hljs-string">        return 403; </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    # 禁止用其他域名或直接用IP访问，只允许指定的域名访问</span><br><span class="hljs-string">    #forbid illegal domain</span><br><span class="hljs-string">    if ( <span class="hljs-variable">$host</span> != &quot;</span>yourdomain.com<span class="hljs-string">&quot; ) &#123;</span><br><span class="hljs-string">        return 403; </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">     </span><br><span class="hljs-string">    ...</span><br><span class="hljs-string">    </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>检查并重启配置文件</p><p><code>nginx -t &amp;&amp; nginx -s reload</code></p></li><li><p>在宝塔防火墙中关闭’GET’过滤，否则会导致搜索某些关键词的时候被误判封锁IP</p></li></ol><p>参考文章:</p><ol><li><a href="https://blog.oyi.me/619">(<em>´∇｀</em>) 被你发现啦~ 搭建google镜像网站(适用最新版nginx)Module for Google Mirror – 深海 (oyi.me)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH技巧总结</title>
    <link href="/p/cff2e0b5.html"/>
    <url>/p/cff2e0b5.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过密钥连接服务器"><a class="markdownIt-Anchor" href="#通过密钥连接服务器"></a> 通过密钥连接服务器</h2><h3 id="生成密钥"><a class="markdownIt-Anchor" href="#生成密钥"></a> 生成密钥</h3><ol><li><p>在客户端电脑上输入以下指令生成rsa私钥和公钥</p><p><code>ssh-keygen -t rsa -C &quot;your@email.com&quot;</code></p><p>生成一对以你的邮箱为标签的密钥</p></li><li><p>在<code>/.ssh/</code>文件夹下的<code>id_rsa</code>为密钥文件，<code>id_rsa.pub</code>为公钥文件</p></li></ol><h3 id="在linux服务器下添加密钥"><a class="markdownIt-Anchor" href="#在linux服务器下添加密钥"></a> 在Linux服务器下添加密钥</h3><ol><li>在当前用户的主目录中的<code>/.ssh/</code>中添加或者修改<code>authorized_keys</code>文件，将刚刚客户端的<code>id_rsa.pub</code>内容复制到<code>authorized_keys</code>中</li></ol><h3 id="关闭密码登入并且只用rsa登入"><a class="markdownIt-Anchor" href="#关闭密码登入并且只用rsa登入"></a> 关闭密码登入，并且只用RSA登入</h3><ol><li><p>编辑<code>sshd_config</code>文件</p><p><code>vi /etc/ssh/sshd_config</code></p></li><li><p>禁用密码验证</p><p>将<code>PasswordAuthentication</code>的注释取消，并修改为</p><p><code>PasswordAuthentication no</code></p></li><li><p>重启SSH服务</p><p>​    <strong>注意，重启SSH服务之前建议保留一个会话，以免出现密码登入失败的情况</strong></p><ul><li><p>RHEL/CentOS系统</p><p><code>sudo service sshd restart</code></p></li><li><p>Ubuntu系统</p><p><code>sudo service ssh restart</code></p></li></ul></li></ol><h2 id="常用的ssh-config参数"><a class="markdownIt-Anchor" href="#常用的ssh-config参数"></a> 常用的ssh config参数</h2><h3 id="建立前的配置"><a class="markdownIt-Anchor" href="#建立前的配置"></a> 建立前的配置</h3><p>在建立连接的时候，如果是第一次对一个服务器建立连接，经常会问到我们是否信任对方，并且在第一次建立连接之后，如果同一个IP地址后的服务器有过重装，还会因为之前保存的证书而出现连接失败的情况。</p><p>因此可以在<code>~/.ssh/config</code>文件中添加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">StrictHostKeyChecking no # 关闭主机公钥的确认信息，去掉了连接时候的提问，不过也因此有安全隐患，需要自己权衡<br>UserKnownHostsFile /dev/null #  在和某个主机建立连接以后，ssh就会将密钥存储在本地的一个known_hosts文件中，配置为/dev/null相当于不保存<br></code></pre></td></tr></table></figure><h3 id="连接服务器"><a class="markdownIt-Anchor" href="#连接服务器"></a> 连接服务器</h3><p>同时，有的时候我们需要频繁访问同一个服务器，反复输入<code>ssh root@xxx.xxx.xxx.xxx</code>是很令人恼火的一件事（即使有的域名或历史记录）。这个时候我们就可以通过在<code>config</code>中添加一个<code>Host</code>来给我们需要的服务器添加一个简单易懂的别名来建立连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host router<br>    User root<br>    HostName 192.168.100.123<br></code></pre></td></tr></table></figure><p>假设我们路由器的IP地址是<code>192.168.100.123</code>，那么我们就可以将原本的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@192.168.100.123<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh router<br></code></pre></td></tr></table></figure><p>这样<code>ssh</code>就会使用<code>root</code>用户来登入<code>192.168.100.123</code>了</p><h3 id="x11窗口转发"><a class="markdownIt-Anchor" href="#x11窗口转发"></a> X11窗口转发</h3><p>对于一些有GUI的Linux系统来说，有的时候我们并不希望远程整个桌面，而是通过SSH来运行部分图形化的程序。在<code>Windows</code>当中，我们可以通过安装<code>VcXsrv</code>来提供一个SSH的转发接口，然后在<code>~/.ssh/config</code>中对应的服务器添加如下参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host study<br>    User halc<br>    HostName 192.168.100.101<br>    ForwardX11 yes<br>    ForwardX11Trusted yes<br></code></pre></td></tr></table></figure><p>这样我们在和对应服务器建立连接以后，就可以通过在自己电脑上的<code>cli</code>运行远程服务器中带有<code>GUI</code></p><h3 id="多文件配置"><a class="markdownIt-Anchor" href="#多文件配置"></a> 多文件配置</h3><p>在有的时候<code>ssh</code>需要连接的主机可能很多，放在一个文件里面可能会不便于管理。这个时候我们就可以通过<code>Include</code>关键字，来添加其他的<code>config</code>合并进来。</p><p>假设当前我们的<code>.ssh</code>目录的结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">~ [ tree .ssh                                                                                                          ] 1:40 PM<br>.ssh<br>├── authorized_keys<br>├── conf.d<br>│   └── home<br>├── config<br>├── id_rsa<br>└── id_rsa.pub<br></code></pre></td></tr></table></figure><p>那么我们就可以在<code>config</code>当中添加<code>Include conf.d/home</code>来实现对于<code>home</code>文件的多文件配置涵盖。参考如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">StrictHostKeyChecking no<br>UserKnownHostsFile /dev/null<br>GSSAPIAuthentication=no<br><br>Include conf.d/home<br><br>Host node1<br>    User root<br>    HostName xxx.xxx.xxx.xx<br><br>...<br></code></pre></td></tr></table></figure><p>在<code>home</code>当中就可以添加正常的<code>ssh</code>配置了</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/p/e8eb0481.html"/>
    <url>/p/e8eb0481.html</url>
    
    <content type="html"><![CDATA[<h2 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsl</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回左边界</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) <span class="hljs-comment">//每次正确右边界都向左缩小</span><br>            r = mid;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//mid不正确，弃用mid并且缩小区间</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsr</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回右边界</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) <span class="hljs-comment">//每次左边界都向右缩小，由于存在向下取整，避免死循环mid需要l+r+1</span><br>            l = mid;<br>        <span class="hljs-keyword">else</span><br>            r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//mid不正确，弃用mid并缩小区间</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码原理"><a class="markdownIt-Anchor" href="#代码原理"></a> 代码原理</h2><h3 id="以bsl为例"><a class="markdownIt-Anchor" href="#以bsl为例"></a> 以<code>bsl</code>为例</h3><p>​    二分的主要的作用，是取得一个“分界点”。采取的思路为<strong>测试中间点是否符合条件，如果不符合则对区间进行缩小操作，重新测试区间，直到区间为一个数字。<strong>在模板一中，首先确定中间点<code>mid</code>，然后测试中间点mid是否符合条件，如果符合条件，则每次都会</strong>将区间的右端点进行左移的操作，直到不能左移为止</strong>，所以返回的最后位置为<strong>最接近答案的最左边的端点</strong>。如果不符合条件，由于**确定了<code>mid</code>的位置为无效位置，所以下一次刷新区间的时候将mid剔除掉。**剔除的操作可以达到防止死循环的效果</p><h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2><p>​    由于二分是每次都将一个区间一分为二，并且对整个区间进行一次操作，所以最后的时间复杂度为<code>O(logN)</code></p><h2 id="需要注意的点"><a class="markdownIt-Anchor" href="#需要注意的点"></a> 需要注意的点</h2><ol><li>在<code>bsr</code>中，由于在每次正确的时候修改的都是左边界<code>l</code>，但是在<code>计算除2</code>的时候会存在<code>mid/2取整为l</code>的情况，这样会导致最后结果的死循环。所以需要定义mid为<code>mid = l+r+1&gt;&gt;1</code>来避免死循环。<s>可以记为 <strong>返回右边界的时候需要+1，因为右边比左边大（bushi</strong></s></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CloudReve个人网盘引导</title>
    <link href="/p/713e2886.html"/>
    <url>/p/713e2886.html</url>
    
    <content type="html"><![CDATA[<h2 id="预先准备"><a class="markdownIt-Anchor" href="#预先准备"></a> 预先准备</h2><ol><li>安装好宝塔面板，并且预先安装好LNMP环境</li><li>Aria2离线下载配置</li><li>在<a href="https://freessl.cn">FreeSSL</a>上获取SSL证书和密钥</li></ol><h2 id="cloudreve部署"><a class="markdownIt-Anchor" href="#cloudreve部署"></a> CloudReve部署</h2><h3 id="安装cloudreve"><a class="markdownIt-Anchor" href="#安装cloudreve"></a> 安装CloudReve</h3><ol><li><p>前往<a href="https://github.com/cloudreve/Cloudreve/releases">官方库</a>下载最新版的对应系统的可执行文件</p></li><li><p>在BT面板内添加网站CloudReve，并且设置对应的域名和根目录（下图为示例）</p><p><img src="https://lsky.halc.top/gIy7SN.png" alt="BT面板创建新网站" /></p></li><li><p>将可执行文件上传到在宝塔面板设置的根目录中，并<code>cd</code>到当前目录</p></li><li><p>运行CloudReve，并记录初始的账号密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x ./cloudreve<br>./cloudreve<br></code></pre></td></tr></table></figure></li><li><p>登入<code>http://ip:5212</code>，在控制面板中修改默认的管理员账号和密码</p></li></ol><h3 id="修改数据库为mysql"><a class="markdownIt-Anchor" href="#修改数据库为mysql"></a> 修改数据库为MySql</h3><blockquote><p>自带的数据库是SQLite，这里需要修改为MySql</p></blockquote><ol><li><p>在宝塔面板创建一个MySql数据库</p></li><li><p>在运行一次CloudReve后，根目录会有一个<code>conf.ini</code>的文件，根据自己情况加入以下配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">; 数据库相关，如果你只想使用内置的 SQLite数据库，这一部分直接删去即可<br>[Database]<br>; 数据库类型，目前支持 sqlite | mysql<br>Type = mysql<br>; MySQL 端口<br>Port = 3306<br>; 用户名<br>User = root<br>; 密码<br>Password = root<br>; 数据库地址<br>Host = 127.0.0.1<br>; 数据库名称<br>Name = v3<br>; 数据表前缀<br>TablePrefix = cd_<br>; SQLite 数据库文件路径<br>DBFile = cloudreve.db<br></code></pre></td></tr></table></figure></li></ol><h3 id="添加进程守护"><a class="markdownIt-Anchor" href="#添加进程守护"></a> 添加进程守护</h3><blockquote><p>这里使用Ubuntu自带的systemd进行进程守护</p></blockquote><ol><li><p>编辑配置文件</p><p><code>vim /usr/lib/systemd/system/cloudreve.service</code></p></li><li><p>将下文的<code>PATH_TO_CLOUDREVE</code>更改为宝塔面板中设置的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=Cloudreve<br>Documentation=https://docs.cloudreve.org<br>After=network.target<br>After=mysqld.service<br>Wants=network.target<br><br>[Service]<br>WorkingDirectory=/PATH_TO_CLOUDREVE<br>ExecStart=/PATH_TO_CLOUDREVE/cloudreve<br>Restart=on-abnormal<br>RestartSec=5s<br>KillMode=mixed<br><br>StandardOutput=null<br>StandardError=syslog<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>载入进程守护并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl start cloudreve<br>systemctl enable cloudreve<br></code></pre></td></tr></table></figure></li></ol><h3 id="设置nginx反代"><a class="markdownIt-Anchor" href="#设置nginx反代"></a> 设置Nginx反代</h3><ol><li><p>在宝塔面板的站点设置中，添加反向代理，配置按下图类比设置(主要还是第二步)</p><p><img src="https://lsky.halc.top/supU6G.png" alt="BT设置反向代理" /></p></li><li><p>点击配置文件，将原本的<code>location /&#123;&#125;</code>的内容替换如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">location / &#123;<br>    proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>    proxy_redirect off;<br>    proxy_pass http://127.0.0.1:5212;<br><br>    <span class="hljs-comment">## 如果您要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸</span><br>    <span class="hljs-comment">## client_max_body_size 20000m;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>保存配置文件，通过宝塔中设置的网站域名即可直接访问网盘地址</p></li></ol><h3 id="配置ssl证书"><a class="markdownIt-Anchor" href="#配置ssl证书"></a> 配置SSL证书</h3><ol><li>在FreeSSL获取证书以后，在<code>KeyManager</code>中导出证书和私钥，分别为<code>.crt</code>和<code>.key</code>文件</li><li>在站点设置中找到SSL，使用<code>其他证书</code>，然后通过编辑器打开<code>crt</code>证书文件和<code>key</code>文件，分别将其中的内容复制到<code>密钥(KEY)</code>和<code>证书(PEM格式)</code>中</li><li>保存并开启强制HTTPS，即可通过SSL访问云盘并且进行配置了。</li></ol><p>参考网站：</p><ol><li><a href="https://blog.lanhui.co/1623.html">Cloudreve对接onedrive搭建属于自己的网盘系统 (lanhui.co)</a></li><li><a href="https://docs.cloudreve.org/">CloudReve官方文档</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux配置局域网下网络唤醒</title>
    <link href="/p/12aa3ef8.html"/>
    <url>/p/12aa3ef8.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装网络管理工具</p><p><code>sudo apt install ethtool</code></p></li><li><p>查询网口信息</p><p><code>ip a</code></p><p>记录需要启动的网口名字</p></li><li><p>通过指令手动启动wol服务</p><p><code>ethtool -s [INTERFACE] wol g</code></p></li><li><p>查询是否成功</p><p><code>ethtool [INTERFACE]</code></p><p>输出信息中如果显示<code>wol:g</code>则代表开启成功</p></li><li><p>创建开机进程</p><p><code>sudo vi /etc/systemd/system/wol.service</code></p></li><li><p>写入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=Configure Wake On LAN<br><br>[Service]<br>Type=oneshot<br>ExecStart=/sbin/ethtool -s [INTERFACE] wol g<br><br>[Install]<br>WantedBy=basic.target<br></code></pre></td></tr></table></figure></li><li><p>载入systemd并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> wol.service<br>sudo systemctl start wol.service<br></code></pre></td></tr></table></figure></li></ol><p>参考博客</p><p>1.<a href="https://my.oschina.net/u/4408675/blog/4450878">WOL持久化设置</a></p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的安装和镜像设置</title>
    <link href="/p/92f7b8a.html"/>
    <url>/p/92f7b8a.html</url>
    
    <content type="html"><![CDATA[<p>参考资料:<br />1.<a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">Docker-从入门到实践</a></p><blockquote><p>在挂载网易云音乐灰色代理的时候终于还是发现了screen后台运行的坏处，经常会出现不小心重启以后忘记开启服务的情况，由于之前一直听说过docker容器，并且灰色代理有现成的docker容器可以使用，在简单查询和操作了一下以后记录一下docker启动网易云音乐并且进行网易云音乐代理的实战</p></blockquote><h2 id="docker部署和安装"><a class="markdownIt-Anchor" href="#docker部署和安装"></a> Docker部署和安装</h2><ol start="0"><li><p>(可选) 通过一键脚本进行安装，安装完成后可跳过以下所有步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>如果要安装测试版的Docker，则用以下脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL test.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror AzureChinaCloud<br></code></pre></td></tr></table></figure></li><li><p>使用<code>apt</code>进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br><br>sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></figure></li><li><p>替换国内软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure></li><li><p>启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure></li><li><p>检测是否已经设置镜像</p><blockquote><p>请首先执行以下命令，查看是否在 <code>docker.service</code> 文件中配置过镜像地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\-\-registry\-mirror&#x27;</span><br></code></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p></blockquote></li><li><p>设置镜像</p><p>创建并编辑<code>/etc/docker/daemon.json</code></p><p>写入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  &quot;registry-mirrors&quot;: [<br>    &quot;https://hub-mirror.c.163.com&quot;,<br>    &quot;https://mirror.baidubce.com&quot;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>检测是否正常</p><p><code>docker run --rm hello-world</code></p><p>通过检查返回信息检查是否成功安装并且部署Docker环境</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux通过fdisk分区引导</title>
    <link href="/p/3efcbb51.html"/>
    <url>/p/3efcbb51.html</url>
    
    <content type="html"><![CDATA[<p>参考地址：<br /><a href="https://blog.csdn.net/xjtumengfanbin/article/details/106871591">CSDN-树莓派Openwrt SD卡扩展问题</a></p><p>​    在给自己的R2S使用64G的SD卡的时候，安装完毕系统启动发现内存卡中有将近50多G的空间没有得到合理的使用，记录一下通过网上树莓派磁盘扩展分区的步骤来在R2S上同样对SD卡进行分区拓展</p><h2 id="fdisk磁盘拓展"><a class="markdownIt-Anchor" href="#fdisk磁盘拓展"></a> fdisk磁盘拓展</h2><ol><li><p>磁盘检查</p><p><code>df -h</code>  检查已经使用的磁盘容量</p><p><code>fdisk /dev/mmcblk0</code>  查看磁盘分区，并进行部分操作</p></li><li><p>检查磁盘分区情况并且进行分区</p><p>在<code>fdisk</code>后的<code>Command( m for help):</code>后输入<code>p</code>来查看分区情况</p><p><img src="https://lsky.halc.top/alLijz.png" alt="fdiskp" /></p><p>其中可以看到最后分区的<code>End</code>为<code>3817471</code></p></li><li><p>新建磁盘</p><p>输入<code>n</code>进行新建磁盘，之后会有几个询问，分别对应以下几点</p><ul><li>输入磁盘编码，一般按Default的设置即可</li><li>输入扇区的起始位置，这里输入最后一个分区+1的数值大小，比如上图中<code>End</code>后为<code>3817471</code>，那我这里就输入<code>3817472</code></li><li>输入终止扇区，这里可以填入Default设置，就会设置最大可用扇区</li><li>输入<code>w</code>进行保存</li></ul></li><li><p>把新建的分区格式化为ext4格式</p><p><code>mkfs.ext4 /dev/mmcblk0p3</code></p></li><li><p>分区挂载</p><ul><li>方法一<ul><li>在Openwrt的管理界面的挂载点中，直接使用&quot;自动挂载&quot;进行磁盘的挂载</li></ul></li><li>方法二<ul><li><code>mount -v -t ext4 -o rw /dev/mmcblk0p3 [pathToMount]</code></li></ul></li></ul></li><li><p>通过<code>df -h</code>命令查看，可以发现已经挂载成功</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>OpenWRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下通过swap或zram管理内存</title>
    <link href="/p/5a7c7761.html"/>
    <url>/p/5a7c7761.html</url>
    
    <content type="html"><![CDATA[<p>参考网址:<br />1.<a href="https://imhy.zbyzbyzby.com/wordpress/?p=815">Ubuntu开启zram和zswap~</a><br />2.<a href="https://blog.gloriousdays.pw/2018/11/30/memory-compress-using-zram/">使用zram进行内存压缩</a><br />3.<a href="https://www.jianshu.com/p/498858f8d704">Ubuntu添加swap分区</a></p><h2 id="创建swap分区"><a class="markdownIt-Anchor" href="#创建swap分区"></a> 创建Swap分区</h2><blockquote><p>Swap分区在系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。</p><p>Swap分区虽然可以达到扩大内存的作用，但缺点依旧很明显，相比直接使用物理内存，Swap必然速度上会出现一定的取舍。</p></blockquote><ol><li><p>新建一个文件夹来作为swap的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir swap<br>cd swap<br>sudo dd if=/dev/zero of=sfile bs=1024 count=2000000<br></code></pre></td></tr></table></figure><p>其中<code>sfile</code>是文件的名字，可以自己设置，<code>count=2000000</code>是Swap分区的大小，这里指2G</p></li><li><p>转化为swap文件</p><p><code>sudo mkswap sfile</code></p></li><li><p>激活swap文件</p><p><code>sudo swapon sfile</code></p></li><li><p>查看效果</p><p><code>free -m</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">              total        used        free      shared  buff/cache   available<br>Mem:            478          61         184           3         233         379<br>Swap:          2704           0        2704<br></code></pre></td></tr></table></figure><p>已经成功挂载了</p></li><li><p>添加开机加载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/fstab<br></code></pre></td></tr></table></figure><p>修改配置文件，添加Swap文件(Swap文件的路径为<code>/root/swap/sfile</code>)</p><p><code>/root/swap/sfile none swap sw 0 0</code></p><p>类似如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/vda1           /               ext4    defaults  1 1<br>/dev/vda2           swap            swap    defaults  0 0<br>/root/swap/sfile    none            swap    sw        0 0<br>none                /dev/shm        tmpfs   defaults  0 0<br></code></pre></td></tr></table></figure></li></ol><h2 id="使用zram进行内存压缩"><a class="markdownIt-Anchor" href="#使用zram进行内存压缩"></a> 使用zram进行内存压缩</h2><blockquote><p>swap空间在机械硬盘的设备上往往不一定是个好选择，这个时候牺牲一定的CPU性能来使用zram则会比较好</p><p>zram 是在 Linux Kernel 3.2 加入的一个模块，其功能是在内存中开辟一块空间，用来存储压缩后的内存数据，这样可以在牺牲一定的 CPU Cycle 的情况下，在内存中存储尽量多的数据而不需要写入到磁盘。</p></blockquote><ol><li><p>安装zram-config，并重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install zram-config<br>sudo reboot<br></code></pre></td></tr></table></figure></li><li><p>通过zramctl查看zram的情况(默认情况下ALGORITHM为lzo)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME       ALGORITHM DISKSIZE DATA COMPR TOTAL STREAMS MOUNTPOINT<br>/dev/zram0 lz4         239.4M   4K   63B    4K       1 [SWAP]<br></code></pre></td></tr></table></figure><blockquote><p>注意到这里的压缩算法，有两种算法 lzo 和 lz4 可选，默认是 lzo。根据 <a href="https://github.com/lz4/lz4">Benchmark</a>，lz4 的压缩和解压性能在压缩率和 lzo 持平的情况下显著高于后者，因此我们应该采用 lz4 而非 lzo 以获得更高的系统效率。</p></blockquote></li><li><p>修改配置文件来使用lz4算法</p><p><code>usr/bin/init-zram-swapping</code></p><p>将源文件的以下部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># initialize the devices</span></span><br>for i in $(seq $&#123;NRDEVICES&#125;); do<br>  DEVNUMBER=$((i - 1))<br>  echo $mem &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/disksize<br>  mkswap /dev/zram$&#123;DEVNUMBER&#125;<br>  swapon -p 5 /dev/zram$&#123;DEVNUMBER&#125;<br>done<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># initialize the devices</span></span><br>for i in $(seq $&#123;NRDEVICES&#125;); do<br>  DEVNUMBER=$((i - 1))<br>  echo lz4 &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/comp_algorithm<br>  echo $mem &gt; /sys/block/zram$&#123;DEVNUMBER&#125;/disksize<br>  mkswap /dev/zram$&#123;DEVNUMBER&#125;<br>  swapon -p 5 /dev/zram$&#123;DEVNUMBER&#125;<br>done<br></code></pre></td></tr></table></figure></li><li><p>载入新的配置</p><p><code>systemctl restart zram-config</code></p></li></ol><h2 id="开启zswap"><a class="markdownIt-Anchor" href="#开启zswap"></a> 开启ZSwap</h2><ol><li><p>编辑grub文件</p><p><code>sudo vi /etc/default/grub</code></p></li><li><p>在文件末尾加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GRUB_CMDLINE_LINUX=”zswap.enabled=1″<br></code></pre></td></tr></table></figure><p>保存退出</p></li><li><p>在终端输入命令</p><p><code>sudo update-grub</code></p></li><li><p>重启系统</p></li></ol><blockquote><p>zswap是一种新的轻量化后端构架，将进程中正交换出的页面压缩，并存储在一个基于RAM的内存缓冲池中。除一些为低内存环境预留的一小部分外，zswap缓冲池不预先分配，按需增加，最大尺寸可用户自定义。</p><p>Zswap启动存在于主线程中的一个前端，称为frontswap，zswap/frontswap进程在页面真正交换出之前监听正常交换路径，所以现有的交换页面选择机理不变。</p><p>Zswap也引入重要功能，当zswap缓冲池满时自动驱除页面从zswap缓冲池到swap设备。防止陈旧页面填满缓冲池。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier配置Moon服务器</title>
    <link href="/p/c1161a88.html"/>
    <url>/p/c1161a88.html</url>
    
    <content type="html"><![CDATA[<p>参考链接:<br />1.<a href="https://post.smzdm.com/p/adwrepgk/">什么值得买-ZeroTier配置Moon节点</a></p><p>2.<a href="https://www.zerotier.com/manual/#4_4">ZeroTier官方手册</a></p><h2 id="安装moon服务器的作用"><a class="markdownIt-Anchor" href="#安装moon服务器的作用"></a> 安装Moon服务器的作用</h2><p>​    ZeroTier本身的PLANET服务器位于国外，并且由于免费的性质以至于在一些高峰时期经常出现无法打通隧道的情况，这个时候通过自己搭建国内的Moon节点并且进行配置可以达到国内中转加速的作用。</p><h2 id="moon服务器在vps上的搭建"><a class="markdownIt-Anchor" href="#moon服务器在vps上的搭建"></a> Moon服务器在VPS上的搭建</h2><ol><li><p>将需要设置moon节点的VPS加入到需要加速的局域网内</p><p><code>zerotier-cli join &lt;network id&gt;</code></p></li><li><p>生成moon模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/zerotier-one<br>zerotier-idtool initmoon identity.public &gt; moon.json<br></code></pre></td></tr></table></figure></li><li><p>修改moon.json</p><p><code>vi moon.json</code></p><p>修改<code>stableEndpoints</code>为VPS的公网IP，可以添加ipv6地址，例如：</p><p><code>&quot;stableEndpoints&quot;: [ &quot;10.0.0.2/9993&quot;,&quot;2001:abcd:abcd::1/9993&quot; ]</code></p><p>完整的文件内容示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;deadbeef00&quot;</span>,<br>  <span class="hljs-string">&quot;objtype&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>,<br>  <span class="hljs-string">&quot;roots&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;identity&quot;</span>: <span class="hljs-string">&quot;deadbeef00:0:34031483094...&quot;</span>,<br>      <span class="hljs-string">&quot;stableEndpoints&quot;</span>: [ <span class="hljs-string">&quot;10.0.0.2/9993&quot;</span>,<span class="hljs-string">&quot;2001:abcd:abcd::1/9993&quot;</span> ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;identity&quot;</span>: <span class="hljs-string">&quot;feedbeef11:0:83588158384...&quot;</span>,<br>      <span class="hljs-string">&quot;stableEndpoints&quot;</span>: [ <span class="hljs-string">&quot;10.0.0.3/9993&quot;</span>,<span class="hljs-string">&quot;2001:abcd:abcd::3/9993&quot;</span> ]<br>    &#125;<br>  ],<br>  <span class="hljs-string">&quot;signingKey&quot;</span>: <span class="hljs-string">&quot;b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0&quot;</span>,<br>  <span class="hljs-string">&quot;signingKey_SECRET&quot;</span>: <span class="hljs-string">&quot;ffc5dd0b2baf1c9b220d1c9cb39633f9e2151cf350a6d0e67c913f8952bafaf3671d2226388e1406e7670dc645851bf7d3643da701fd4599fedb9914c3918db3&quot;</span>,<br>  <span class="hljs-string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="hljs-string">&quot;b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0&quot;</span>,<br>  <span class="hljs-string">&quot;worldType&quot;</span>: <span class="hljs-string">&quot;moon&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成moon签名文件</p><p><code>zerotier-idtool genmoon moon.json</code></p></li><li><p>通过winscp等工具将<code>000000xxxx.moon</code>的签名文件拷贝下来，或者记住<code>moon.json</code>中<code>&quot;id&quot;: &quot;idtoremember&quot;</code>的<code>id</code></p></li><li><p>将moon节点加入网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> moons.d<br><span class="hljs-built_in">mv</span> ./*.moon ./moons.d<br></code></pre></td></tr></table></figure></li><li><p>重启ZeroTier，到此Moon服务器的配置结束。</p></li></ol><h2 id="在客户端启用配置好的节点"><a class="markdownIt-Anchor" href="#在客户端启用配置好的节点"></a> 在客户端启用配置好的节点</h2><h3 id="方法一通过id直接加入"><a class="markdownIt-Anchor" href="#方法一通过id直接加入"></a> 方法一：通过ID直接加入</h3><ol><li><p>在搭建moon服务器的第五步中，记录下moon节点的id，然后在客户端上运行命令</p><p><code>zerotier-cli orbit idtoremeber idtoremeber</code></p></li></ol><h3 id="方法二通过添加签名文件加入"><a class="markdownIt-Anchor" href="#方法二通过添加签名文件加入"></a> 方法二：通过添加签名文件加入</h3><ol><li><p>在不同设备的ZeroTier根目录下添加moons.d文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">其中，不同系统对应的ZeroTier的位置如下：<br>Windows: C:\ProgramData\ZeroTier\One<br>Macintosh: /Library/Application Support/ZeroTier/One)<br>Linux: /var/lib/zerotier-one<br>FreeBSD/OpenBSD: /var/db/zerotier-one<br></code></pre></td></tr></table></figure></li><li><p>将生成的0000xxx.moon文件放置于moons.d文件夹下</p></li></ol><h4 id="openwrt下zerotier配置moon服务器"><a class="markdownIt-Anchor" href="#openwrt下zerotier配置moon服务器"></a> Openwrt下ZeroTier配置Moon服务器</h4><blockquote><p>OpenWrt需要修改一个脚本，因为其var目录是一个内存虚拟的临时目录，重启后原有配置不会保留。</p></blockquote><ol><li><p>通过ssh连接到Openwrt并修改zerotier的启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/init.d/zerotier<br></code></pre></td></tr></table></figure></li><li><p>在<code>add_join()&#123;&#125;</code>上方插入两行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$CONFIG_PATH</span>/moons.d<br><span class="hljs-built_in">cp</span> /home/moons.d/* <span class="hljs-variable">$CONFIG_PATH</span>/moons.d/<br></code></pre></td></tr></table></figure><p>如下图所示:</p><p><img src="https://lsky.halc.top/laU3wA.png" alt="ZeroTier的Moon节点" /></p></li><li><p>在/home文件夹下创建moons.d文件夹（修改<code>cp /home/moons.d</code>可以修改需要设置的路径）</p></li><li><p>把moon的签名文件00000xxx.moon放于该文件夹内，并重启ZeroTier即可</p></li></ol><h5 id="补充解决openwrt重启后zerotier的id重新分配的问题"><a class="markdownIt-Anchor" href="#补充解决openwrt重启后zerotier的id重新分配的问题"></a> 补充：解决Openwrt重启后ZeroTier的ID重新分配的问题</h5><ol><li><p>启动Openwrt上的ZeroTier</p></li><li><p>输入以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -a /var/lib/zerotier-one /etc/zerotier<br></code></pre></td></tr></table></figure></li><li><p>修改<code>/etc/config/zerotier</code>的配置文件，添加以下内容</p><p><code>option config_path '/etc/zerotier'</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openwrt系统内配置Frpc自启动</title>
    <link href="/p/99e48799.html"/>
    <url>/p/99e48799.html</url>
    
    <content type="html"><![CDATA[<hr /><blockquote><p>Frpc在Openwrt上的客户端多多少少有点问题，为了方便自己使用，在这里记录一下如果用命令行启动和编辑Frpc的流程</p></blockquote><ol><li><p>首先，在 <a href="https://github.com/fatedier/frp/releases/">fatedier/frp</a>中下载最新版的frp打包程序，以下以0.35.1版本为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz<br>tar -xvf frp_0.35.1_linux_amd64.tar.gz<br><span class="hljs-built_in">rm</span> frp_0.35.1_linux_amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>首先切换到frp的目录下，把frpc和配置文件放于service对应的目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> frp_0.35.1_linux_amd64<br>sudo <span class="hljs-built_in">mv</span> frpc /usr/bin<br>sudo <span class="hljs-built_in">chmod</span> 755 /usr/bin/frpc <br>sudo <span class="hljs-built_in">mkdir</span> /etc/frp<br>sudo <span class="hljs-built_in">mv</span> frpc.ini /etc/frp <br></code></pre></td></tr></table></figure></li><li><p>之后通过指令编辑frpc.ini</p><p><code>sudo vi /etc/frp/frpc.ini</code></p></li><li><p>之后，编辑/etc/init.d/frpc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh /etc/rc.common</span><br> <br> START=90<br> STOP=90<br> SERVICE=frpc<br> USE_PROCD=1<br> PROC=<span class="hljs-string">&quot;/usr/bin/frpc -c /etc/frp/frpc.ini&quot;</span><br> <br> <span class="hljs-function"><span class="hljs-title">start_service</span></span>()<br> <br> &#123;<br>     procd_open_instance<br>     procd_set_param <span class="hljs-built_in">command</span> <span class="hljs-variable">$PROC</span><br>     procd_set_param respawn<br>     procd_close_instance<br> <br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-title">service_triggers</span></span>()<br> &#123;<br>     procd_add_reload_trigger <span class="hljs-string">&quot;rpcd&quot;</span><br> &#125;<br></code></pre></td></tr></table></figure><blockquote><p>脚本来自<a href="https://juejin.cn/post/6844904014446854158">OpenWRT/LEDE下开机脚本</a></p></blockquote></li><li><p>配置文件就结束了之后只需要直接启用和启动frpc即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/init.d/frp start<br>/etc/init.d/frp <span class="hljs-built_in">enable</span> &amp;&amp; <span class="hljs-built_in">echo</span> on<br></code></pre></td></tr></table></figure></li><li><p>另外由于不需要配置frps服务，可以回到上级目录并把下载的文件全部删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">rm</span> -rf frp_0.35.1_linux_amd64<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展Ubuntu服务器内LVM分区容量引导</title>
    <link href="/p/2dda2597.html"/>
    <url>/p/2dda2597.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<a href="https://blog.csdn.net/Fly_1213/article/details/105142427">解决 Linux /dev/mapper/ubuntu–vg-ubuntu–lv 磁盘空间不足的问题</a></p></blockquote><ol><li><p>通过命令查看LVM卷组的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># vgdisplay</span><br>  --- Volume group ---<br>  VG Name               ubuntu-vg<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  2<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                1<br>  Open LV               1<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               &lt;930.01 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238082<br>  Alloc PE / Size       51200 / 200.00 GiB<br>  Free  PE / Size       186882 / &lt;730.01 GiB<br></code></pre></td></tr></table></figure></li><li><p>可以看到可扩容大小</p><p><code>Free PE / Size 186882 / &lt;730.01 GiB</code></p></li><li><p>使用命令进行扩容</p><p>按不同需求有以下命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">lvextend -L 10G /dev/mapper/ubuntu--vg-ubuntu--lv      //增大或减小至19G<br>lvextend -L +10G /dev/mapper/ubuntu--vg-ubuntu--lv     //增加10G<br>lvreduce -L -10G /dev/mapper/ubuntu--vg-ubuntu--lv     //减小10G<br>lvresize -l  +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv   //按百分比扩容<br><br>resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv            //执行调整<br></code></pre></td></tr></table></figure><p>具体操作:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># lvextend -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv</span><br>  Size of logical volume ubuntu-vg/ubuntu-lv changed from 200.00 GiB (51200 extents) to &lt;930.01 GiB (238082 extents).<br>  Logical volume ubuntu-vg/ubuntu-lv successfully resized.<br>root@azhal:/mnt/Ar2D<span class="hljs-comment"># resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span><br>resize2fs 1.45.5 (07-Jan-2020)<br>Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required<br>old_desc_blocks = 25, new_desc_blocks = 117<br>The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 243795968 (4k) blocks long.<br></code></pre></td></tr></table></figure></li><li><p>检查是否扩容成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">root@azhal:/mnt/Ar2D<span class="hljs-comment"># vgdisplay</span><br>  --- Volume group ---<br>  VG Name               ubuntu-vg<br>  System ID<br>  Format                lvm2<br>  Metadata Areas        1<br>  Metadata Sequence No  3<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                1<br>  Open LV               1<br>  Max PV                0<br>  Cur PV                1<br>  Act PV                1<br>  VG Size               &lt;930.01 GiB<br>  PE Size               4.00 MiB<br>  Total PE              238082<br>  Alloc PE / Size       238082 / &lt;930.01 GiB<br>  Free  PE / Size       0 / 0<br></code></pre></td></tr></table></figure><p>可以看到Free Size已经变成0，即扩容成功。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统中校验文件哈希值</title>
    <link href="/p/a9706dff.html"/>
    <url>/p/a9706dff.html</url>
    
    <content type="html"><![CDATA[<p>​    每次要查询一个文件的hash值的时候总要打开一个hash校验工具，觉得有些麻烦了，加上也不是所有文件都会经常需要校验，就常常并不想单独下载一个工具，查询到Windows有自带的hash校验指令，于是记录一下，以下内容摘自<a href="https://zhuanlan.zhihu.com/p/344545687">知乎</a></p><ol><li><p>使用certutil</p><blockquote><p>Windows从Win7开始，包含了一个CertUtil命令，可以通过这个命令来计算指定文件的杂凑值(Hash Value)</p></blockquote><p>使用的指令为:</p><p><code>certutil -hashfile [fileName] [algorithm]</code></p><p>其中<code>[algorithm]</code>指不同的hash算法，可以取的值有：<strong>MD2、MD4、MD5、SHA1、SHA256、SHA384、SHA512</strong>。</p><p>例子:</p><p><code>certutil -hashfile D:\test.txt MD5</code></p></li><li><p>使用Get-FileHash</p><p><code>Get-FileHash [fileName] -Algorithm [algorithm]</code></p><p>其中，支持的算法有<strong>MACTripleDES、MD5、RIPEMD160、SHA1、SHA256、SHA384、SHA512</strong>。</p><p>显示效果:</p><p><img src="https://lsky.halc.top/VSkKLK.png" alt="Hash_1" /></p><p>其中，为了方便观察可以通过管道使用Format-List</p><p><code>Get-FileHash .\test.txt -Algorithm SHA512 | Format-List</code></p><p>显示效果:</p><p><img src="https://lsky.halc.top/QFCdUM.png" alt="Hash_2" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建ZeroTier Controller管理网络引导</title>
    <link href="/p/41385a4a.html"/>
    <url>/p/41385a4a.html</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本来的理解</strong>: 在使用ZeroTier的时候经常会出现穿透失败，或者穿透延迟过大但是中转服务器不好用的情况，之前有参考过网上的教程来通过一台国内的VPS搭建自己的MOON节点来达到加速的目的，但是最后的效果不尽人意，而且还存在安卓端添加mood节点并不轻松的问题，所以在这里采取直接通过<a href="https://github.com/key-networks/ztncui">key-networks/ztncui: ZeroTier network controller UI</a>搭建自己的ZeroTier根服务器</p></blockquote><p>​    最近在使用<code>zerotier-cli listpeers</code>指令的时候发现设置的控制器是一个<code>LEAF</code>而不是本来预期的<code>PLANT</code>，在查阅了一部分资料之后发现如果想要加速网络的话目前比较好的方便还是<code>MOON</code>服务器进行中转，详情参考另外一篇<code>ZeroTier下Moon服务器的搭建</code>。</p><h2 id="安装准备"><a class="markdownIt-Anchor" href="#安装准备"></a> 安装准备</h2><ol><li><p>准备好一台在国内，至少开放端口3443端口的服务器（暂未测试对其他端口是否有需求）</p></li><li><p>在服务器内安装ZeroTier，以下为一键安装脚本</p><p><code>curl -s https://install.zerotier.com | sudo bash</code></p><p>如果服务器有安装GPG，则需要多几个步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s <span class="hljs-string">&#x27;https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg&#x27;</span> | gpg --import &amp;&amp; \<br><span class="hljs-keyword">if</span> z=$(curl -s <span class="hljs-string">&#x27;https://install.zerotier.com/&#x27;</span> | gpg); <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$z</span>&quot;</span> | sudo bash; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="部署ztncui"><a class="markdownIt-Anchor" href="#部署ztncui"></a> 部署ztncui</h2><h3 id="rpm-installation-on-el7"><a class="markdownIt-Anchor" href="#rpm-installation-on-el7"></a> RPM installation on EL7</h3><ol><li><p><code>sudo yum install https://download.key-networks.com/el7/ztncui/1/ztncui-release-1-1.noarch.rpm -y</code></p></li><li><p><code>sudo yum install ztncui -y</code></p></li><li><p>(可选择)：添加服务器自己的TLS/SSL证书，或者添加服务器自认证的证书 - <strong>后文有教程</strong></p></li><li><p>开放服务器的3443端口(已开放可忽略)</p></li><li><p><code>sudo sh -c &quot;echo 'HTTPS_PORT=3443' &gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo sh -c &quot;echo 'NODE_ENV=production' &gt;&gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo systemctl restart ztncui</code></p></li><li><p>通过HTTPS来在服务器的3443端口访问控制界面，比如</p><p><code>e.g. https://my.network.controller:3443</code></p></li><li><p>通过默认的账号<code>admin</code>和密码<code>password</code>.</p></li></ol><h3 id="deb-installation-on-debianubuntu"><a class="markdownIt-Anchor" href="#deb-installation-on-debianubuntu"></a> DEB installation on Debian/Ubuntu</h3><ol><li><p><code>curl -O https://s3-us-west-1.amazonaws.com/key-networks/deb/ztncui/1/x86_64/ztncui_0.7.1_amd64.deb</code></p></li><li><p><code>sudo apt-get install ./ztncui_0.7.1_amd64.deb</code></p></li><li><p>(可选择)：添加服务器自己的TLS/SSL证书，或者添加服务器自认证的证书 - <strong>后文有教程</strong></p></li><li><p>开放服务器的3443端口(已开放可忽略)</p></li><li><p><code>sudo sh -c &quot;echo 'HTTPS_PORT=3443' &gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo sh -c &quot;echo 'NODE_ENV=production' &gt;&gt; /opt/key-networks/ztncui/.env&quot;</code></p></li><li><p><code>sudo systemctl restart ztncui</code></p></li><li><p>通过HTTPS来在服务器的3443端口访问控制界面，比如</p><p><code>e.g. https://my.network.controller:3443</code></p></li><li><p>通过默认的账号<code>admin</code>和密码<code>password</code>.</p></li></ol><h2 id="笔记"><a class="markdownIt-Anchor" href="#笔记"></a> 笔记</h2><ol><li><p>如果要添加额外的监听端口，只需要在<code>/opt/key-network/ztncui</code>下面添加一个<code>.env</code>文件，其中附带一行</p><p><code>HTTPS_PORT=3443</code></p><p>或者任意一个大于1024的端口即可。</p></li><li><p>如果存在<code>.env</code>文件来指向特定的一个端口，那么ztncui将会在所有的端口监听网络，如果希望限制一个特定的IP进行监听的话，只需要在<code>.env</code>文件中再添加一行</p><p><code>HTTPS_HOST=12.34.56.78</code></p><p>来设置自己制定的IP或者域名即可。</p></li></ol><h2 id="添加self-signed-certificate"><a class="markdownIt-Anchor" href="#添加self-signed-certificate"></a> 添加Self-signed Certificate</h2><blockquote><p>这种方法添加的证书会存在浏览器警告的问题，不过由于是自己使用，平时也不会一直盯着控制界面，所以影响应该不会很大，如果有共用或者对安全有需求建议自行添加</p></blockquote><p>以下为无脑脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -i<br><span class="hljs-built_in">cd</span> /opt/key-networks/ztncui/etc/tls<br><span class="hljs-built_in">rm</span> -f privkey.pem fullchain.pem<br>openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privkey.pem -out fullchain.pem<br><span class="hljs-built_in">chown</span> ztncui.ztncui *.pem<br><span class="hljs-built_in">chmod</span> 600 privkey.pem<br></code></pre></td></tr></table></figure><h2 id="配置ztnui"><a class="markdownIt-Anchor" href="#配置ztnui"></a> 配置ztnui</h2><p>由于ztnui是自己搭建的一个ZeroTier服务器，所以并没有预先设置好的DHCP分配，需要自己设置分配范围。如果需要添加一个新的网络，在使用账号密码登入以后，点击<code>Add network</code>就可以添加一个自己的虚拟局域网络</p><ol><li><p>点击Add network</p></li><li><p>设置好network的名字并create</p></li><li><p>如果需要设置&quot;隐私&quot;与否，在Private中设置即可，这里稍作翻译即可看懂，所以不多解释</p></li><li><p>点击如下图所示的Easy Setup来快速完成一个IPv4的DHCP分配</p><p><img src="https://lsky.halc.top/kvEZFd.png" alt="ESETUP" /></p></li><li><p>如下图所示填入对应信息</p><p><img src="https://lsky.halc.top/LhjtZx.png" alt="IPPOOL" /></p><p>以下为一个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">网关:192.168.192.0/24<br>起始IP:192.168.192.1<br>终止IP:192.168.192.254<br></code></pre></td></tr></table></figure></li><li><p>然后点submit即可快速创建，也可以通过generate network address的方式自动随机填入。</p></li><li><p>如果需要设置NAT路由，则只需要在Routes下进行配置和添加即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Devc++调试相关选项配置</title>
    <link href="/p/c9774a05.html"/>
    <url>/p/c9774a05.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于蓝桥杯比赛需要使用Devc<ins>作为IDE工具，平时用习惯了vscode的snap和其他功能以后觉得如果不提前适应一下Devc</ins>的编译环境的话在比赛的时候会吃很大的亏，于是决定之后的学习都用Devc<ins>进行，在此记录一下Devc</ins>启用调试之前需要的一些基本设置</p></blockquote><h2 id="启用调试信息选做"><a class="markdownIt-Anchor" href="#启用调试信息选做"></a> 启用调试信息(选做)</h2><blockquote><p>貌似在按F5准备进行调试的时候，即使自己没有进行以下设置，Devc++依旧会询问并且可以直接打开进行设置，这里只做一个提前设置的记录，并非必须</p></blockquote><ol><li><p>首先，打开devc++之后，找到上方的Tools(工具)，如下图所示，打开其中的Compiler options(编译选项)</p><p><img src="https://lsky.halc.top/khFnOI.png" alt="工具" /></p></li><li><p>然后按下图开启调试信息（设置为yes）</p><p><img src="https://lsky.halc.top/Dy3AFE.png" alt="调试信息" /></p></li></ol><h2 id="显示鼠标所指变量"><a class="markdownIt-Anchor" href="#显示鼠标所指变量"></a> 显示鼠标所指变量</h2><ol><li><p>再次打开Tools，并且打开Enviroment options</p></li><li><p>启用下图黄线部分的选项，开启显示指针所指变量的值</p><p><img src="https://lsky.halc.top/lAqdhj.png" alt="指针调试" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Devc++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下创建拥有sudo权限的用户</title>
    <link href="/p/9232cf7b.html"/>
    <url>/p/9232cf7b.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>添加用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo adduser username<br></code></pre></td></tr></table></figure></li><li><p>添加sudo权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">表示将username追加到sudo权限组当中</span><br>sudo usermod -aG sudo username<br></code></pre></td></tr></table></figure></li><li><p>检查是否拥有<code>sudo</code>权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新ubuntu软件源</span><br>sudo apt update<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动在服务器上安装Frp</title>
    <link href="/p/1d3a895d.html"/>
    <url>/p/1d3a895d.html</url>
    
    <content type="html"><![CDATA[<hr /><ol><li><p>首先，在 <a href="https://github.com/fatedier/frp/releases/">fatedier/frp</a>中下载最新版的frp打包程序，以下以0.35.1版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://github.com/fatedier/frp/releases/download/v0.35.1/frp_0.35.1_linux_amd64.tar.gz<br>tar -xvf frp_0.35.1_linux_amd64.tar.gz<br><span class="hljs-built_in">rm</span> frp_0.35.1_linux_amd64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>首先切换到frp的目录下，把frpc和配置文件放于service对应的目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> frp_0.35.1_linux_amd64<br>sudo <span class="hljs-built_in">mv</span> frpc /usr/bin<br>sudo <span class="hljs-built_in">chmod</span> 755 /usr/bin/frpc <br>sudo <span class="hljs-built_in">mkdir</span> /etc/frp<br>sudo <span class="hljs-built_in">mv</span> frpc.ini /etc/frp <br></code></pre></td></tr></table></figure></li><li><p>之后通过指令编辑frpc.ini</p><p><code>sudo vi /etc/frp/frpc.ini</code></p></li><li><p>之后，切换到services的目录下，将frpc.service移动到系统的systemctl进程守护下，并启用权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ./systemd<br>sudo <span class="hljs-built_in">mv</span> frpc.service /usr/lib/systemd/system<br>sudo <span class="hljs-built_in">chmod</span> 644 /usr/lib/systemd/system/frpc.service<br>sudo <span class="hljs-built_in">mv</span> frpc@.service /usr/lib/systemd/system<br>sudo <span class="hljs-built_in">chmod</span> 644 /usr/lib/systemd/system/frpc@.service<br></code></pre></td></tr></table></figure></li><li><p>配置文件就结束了之后只需要直接启用和启动frpc即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl <span class="hljs-built_in">enable</span> frpc<br>sudo systemctl start frpc<br></code></pre></td></tr></table></figure></li><li><p>另外由于不需要配置frps服务，可以回到上级目录并把下载的文件全部删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">rm</span> -rf frp_0.35.1_linux_amd64<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>对于Frps的安装，可以使用该仓库下的一键安装脚本进行配置：<a href="https://github.com/MvsCode/frps-onekey">frps-onekey</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>安装引导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu禁用系统休眠</title>
    <link href="/p/dea4f344.html"/>
    <url>/p/dea4f344.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>由于用笔记本做服务器的时候并不需要屏幕显示，并且屏幕显示会带来多余的耗电，于是就想试着把笔记本屏幕关上的同时能让Ubuntu Server正常运行，而不是进入休眠模式，索性在网上查阅资料以后发现并不是很困难，以此在这里记录需要修改的操作以便以后查阅</p><ol><li><p>修改logind.conf文件</p><p><code>sudo vim /etc/systemd/logind.conf</code></p></li><li><p>修改logind.conf中的选项，使得笔记本忽略关闭屏幕对系统的影响</p><p>将原本的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#HandleLidSwitch=suspend</span><br><span class="hljs-comment">#HandleLidSwitchExternalPower=suspend</span><br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HandleLidSwitch=ignore</span><br><span class="hljs-string">HandleLidSwitchExternalPower=ignore</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>reboot</code>指令来重启电脑即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修复Vim的光标兼容问题</title>
    <link href="/p/15b28479.html"/>
    <url>/p/15b28479.html</url>
    
    <content type="html"><![CDATA[<hr /><blockquote><p>参考:</p><ol><li><a href="https://blog.csdn.net/wr132/article/details/53769257">Ubuntu的Vi/Vim编辑器的方向键变成ABCD问题_colorfulshark-CSDN博客</a></li><li><a href="http://edyfox.codecarver.org/html/_vimrc_for_beginners.html">Vim入门基本设置</a></li></ol></blockquote><p>在终端输入如下指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set nocp&quot;</span> &gt;&gt; ~/.vimrc<br><span class="hljs-built_in">source</span> ~/.vimrc<br></code></pre></td></tr></table></figure><blockquote><p>出现问题的原因：</p><p>set nocp</p><p>该命令指定让 VIM 工作在不兼容模式下。在 VIM 之前，出现过一个非常流行的编辑器叫 vi。VIM 许多操作与 vi 很相似，但也有许多操作与 vi 是不一样的。如果使用“:set cp”命令打开了兼容模式开关的话，VIM 将尽可能地模仿 vi 的操作模式。</p><p>也许有许多人喜欢“最正统的 vi”的操作模式，对于初学者来说，vi 里许多操作是比较不方便的。</p><p>举一个例子，VIM 里允许在 Insert 模式下使用方向键移动光标，而 vi 里在 Insert 模式下是不能移动光标的，必须使用 ESC 退回到 Normal 模式下才行。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本语法记录笔记</title>
    <link href="/p/20c326f2.html"/>
    <url>/p/20c326f2.html</url>
    
    <content type="html"><![CDATA[<hr /><p>​        通过使用Github Pages + jekyll 的方法也算是搭建了自己的第一篇博客，由于之后post主要都以markdown的文章发布，所以第一篇blog就留给markdown的语法了。</p><p>​        本篇文章参考自<a href="https://www.jianshu.com/p/191d1e21f7ed">Markdown基本语法 - 简书 (jianshu.com)</a>，在学习之后做一个汇总，以便自己后续查看和回忆。</p><hr /><h2 id="一-标题"><a class="markdownIt-Anchor" href="#一-标题"></a> 一、标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 这是一级标题,也就是字最大的</span><br><span class="hljs-section">## 这是二级标题</span><br><span class="hljs-section">### 这是三级标题</span><br><span class="hljs-section">#### 这是四级标题</span><br><span class="hljs-section">##### 这是五级标题</span><br><span class="hljs-section">###### 这是六级标题</span><br></code></pre></td></tr></table></figure><p>其中，不同的效果如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br><br><span class="hljs-section">## 一级标题</span><br><br><span class="hljs-section">## 二级标题</span><br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题</span><br><br><span class="hljs-section">##### 五级标题</span><br><br><span class="hljs-section">###### 六级标题</span><br><br>---<br><br><span class="hljs-section">## 二、字体</span><br><br>字体总共有四种排布:<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**加粗**</span><br><br>  <span class="hljs-code">`**这里是要加粗的字体**`</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-emphasis">*斜体*</span><br><br>  <span class="hljs-code">``*这里是要倾斜的字体*`</span>`<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗*</span>**</span>  ~~(就是粗体+斜体啦)~~<br><br>  <span class="hljs-code">``***这里是要斜体并且加粗的字体***`</span>`<br><br><span class="hljs-bullet">-</span> ~~删除线~~<br><br>  <span class="hljs-code">``~~这里是要打删除线的字体~~`</span>`<br><br><span class="hljs-section">## 三、引用</span><br><br>通过使用引用，可以较为美观的引用别人的内容。<br><br>使用示例:<br><br><span class="hljs-code">```markdown</span><br><span class="hljs-code">&gt; 引用</span><br><span class="hljs-code">&gt;&gt; 引用的引用</span><br><span class="hljs-code">&gt;&gt;&gt; 引用的引用的引用</span><br></code></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><p>引用的引用</p><blockquote><p>引用的引用的引用</p></blockquote></blockquote></blockquote><h2 id="四-分割线"><a class="markdownIt-Anchor" href="#四-分割线"></a> 四、分割线</h2><p>分割线有两种实现方式，只要三个，或者三个以上的 ‘-’ 或者 ‘*’ 就可以达到目的，以下为示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">---</span><br>----<br><span class="hljs-strong">***</span><br><span class="hljs-strong">**</span><span class="hljs-strong">**</span><br></code></pre></td></tr></table></figure><p>效果如下</p><h2 id="-markdownlint-disable-md035-"><a class="markdownIt-Anchor" href="#-markdownlint-disable-md035-"></a> <!-- markdownlint-disable MD035--></h2><hr /><hr /><hr /><h2 id="五-图片"><a class="markdownIt-Anchor" href="#五-图片"></a> 五、图片</h2><p>Markdown中的图片分为三个部分，分别是“图片介绍”，“图床地址”和“图片信息title”</p><ul><li>图片介绍是在图片如果加载失败的时候，将会显示的文字内容</li><li>图床地址用于填写图片存放的位置</li><li>图片信息显示的title，为鼠标移动到图片上面的时候显示的小字内容(可有可无)</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片介绍</span>](<span class="hljs-link">图片url &quot;图片信息显示&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下为一个示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">背景</span>](<span class="hljs-link">https://lsky.halc.top/LY53bA.jpg</span>)<br></code></pre></td></tr></table></figure><p>示例:   <img src="https://lsky.halc.top/LY53bA.jpg" alt="背景" /></p><hr /><h2 id="六-超链接"><a class="markdownIt-Anchor" href="#六-超链接"></a> 六、超链接</h2><p>超链接的语法和图片的语法很像，唯一的区别就是前面是否有那个感叹号，示例如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">超链接的内容</span>](<span class="hljs-link">超链接地址 &quot;超链接的title&quot;</span>)<br>[<span class="hljs-string">百度</span>](<span class="hljs-link">http://baidu.com</span>)<br></code></pre></td></tr></table></figure><p><a href="http://baidu.com">百度</a></p><p><a href="https://halc.top">HalcyonAzure的Blog</a></p><p>其中Markdown本身的语法目前并不支持超链接打开，需要使用html语言进行修改，由于目前暂时并未学习html有关内容，所以这部分内容直接引用<a href="https://www.jianshu.com/p/191d1e21f7ed">简书</a>中的内容，暂时不研究。</p><blockquote><blockquote><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;超链接地址&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>超链接名<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>示例<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>简书<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="七-代码"><a class="markdownIt-Anchor" href="#七-代码"></a> 七、代码</h2><p>直接贴语法：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">`单行代码内容`<br><br>​```<br>多行代码内容<br>​```<br></code></pre></td></tr></table></figure><p>示例的话上面的很多内容都采用了代码块的方法，所以就不多做展示了</p><h3 id="代码折叠"><a class="markdownIt-Anchor" href="#代码折叠"></a> 代码折叠</h3><p>记录一个实现代码折叠的小技巧</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span></span>bottom<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span></span><br><span class="hljs-code">`code here`</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>效果</p><details><summary>bottom</summary>`code here`</details><h2 id="八-列表"><a class="markdownIt-Anchor" href="#八-列表"></a> 八、列表</h2><h2 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h2><p>语法：无序列表使用’-/+/*'的任意一种符号都可以达到效果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 内容<br><span class="hljs-bullet">+</span> 内容<br><span class="hljs-bullet">*</span> 内容<br></code></pre></td></tr></table></figure><p>显示效果:</p><!-- markdownlint-disable MD004--><ul><li>内容</li></ul><ul><li>内容</li></ul><ul><li>内容</li></ul><p>如果需要列表嵌套，只需要在回车后重复输入列表(快捷键Tab)即可，示例如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 内容<br><span class="hljs-bullet">    -</span> 内容1<br><span class="hljs-bullet">    -</span> 内容2<br></code></pre></td></tr></table></figure><ul><li>内容<ul><li>内容1</li><li>内容2</li></ul></li></ul><p>Ps: 在使用Typora编辑列表的时候，如果下一行不再需要列表，只需要通过方向键直接移动光标到下一行即可，如果使用回车来换行的话只会进行列表嵌套的操作</p><h2 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h2><p>通过从无序列表进行引申，可以得到有序列表的语法内容:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 内容1<br><span class="hljs-bullet">2.</span> 内容2<br></code></pre></td></tr></table></figure><p>示例:</p><ol><li>内容1</li><li>内容2</li></ol><h2 id="表格和流程图"><a class="markdownIt-Anchor" href="#表格和流程图"></a> 表格和流程图</h2><p>由于这两部分内容目前还没有遇到使用需求，所以这里同样引用简书内的介绍，等真正有需要和使用的时候再返回这条Blog进行更新和整理</p><blockquote><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;表头|<span class="hljs-params">表头</span>|表头<br>&gt;---|<span class="hljs-params">:--:</span>|---:<br>&gt;内容|<span class="hljs-params">内容</span>|内容<br>&gt;内容|<span class="hljs-params">内容</span>|内容<br><br>&gt;第二行分割表头和内容。<br>&gt;- 有一个就行，为了对齐，多加了几个<br>&gt;文字默认居左<br>&gt;-两边加：表示文字居中<br>&gt;-右边加：表示文字居右<br>&gt;注：原生的语法两边都要用 |<span class="hljs-params"> 包起来。此处省略</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&gt;姓名|<span class="hljs-params">技能</span>|排行<br>&gt;--|<span class="hljs-params">:--:</span>|--:<br>&gt;刘备|<span class="hljs-params">哭</span>|大哥<br>&gt;关羽|<span class="hljs-params">打</span>|二哥<br>&gt;张飞|<span class="hljs-params">骂</span>|三弟<br></code></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th style="text-align:center">技能</th><th style="text-align:right">排行</th></tr></thead><tbody><tr><td>刘备</td><td style="text-align:center">哭</td><td style="text-align:right">大哥</td></tr><tr><td>关羽</td><td style="text-align:center">打</td><td style="text-align:right">二哥</td></tr><tr><td>张飞</td><td style="text-align:center">骂</td><td style="text-align:right">三弟</td></tr></tbody></table><h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2><p>出于Blog的排版问题，只有一个示例</p><pre class="highlight"><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```~~~</code></pre></blockquote><p><s>第一篇Blog就是把别人的东西抄了一遍.jpg</s></p>]]></content>
    
    
    <categories>
      
      <category>知识记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
