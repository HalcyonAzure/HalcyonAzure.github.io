<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-pic.png"><link rel="icon" href="/img/favicon-pic.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="HalcyonAzure"><meta name="keywords" content=""><meta name="description" content="参考文章  Bryan Ford’s Home Page (bford.info)   P2P的特点 在当前互联网的结构模式下，大部分的数据通信和交互都是以C&#x2F;S结构进行通信，即一个客户端和一个中心服务器，客户端通过将数据交给服务器，再有服务器将数据进行适当的处理后与客户端进行交互。除了C&#x2F;S，还有一种常见的结构，即P2P通信。在P2P网络下，主要的通信双方为“节点”，节点和节点之间的通信是直达"><meta property="og:type" content="article"><meta property="og:title" content="原理分析：UDP和TCP在NAT环境下的P2P打洞实现"><meta property="og:url" content="https://halc.top/p/bb3a9deb"><meta property="og:site_name" content="Halcyon Zone"><meta property="og:description" content="参考文章  Bryan Ford’s Home Page (bford.info)   P2P的特点 在当前互联网的结构模式下，大部分的数据通信和交互都是以C&#x2F;S结构进行通信，即一个客户端和一个中心服务器，客户端通过将数据交给服务器，再有服务器将数据进行适当的处理后与客户端进行交互。除了C&#x2F;S，还有一种常见的结构，即P2P通信。在P2P网络下，主要的通信双方为“节点”，节点和节点之间的通信是直达"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lsky.halc.top/Gt6JKG.png"><meta property="og:image" content="https://lsky.halc.top/KZN0EJ.png"><meta property="og:image" content="https://lsky.halc.top/4nATYZ.png"><meta property="og:image" content="https://lsky.halc.top/GPPOFe.png"><meta property="og:image" content="https://lsky.halc.top/glofU4.png"><meta property="og:image" content="https://lsky.halc.top/f9rV8M.png"><meta property="og:image" content="https://lsky.halc.top/oHhxGK.png"><meta property="og:image" content="https://lsky.halc.top/cd4KWj.png"><meta property="article:published_time" content="2024-01-31T09:36:55.000Z"><meta property="article:modified_time" content="2024-02-21T07:07:09.000Z"><meta property="article:author" content="HalcyonAzure"><meta property="article:tag" content="DNS"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://lsky.halc.top/Gt6JKG.png"><meta name="referrer" content="no-referrer-when-downgrade"><script async src="https://umami.azsyc.com/script.js" data-website-id="ab8bb282-3900-4ec9-a4dd-6076b4af581c"></script><title>原理分析：UDP和TCP在NAT环境下的P2P打洞实现 - Halcyon Zone</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/round.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"halc.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"c4f509f89fec4843f255dfb1ae66ca2b",google:null,tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!0},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null},gtag:null,woyaola:null,cnzz:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c4f509f89fec4843f255dfb1ae66ca2b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Halcyon Zone" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Halcyon</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="原理分析：UDP和TCP在NAT环境下的P2P打洞实现"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-01-31 17:36" pubdate>2024年1月31日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>38 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">原理分析：UDP和TCP在NAT环境下的P2P打洞实现</h1><p id="updated-time" class="note note-info">本文最后更新于：2024年2月21日 下午</p><div class="markdown-body"><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a target="_blank" rel="noopener" href="https://bford.info/pub/net/p2pnat/index.html">Bryan Ford’s Home Page (bford.info)</a></li></ul><h1 id="p2p的特点"><a class="markdownIt-Anchor" href="#p2p的特点"></a> P2P的特点</h1><p>在当前互联网的结构模式下，大部分的数据通信和交互都是以C/S结构进行通信，即一个客户端和一个中心服务器，客户端通过将数据交给服务器，再有服务器将数据进行适当的处理后与客户端进行交互。除了C/S，还有一种常见的结构，即P2P通信。在P2P网络下，主要的通信双方为“节点”，节点和节点之间的通信是直达的，不需要中心服务器对信息进行处理。</p><p>由于这篇博客本身的目的并不是非要在C/S和P2P中抉择出一个好坏，重点主要放在P2P的技术实现上，就不做优劣对比了。P2P网络本质上是一种去中心化的网络结构，每个节点都直接与其他节点交互，共享节点和节点之间的资源与服务。这种结构相对来说可以更有效的利用资源，提高传输效率和可靠性（打洞成功的情况下）。</p><p>但是既然有这么多好处，那么必然也有相对应的挑战：P2P网络最核心的本质还是需要节点和节点能够直接通信。但是在当前国内的网络环境下，大部分的家庭用户并没有一个自己的公网IP。很多时候想实现节点和节点的直接通信，我们都需要想一个办法跨过防火墙，来让两个节点能够“握手”并“通信”，而这个过程便称为“打洞”。</p><h1 id="nat的通信方式"><a class="markdownIt-Anchor" href="#nat的通信方式"></a> NAT的通信方式</h1><p><img src="https://lsky.halc.top/Gt6JKG.png" srcset="/img/loading.gif" lazyload alt="NAT通信流程图"></p><ol><li><strong>内网请求</strong>：用户设备（内网IP地址为192.168.1.10）通过端口5000发起对外部服务器的请求。</li><li><strong>地址转换</strong>：路由器接收到来自内网用户的请求后，使用NAT机制将源地址从内网IP转换为路由器的公网IP地址（203.0.113.45），同时，源端口从5000更改为1024。NAT通过这一端口映射的过程，来维护外网和内网设备的通信。</li><li><strong>请求转发</strong>：经过地址转换后，路由器将修改后的请求通过互联网转发至目标服务器（IP地址为51.68.141.240）的80端口。s</li><li><strong>服务器响应</strong>：服务器接收到请求后，对该请求进行处理，并通过相同的端口（80）向互联网发送响应数据。</li><li><strong>响应数据路由</strong>：互联网将服务器的响应数据发回路由器的公网IP地址（203.0.113.45）的1024端口。</li><li><strong>反向地址转换</strong>：路由器接收到响应数据后，再次使用NAT机制，将响应数据包的目标地址从路由器的“公网IP地址（203.0.113.45）：端口（1024）”映射回用户的”内网IP地址（192.168.1.10）和端口5000“。</li><li><strong>内网传递响应</strong>：最后，路由器将响应数据发送回内网用户，完成整个通信过程。</li></ol><h1 id="udp的打洞过程"><a class="markdownIt-Anchor" href="#udp的打洞过程"></a> UDP的打洞过程</h1><h2 id="建立点对点会话连接"><a class="markdownIt-Anchor" href="#建立点对点会话连接"></a> 建立点对点会话连接</h2><p><img src="https://lsky.halc.top/KZN0EJ.png" srcset="/img/loading.gif" lazyload alt="image-20240130172638076"></p><ol><li><strong>注册与穿透服务器</strong>：两个客户端A和B分别与穿透服务器S建立UDP会话。在此过程中，服务器S记录每个客户端的两个<code>Endpoint</code>：客户端自认为用来与S通信的内网<code>Endpoint</code>对，以及服务器观察到的客户端用来进行通信的公网<code>Endpoint</code>。</li><li><strong><code>Endpoint</code>信息的记录与交换</strong>：服务器S将从客户端收到的注册消息中提取内网<code>Endpoint</code>信息，并从IP和UDP头部提取公网<code>Endpoint</code>信息。如果客户端不在NAT后面，这两个<code>Endpoint</code>应该是相同的。</li><li><strong>发起UDP打洞请求</strong>：假设客户端A想要直接与客户端B建立UDP会话。A首先不知道如何到达B，因此A请求S帮助建立与B的UDP会话。</li><li><strong>服务器响应</strong>：S回复A，包含B的公网和内网<code>Endpoint</code>信息。同时，S使用其与B的UDP会话向B发送包含A的公网和内网<code>Endpoint</code>的连接请求消息。收到这些消息后，A和B知道了对方的公网和内网<code>Endpoint</code>。</li><li><strong>双向打洞</strong>：A收到B的公网和内网<code>Endpoint</code>后，开始向这两个<code>Endpoint</code>发送UDP数据包，并锁定首先从B处获得有效响应的<code>Endpoint</code>。类似地，B在收到转发的连接请求后，开始向A的已知<code>Endpoint</code>发送UDP数据包，锁定第一个有效的<code>Endpoint</code>并以此通讯。由于A和B相互发送数据包的操作本身是异步的，因此A和B发送数据包的前后顺序并没有严格要求。</li></ol><h2 id="不同nat下打洞的过程"><a class="markdownIt-Anchor" href="#不同nat下打洞的过程"></a> 不同NAT下打洞的过程</h2><h3 id="客户端a和b都在同一个nat后"><a class="markdownIt-Anchor" href="#客户端a和b都在同一个nat后"></a> 客户端A和B都在同一个NAT后</h3><p><img src="https://lsky.halc.top/4nATYZ.png" srcset="/img/loading.gif" lazyload alt="image-20240131145913368"></p><ol><li><p><strong>建立会话</strong>：客户端A与服务器S建立UDP会话，NAT分配公网端口62000。</p></li><li><p><strong>端口分配</strong>：客户端B也与服务器S建立UDP会话，NAT为其分配公网端口62005。</p></li><li><p><strong>连接请求</strong>：客户端A请求使用打洞技术与客户端B建立通信，并通过服务器S作为介绍人。</p></li><li><p><strong>交换Endpoint信息</strong>：服务器S向客户端A发送客户端B的公网和内网Endpoint信息，并将客户端A的信息转发给客户端B。</p></li><li><p><strong>尝试直接通信</strong>：客户端A和B尝试向彼此的公网和内网Endpoint发送UDP数据包。</p></li><li><p><strong>选择通信路径</strong>：根据NAT的支持情况，客户端可能通过NAT（支持Hairpin转译）或直接（不支持Hairpin转译）进行通信。</p><blockquote><p><strong>Hairpin转译</strong>：</p><p>Hairpin是NAT中的一种转译技术，其主要实现了让NAT后的两台设备都可以通过公网的IP和端口进行直接通信，具体的效果如下</p><ol><li><strong>客户端A发送数据</strong>：假设客户端A想要发送数据到客户端B。首先，客户端A会将数据包发送到NAT设备，目标是客户端B的公网Endpoint（例如155.99.25.11:62005）。</li><li><strong>NAT设备处理</strong>：NAT设备接收到来自客户端A的数据包，并查看目标地址。这里涉及Hairpin转译，因为数据包的源地址和目标地址都是由NAT设备分配的公网地址。</li><li><strong>Hairpin转译动作</strong>：如果NAT设备支持Hairpin NAT，它会识别出虽然目标地址是公网地址，但实际上目的地是内网中的另一个客户端。NAT设备将会将数据包的目标地址从B的公网Endpoint转换为B的内网IP地址（10.1.1.3），同时可能还会更改源地址从A的公网Endpoint到A的内网IP地址（10.0.0.1）。</li><li><strong>数据包转发给客户端B</strong>：完成地址转换后，NAT设备将数据包转发到客户端B的内网地址上。此时，数据包好像是从客户端A直接发送给客户端B而不是经过互联网，即使它们实际上是通过NAT设备的公网地址进行通信的。</li><li><strong>客户端B接收数据</strong>：客户端B收到了来自客户端A的数据包，尽管这些数据包最初是发送到NAT设备的公网地址的。</li></ol><p>在P2P通信中，由于内网Endpoint比公网的Endpoint要更早到达客户端B，也就是说Hairpin转译的通信流程还没走完，客户端A通过内网Endpoint和B建立的通信就完成了。因此在实际的通信中，由于内网路由通常比经过NAT的路由更快，客户端A和B更倾向于使用内网Endpoint进行后续的常规通信。</p></blockquote></li></ol><h3 id="客户端a和b在不同nat后"><a class="markdownIt-Anchor" href="#客户端a和b在不同nat后"></a> 客户端A和B在不同NAT后</h3><p><img src="https://lsky.halc.top/GPPOFe.png" srcset="/img/loading.gif" lazyload alt="不同NAT后打洞的原理"></p><ol><li><strong>会话初始化</strong>：客户端A和B分别从它们的本地端口4321发起到服务器S的1234端口的UDP通信会话。</li><li><strong>端口映射</strong>：NAT A为客户端A分配公网端口62000，而NAT B为客户端B分配公网端口31000。</li><li><strong>注册与记录</strong>：A和B向服务器S注册它们的内网和公网Endpoint。</li><li><strong>请求协助</strong>：客户端A请求服务器S帮助与客户端B建立连接。</li><li><strong>Endpoint交换</strong>：服务器S向两个客户端交换彼此的公网和内网Endpoint信息。</li><li><strong>尝试直连</strong>：A和B尝试直接向彼此的公网和内网Endpoint发送UDP数据包。</li><li><strong>NAT行为</strong>：如果NAT A和NAT B表现良好，它们将保留公网到内网的映射，为P2P通信“打洞”。</li><li><strong>通信验证</strong>：一旦客户端验证了公网Endpoint的可用性，且因为在两个不同的NAT后，内网Endpoint不可达，它们将停止向内网Endpoint发送消息，只用公网Endpoint通信。</li></ol><h3 id="客户端a和b在多层nat后"><a class="markdownIt-Anchor" href="#客户端a和b在多层nat后"></a> 客户端A和B在多层NAT后</h3><p><img src="https://lsky.halc.top/glofU4.png" srcset="/img/loading.gif" lazyload alt="多层NAT下打洞的原理"></p><ol><li><strong>客户端发起连接</strong> - 客户端A和B分别从它们的内网地址发起到服务器S的UDP连接。</li><li><strong>NAT A和B映射</strong> - NAT A和NAT B各自为客户端A和B创建了公网到内网的地址映射。</li><li><strong>NAT C建立映射</strong> - 在ISP级别的NAT C为两个会话建立了公网到内网的地址映射。</li><li><strong>尝试建立P2P连接</strong> - 客户端A和B尝试通过UDP打洞技术建立直接的P2P连接。</li><li><strong>NAT C的Hairpin转译</strong> - 如果NAT C支持Hairpin转译，它会处理从A到B和从B到A的数据包。</li><li><strong>数据包路由</strong> - NAT C将数据包正确地路由到另一端的客户端。</li><li><strong>数据包到达目的地</strong> - 经过NAT的转译，数据包成功到达对方客户端。</li></ol><p>当NAT不支持Hairpin转发的时候就无能为力了，目前Hairpin的普及度也需要打一个问号。也存在一些特殊的NAT结构，让P2P的成功率更加没有保证。如果希望P2P打洞的成功率变高，则需要整个互联网都推动这一块的发展。</p><h2 id="打洞成功后的空闲超时机制"><a class="markdownIt-Anchor" href="#打洞成功后的空闲超时机制"></a> 打洞成功后的空闲超时机制</h2><p>即使在通过上述的几种不同的方法打洞成功，这种方法打出的隧道也并不是可以一直可靠的。大部分的NAT内部都有一个维护UDP转换信息的计时器：如果在一段时间内某个端口上不再有数据通信，那么这个隧道就会因为空闲超时被关闭掉。</p><h3 id="维持隧道连接"><a class="markdownIt-Anchor" href="#维持隧道连接"></a> 维持隧道连接</h3><p>如果希望P2P的隧道能不受NAT网关的时间限制，就需要通过发送持续的心跳包来维持这个隧道的活跃状态。</p><p>除了心跳包的方法，当然也可以在双方长时间没有数据往来的时候将当前的隧道关闭，并在下一次需要通信的时候建立连接。通过这样的方式避免不必要的流量浪费。</p><h1 id="使用tcp实现p2p打洞"><a class="markdownIt-Anchor" href="#使用tcp实现p2p打洞"></a> 使用TCP实现P2P打洞</h1><p>与UDP协议相比，使用TCP实现P2P打洞最大的问题并不在于TCP诸如三次握手等协议层的问题。相比之下，由于TCP拥有诸如<code>SYN_SENT</code>和<code>ESTABLISHED</code>这种状态描述来记录一个会话的具体生命周期，使用TCP进行P2P要比使用UDP更加健壮一些。缺点是由于TCP的打洞目前还未推广开来，因此支持TCP打洞的设备并不多。</p><h2 id="sockets与tcp端口的复用"><a class="markdownIt-Anchor" href="#sockets与tcp端口的复用"></a> Sockets与TCP端口的复用</h2><p>在操作系统的通信API当中，如果要使用<code>Socket</code>建立<code>TCP</code>的连接，可以使用<code>connect()</code>方法来发送一个请求；或使用<code>listen()</code>和<code>accept()</code>来监听一个请求。但是相比UDP，正常情况下TCP要求一个端口仅能绑定一个<code>Socket</code>通信。如果想要绑定第二个的话则会失败。</p><p>如果我们需要实现一个TCP的打洞，我们需要有一个端口，可以在监听请求的同时对外发送请求。为了实现这一点，我们需要使用操作系统中的一种特殊的<code>Socket</code>：通过在<code>TCP Socket</code>携带<code>SO_REUSEADDR</code>这个特殊的关键字，我们就可以实现复用一个TCP端口，绑定多个<code>Sockets</code>。但这么做也是有限制的：所有绑定在这个端口上的<code>Socket</code>请求，都必须要携带<code>SO_REUSEADDR</code>这个关键字。</p><blockquote><p>在类似BSD的系统中，除了针对端口的绑定，还有<code>SO_REUSEPORT</code>这个关键字，用于区分具体是复用端口还是复用地址。这个时候就需要将两个参数同时设置才能生效。</p></blockquote><h2 id="建立tcp的p2p数据流"><a class="markdownIt-Anchor" href="#建立tcp的p2p数据流"></a> 建立TCP的P2P数据流</h2><p>其实TCP打洞的过程和UDP的打洞过程本质并没有很大区别。都是通过握手服务器获取到了对方的 Endpoint 信息后，同时尝试对内网和公网的地址进行访问。</p><p><img src="https://lsky.halc.top/f9rV8M.png" srcset="/img/loading.gif" lazyload alt="TCP打洞的实现"></p><p>正如上面介绍<code>Sockets</code>之于TCP的端口复用中提到的：在TCP协议中，开发者需要维护多个<code>Socket</code>，分别来处理监听和信息的发送；而对于UDP来说，只需要维护一个<code>Socket</code>，就可以实现客户端和客户端之间的信息交互。</p><h2 id="tcp连接的握手过程"><a class="markdownIt-Anchor" href="#tcp连接的握手过程"></a> TCP连接的握手过程</h2><p>在TCP打洞技术中，客户端应用程序根据操作系统的不同，可能观察到两种不同的行为。这两种行为反映了不同TCP实现对同步包(SYN)的处理方式的差异。在这里我们假设A向B发送的SYN数据包被B的防火墙丢弃了，但是B向A的Endpoint发送的SYN数据包可以正常抵达（即至少有一方可握手成功）。</p><h3 id="基于bsd的操作系统行为"><a class="markdownIt-Anchor" href="#基于bsd的操作系统行为"></a> 基于BSD的操作系统行为：</h3><p><img src="https://lsky.halc.top/oHhxGK.png" srcset="/img/loading.gif" lazyload alt="基于BSD的操作系统"></p><p>简单来说，A的网络程序接收到了B发来的SYN信号，这个信号的Endpoint对应了A之前试图发出去的信号回应。于是，A的网络部件就把这个新信号和它原来用来尝试联系B的那个通道（socket）联系起来了。这样一来，A尝试连接B的<code>connect()</code>就成功了，而且A用来等待别人的监听socket并没有被使用到。</p><h3 id="linux和windows系统的行为"><a class="markdownIt-Anchor" href="#linux和windows系统的行为"></a> Linux和Windows系统的行为：</h3><p><img src="https://lsky.halc.top/cd4KWj.png" srcset="/img/loading.gif" lazyload alt="Linux和Windows操作系统"></p><p>在打洞过程中，A收到了B发出的SYN信号。这个信号与A尝试向B发起的连接请求相对应，因此A的TCP实现决定将这个新的连接尝试与原本用于尝试连接B的<code>socket</code>关联起来。</p><p>接着，A通过向B发送SYN-ACK响应，继续常规的TCP连接建立流程。然而，因为A先前向B尝试发起的<code>connect()</code>操作使用了和新的<code>socket</code>相同的源和目标Endpoint，所以<code>connect()</code>操作最终会失败，而用于接受B传来的SYN的新建立的<code>socket</code>下的<code>accept()</code>方法则会成功。</p><h2 id="顺序打洞"><a class="markdownIt-Anchor" href="#顺序打洞"></a> 顺序打洞</h2><p>在一些老旧的Windows系统上，当双方想要进行通信的时候，打洞这个操作不一定是并行的，他有可能是一个顺序下来的步骤。</p><ol><li>A告诉S，它想和B通信，但A这边无法正常接受数据包。</li><li>然后B尝试通过<code>connect()</code>发送一个信号给A，希望通过S的帮助到达A。但因为A还没准备好，所以B的尝试失败了。</li><li>B告诉S，它完成了尝试，并开始准备通过<code>listen()</code>接收A的信号。</li><li>S告诉A，现在轮到你尝试直接联系B了。</li></ol><p>之所以有这种应用场景的需求，是因为在一些老旧的系统上并不能够并发的打开TCP连接，或<code>socket</code>接口没有实现<code>SO_REUSEADDR</code>的关键字。这种方法相对于并发连接来说速度会更慢一些，同时这种方法也需要与S服务器能够一直存在连接。而现在主流的操作系统在建立了P2P连接之后就不需要依赖于服务器S的连接了。</p><h1 id="当前nat网络现状"><a class="markdownIt-Anchor" href="#当前nat网络现状"></a> 当前NAT网络现状</h1><blockquote><p>以下部分内容来源于 GPT-4 的总结</p></blockquote><p>为了使上文提到的打洞技术能够顺利工作，NAT必须具备一些关键的行为特性。虽然不是所有现有的NAT都符合这些要求，但许多NAT已经做到了，并且随着NAT厂商逐渐认识到对点对点（P2P）协议的需求（例如IP语音和在线游戏），它们正变得更加友好于P2P网络。</p><p>这里并不旨在提供一个关于NAT应如何表现的完全或确定性的规范。我们只是提供一些信息，介绍哪些最常见的行为能够支持或阻碍P2P打洞。IETF已经启动了BEHAVE工作组，旨在为NAT行为定义官方的“最佳当前实践”。</p><p>关键特性包括：</p><ul><li><strong>一致的端点转换</strong>：NAT需要一致地将私有网络上的TCP或UDP源端点映射到一个单一的公共端点。这种NAT被称为圆锥NAT，它可以确保来自同一私有端点的所有会话通过NAT上的同一个公共端点传输。</li><li><strong>处理未请求的TCP连接</strong>：当NAT收到一个未经请求的SYN包时，它应该静默丢弃该包，而不是主动拒绝它。这样可以避免干扰TCP打洞过程。</li><li><strong>保持负载不变</strong>：一些NAT会“盲目”扫描数据包负载中的IP地址并进行转换，这种行为虽不常见，但应用程序可以通过对IP地址进行混淆来保护自己。</li><li><strong>Hairpin转换</strong>：在一些需要Hairpin转换支持的多级NAT场景中，当前NAT对此的支持很少，但随着IPv4地址空间的耗尽，支持Hairpin转换在未来NAT实现中变得重要。</li></ul><p>简而言之，为了支持P2P通信和打洞技术，NAT需要具备一些特定的行为特性，包括一致的端点转换、正确处理未请求的连接尝试、保持数据包负载不变，以及在需要时支持Hairpin转换。随着对P2P通信需求的增加，NAT技术也在逐步适应，以更好地支持这些应用。</p><p><strong>在英文原文中还有一些有关于如何衡量和测试NAT结构的方法，由于本文主要探究的是P2P打洞的技术实现，因此在这里就不做拓展了。后续如果遇到有关的技术问题则会在这里进行进一步的更新</strong></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" class="category-chain-item">知识记录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/DNS/" class="print-no-link">#DNS</a></div></div><div class="license-box my-3"><div class="license-title"><div>原理分析：UDP和TCP在NAT环境下的P2P打洞实现</div><div>https://halc.top/p/bb3a9deb</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>HalcyonAzure</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年1月31日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/p/d556ca0e" title="标准 Linux 启用 ZeroTier 局域网转发"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">标准 Linux 启用 ZeroTier 局域网转发</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/p/b9295ba3" title="镜像构建：Windows Cloud Image"><span class="hidden-mobile">镜像构建：Windows Cloud Image</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){var t=document.documentElement.getAttribute("data-user-color-scheme");t="dark"===t?"github-dark":"github-light",window.UtterancesThemeLight="github-light",window.UtterancesThemeDark="github-dark";var e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","HalcyonAzure/HalcyonAzure.github.io"),e.setAttribute("issue-term","title"),e.setAttribute("label","blog commit"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/DynamicLine.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>