<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-pic.png"><link rel="icon" href="/img/favicon-pic.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="HalcyonAzure"><meta name="keywords" content=""><meta name="description" content="TCP Sender  需要实现的主要逻辑  追踪Receiver返回的windows_size（可接受的剩余容量）和ackno（已经确认接收的字符位置） 只要数据来了就直接对数据进行封装并发送，只有在窗口被消耗为零的情况下才停止发送 将没有被acknowledge的数据包存储起来，在超时的时候进行发送   实现细节  对于超时重传的时间判断，使用已经提供的tick()函数，每次调用的时候传入多"><meta property="og:type" content="article"><meta property="og:title" content="CS144-Lab3 计算机网络：TCP Sender的实现"><meta property="og:url" content="https://halc.top/p/73e1b791"><meta property="og:site_name" content="Halcyon Zone"><meta property="og:description" content="TCP Sender  需要实现的主要逻辑  追踪Receiver返回的windows_size（可接受的剩余容量）和ackno（已经确认接收的字符位置） 只要数据来了就直接对数据进行封装并发送，只有在窗口被消耗为零的情况下才停止发送 将没有被acknowledge的数据包存储起来，在超时的时候进行发送   实现细节  对于超时重传的时间判断，使用已经提供的tick()函数，每次调用的时候传入多"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-12-03T08:31:47.000Z"><meta property="article:modified_time" content="2023-04-10T18:04:14.000Z"><meta property="article:author" content="HalcyonAzure"><meta property="article:tag" content="cs144"><meta property="article:tag" content="network"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><script async src="https://umami.azsyc.com/script.js" data-website-id="ab8bb282-3900-4ec9-a4dd-6076b4af581c"></script><title>CS144-Lab3 计算机网络：TCP Sender的实现 - Halcyon Zone</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/round.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"halc.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"c4f509f89fec4843f255dfb1ae66ca2b",google:null,tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!0},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null},gtag:null,woyaola:null,cnzz:null},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c4f509f89fec4843f255dfb1ae66ca2b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Halcyon Zone" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Halcyon</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="CS144-Lab3 计算机网络：TCP Sender的实现"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-03 16:31" pubdate>2022年12月3日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>2.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>23 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">CS144-Lab3 计算机网络：TCP Sender的实现</h1><p id="updated-time" class="note note-info">本文最后更新于：2023年4月11日 凌晨</p><div class="markdown-body"><h2 id="tcp-sender"><a class="markdownIt-Anchor" href="#tcp-sender"></a> TCP Sender</h2><h3 id="需要实现的主要逻辑"><a class="markdownIt-Anchor" href="#需要实现的主要逻辑"></a> 需要实现的主要逻辑</h3><ol><li>追踪<code>Receiver</code>返回的<code>windows_size</code>（可接受的剩余容量）和<code>ackno</code>（已经确认接收的字符位置）</li><li>只要数据来了就直接对数据进行封装并发送，只有在窗口被消耗为零的情况下才停止发送</li><li>将没有被<code>acknowledge</code>的数据包存储起来，在超时的时候进行发送</li></ol><h3 id="实现细节"><a class="markdownIt-Anchor" href="#实现细节"></a> 实现细节</h3><ol><li>对于超时重传的时间判断，使用已经提供的<code>tick()</code>函数，每次调用的时候传入多少时间就消耗了多少时间</li><li>超时重传的默认基准值会以成员变量的形式在<code>TCPSender</code>中进行初始化</li><li>在<code>TCPSegment</code>中有一个<code>_segments_out</code>的成员，只需要向这个<code>queue</code>内<code>push</code>一个<code>TCPSegment</code>就相当于将这个数据段发送了</li></ol><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><h4 id="额外定义成员"><a class="markdownIt-Anchor" href="#额外定义成员"></a> 额外定义成员</h4><p>对于计时器的部分，为了方便抽象管理，我这里选择直接创建一个类来进行封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPTimer</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> _tick_passed = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录实时的时间戳</span><br>    <span class="hljs-type">size_t</span> _rto_timeout = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录超过多久时间没有收到ACK就重传</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _rto_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录重传的次数</span><br><br>    <span class="hljs-type">bool</span> _is_running&#123;<span class="hljs-literal">false</span>&#125;;  <span class="hljs-comment">// 记录计时器是否启动</span><br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重置计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> retx_timeout)</span> </span>&#123;<br>        _rto_count = <span class="hljs-number">0</span>;<br>        _rto_timeout = retx_timeout;<br>        _tick_passed = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 启动计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; _is_running = <span class="hljs-literal">true</span>; &#125;<br><br>    <span class="hljs-comment">// 暂停计时器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123; _is_running = <span class="hljs-literal">false</span>; &#125;<br><br>    <span class="hljs-comment">// 计时器是否启动</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_running</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_running; &#125;<br><br>    <span class="hljs-comment">// 重传次数</span><br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">rto_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _rto_count; &#125;<br><br>    <span class="hljs-comment">// 慢启动</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_start</span><span class="hljs-params">()</span> </span>&#123;<br>        _rto_count++;<br>        _rto_timeout *= <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新当前时间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123; _tick_passed += ms_since_last_tick; &#125;<br><br>    <span class="hljs-comment">// 检测是否超时</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_timeout</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_running &amp;&amp; _tick_passed &gt;= _rto_timeout; &#125;<br><br>    <span class="hljs-comment">// 重新计时</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restart</span><span class="hljs-params">()</span> </span>&#123; _tick_passed = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>private</code>的部分定义则如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 超时重传计时器</span><br>TCPTimer _rto_timer&#123;&#125;;<br><br><span class="hljs-comment">// 记录确认的_ackno</span><br><span class="hljs-type">size_t</span> _ackno = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 记录窗口大小，并标记是否为空窗口</span><br><span class="hljs-type">size_t</span> _window_size = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 缓存队列</span><br>std::queue&lt;TCPSegment&gt; _cache&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="额外定义函数"><a class="markdownIt-Anchor" href="#额外定义函数"></a> 额外定义函数</h4><p>额外定义的函数主要作用为将已经封装好的<code>TCP</code>报文进行发送，如果在发送的时候检测到<code>RTO</code>重传计时器并没有工作，则发送的同时激活重传计时器。同时在发送了报文后对seqno序号进行消耗，移动<code>_next_seqno</code>指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> TCPSender::_send_segment(<span class="hljs-type">const</span> TCPSegment &amp;seg) &#123;<br>    <span class="hljs-comment">// 当前报文需要占用的长度</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> seg_len = seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    _next_seqno += seg_len;<br>    _cache.<span class="hljs-built_in">push</span>(seg);<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    <span class="hljs-comment">// 如果没启动计时器，就启动计时器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> _rto_timer.<span class="hljs-built_in">is_running</span>()) &#123;<br>        _rto_timer.<span class="hljs-built_in">run</span>();<br>        _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fill_window"><a class="markdownIt-Anchor" href="#fill_window"></a> fill_window()</h4><p>对于需要封装的报文，大致可以分为三类，一类是最开始用于建立连接的<code>SYN</code>报文，一类是携带数据的<code>PAYLOAD</code>报文，最后一类是用于发送结束连接的挥手<code>FIN</code>报文。在该方法中主要的难点就是通过对目前已经确认的<code>ackno</code>和<code>next_seqno</code>等数据来判断当前需要封装的报文具体是哪一类，以及根据还未接收到的数据以及零窗口本身的机制来判断空闲的窗口大小</p><h5 id="fill_space窗口大小"><a class="markdownIt-Anchor" href="#fill_space窗口大小"></a> fill_space窗口大小</h5><p>首先，为了防止出现对方当前空闲窗口已满，而sender就一直啥也不发的情况出现，因此在接受到的窗口大小是0的时候，要将其改为1，来避免零窗口堵塞。同时由于部分数据还在传输的路上，这一部分的数据也需要被减掉，从而得到最后的空闲大小fill_space。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> fill_space = _window_size ? _window_size : <span class="hljs-number">1</span>;<br>fill_space -= <span class="hljs-built_in">bytes_in_flight</span>();<br></code></pre></td></tr></table></figure><h5 id="syn报文"><a class="markdownIt-Anchor" href="#syn报文"></a> SYN报文</h5><p><code>SYN</code>报文的判断很简单，因为发送<code>SYN</code>的话无非是打开连接的建立者A自己，又或者是收到了A发来报文的B返回一个携带<code>ACK</code>的<code>SYN</code>报文进行确认。而对于A和B来说，由于<code>SYN</code>报文都是他们自己发送的第一个报文，因此在封装的过程中，他们的“下一个发送序列号”<code>_next_seqno</code>显而易见的应该为零。大致逻辑代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// _next_seqno == 0 代表还没有开始发送数据，此时需要发送SYN报文</span><br>section.<span class="hljs-built_in">header</span>().syn = (_next_seqno == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h5 id="payload报文"><a class="markdownIt-Anchor" href="#payload报文"></a> PAYLOAD报文</h5><p>对于含有内容的报文，主要的工作就是对<code>payload</code>长度的合理切割，对此只需要在<code>TCPConfig::MAX_PAYLOAD_SIZE</code>和当前剩余``中取最小值并从<code>_stream</code>当中读入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将数据进行封装</span><br><span class="hljs-type">size_t</span> segment_payload_size = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, fill_space);<br>section.<span class="hljs-built_in">payload</span>() = _stream.<span class="hljs-built_in">read</span>(segment_payload_size);<br></code></pre></td></tr></table></figure><h5 id="fin报文"><a class="markdownIt-Anchor" href="#fin报文"></a> FIN报文</h5><p>在<code>_stream</code>发送完毕，并且被我方全部接受了的时候发送一个携带<code>FIN</code>的报文，告知对方我方已经发送完毕。由于<code>FIN</code>本身需要消耗一个序列号，因此发送前需检查当前数据段是否还有一个空位来放FIN</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果要发送FIN的话，窗口内至少还要剩余一个字符(bytes_in_flight的也会占用窗口)</span><br><span class="hljs-keyword">if</span> (_stream.<span class="hljs-built_in">eof</span>() &amp;&amp; fill_space &gt; section.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>    section.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="发送过滤"><a class="markdownIt-Anchor" href="#发送过滤"></a> 发送过滤</h5><p>在标记完了<code>FIN</code>之后，如果这个报文依旧不占用序列号，则说明这个报文不是<code>TCP Sender</code>处理的部分；又或者此时在<code>FIN</code>已经发送的基础上，重复发送了一个<code>FIN</code>，这时多的<code>FIN</code>应该被抛弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空字符报的报文或错误溢出的报文不应该由`TCP Sender`进行发送</span><br><span class="hljs-keyword">if</span> (section.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span> || _next_seqno == _stream.<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><details><summary>最后总的代码如下</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> fill_space = _window_size ? _window_size : <span class="hljs-number">1</span>;<br>    fill_space -= <span class="hljs-built_in">bytes_in_flight</span>();<br>    <span class="hljs-keyword">while</span> (fill_space &gt; <span class="hljs-number">0</span>) &#123;<br>        TCPSegment section;<br><br>        <span class="hljs-comment">// 发送的数据包的序号是将要写入的下一个序号</span><br>        section.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">next_seqno</span>();<br><br>        <span class="hljs-comment">// _next_seqno == 0 代表还没有开始发送数据，此时需要发送SYN报文</span><br>        section.<span class="hljs-built_in">header</span>().syn = (_next_seqno == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 将数据进行封装</span><br>        <span class="hljs-type">size_t</span> segment_payload_size = <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, fill_space);<br>        section.<span class="hljs-built_in">payload</span>() = _stream.<span class="hljs-built_in">read</span>(segment_payload_size);<br><br>        <span class="hljs-comment">// 空闲窗口中至少要留有一位序号的位置才能将当前数据包添加FIN(bytes_in_flight的也会占用窗口)</span><br>        <span class="hljs-keyword">if</span> (_stream.<span class="hljs-built_in">eof</span>() &amp;&amp; fill_space &gt; section.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>            section.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果这个报文啥都没有，或者FIN报文已经发送了，就没必要发送新的数据段了</span><br>        <span class="hljs-keyword">if</span> (section.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span> || _next_seqno == _stream.<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        fill_space -= section.<span class="hljs-built_in">length_in_sequence_space</span>();<br><br>        _send_segment(section);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="bytes_in_flight"><a class="markdownIt-Anchor" href="#bytes_in_flight"></a> bytes_in_flight()</h4><p>这个感觉可能是看起来最简单的一个函数了，因为用了<code>_ackno</code>来记录已经确认过的报文，同时<code>_next_seqno</code>又代表的是将要发送的数据流位置，因此只需要将<code>_next_seqno - _ackno</code>返回的就是正在发送中的数据长度了。（最开始想实现的时候还在考虑要不要在每次<code>fill_window</code>和<code>ack_received</code>的时候添加计数器。。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _next_seqno - _ackno; &#125;<br></code></pre></td></tr></table></figure><h4 id="ack_received"><a class="markdownIt-Anchor" href="#ack_received"></a> ack_received()</h4><p>确认报文主要需要的逻辑有以下四个部分：</p><ol><li>只处理有效并且正确的<code>ackno</code>。如果<code>ackno</code>有效，记录<code>ackno</code>和<code>window_size</code>用以<code>fill_window()</code>来进行报文的封装</li><li>记录ack报文中包含的窗口大小</li><li>如果曾经的报文已经确认过，则报文已经送达，将送达的报文从缓冲区中弹出，如果所有的报文都被弹出了，则关闭RTO计时器</li><li>如果接受到了对方这时的窗口又有了空闲大小，则使用<code>fill_window()</code>来填充新的空报文</li></ol><h5 id="对于第一个逻辑"><a class="markdownIt-Anchor" href="#对于第一个逻辑"></a> 对于第一个逻辑</h5><p>对于判断<code>ackno</code>是否是正确的<code>ackno</code>,只需要判断<code>ackno</code>是否处于已经记录的<code>_ackno</code>和<code>_next_seqno</code>之间，如果在这个区间之外，意味着要么是老的<code>ackno</code>，要么是确认了不存在的数据，需要进行短路丢弃，逻辑如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span> abs_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _next_seqno);<br><span class="hljs-comment">// 如果接收到对方发送的确认序号大于自己的下一个序号或者小于自己的已经被确认序号，说明接收到的确认序号是错误的</span><br><span class="hljs-keyword">if</span> (abs_ackno &lt; _ackno || abs_ackno &gt; _next_seqno) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对于第二个逻辑"><a class="markdownIt-Anchor" href="#对于第二个逻辑"></a> 对于第二个逻辑</h5><p>在接受到了窗口大小之后只需要直接将其记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 记录窗口大小</span><br>_window_size = window_size;<br></code></pre></td></tr></table></figure><h5 id="对于第三-四个逻辑"><a class="markdownIt-Anchor" href="#对于第三-四个逻辑"></a> 对于第三、四个逻辑</h5><p>这部分都是属于对于超时重传的处理，其中主要需要实现的是对缓冲区确认后的报文进行弹出，同时弹出所有报文后取消对<code>RTO</code>的占用，初始化超时重传的等待时间并记录当前的时间。</p><p>其中弹出操作只有在<code>_ackno</code>确认的是第一个报文对应的<code>seqno</code>和<code>length</code>的时候才进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用于判断是否重置计时器</span><br><span class="hljs-type">bool</span> has_reset = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 当缓冲区内的报文已经被ackno确认，则将已经确认的报文进行丢弃</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> _cache.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>       _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno.<span class="hljs-built_in">raw_value</span>() + _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= ackno.<span class="hljs-built_in">raw_value</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> has_reset) &#123;<br>        <span class="hljs-comment">// 有效的确认报文到达，重置计时器</span><br>        _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>        has_reset = <span class="hljs-literal">true</span>;<br>    &#125;<br>    _cache.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-comment">// 所有数据包都被确认了，所以暂停计时器</span><br>    _rto_timer.<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果剩余的窗口还有空间，就填入内容</span><br><span class="hljs-built_in">fill_window</span>();<br></code></pre></td></tr></table></figure><details><summary>最后总的代码如下</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="hljs-comment">//! \param window_size The remote receiver&#x27;s advertised window size</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-type">const</span> WrappingInt32 ackno, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-type">uint64_t</span> abs_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _next_seqno);<br>    <span class="hljs-comment">// 如果接收到对方发送的确认序号大于自己的下一个序号或者小于自己的已经被确认序号，说明接收到的确认序号是错误的</span><br>    <span class="hljs-keyword">if</span> (abs_ackno &lt; _ackno || abs_ackno &gt; _next_seqno) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _ackno = abs_ackno;<br><br>    <span class="hljs-comment">// 记录窗口大小</span><br>    _window_size = window_size;<br><br>    <span class="hljs-comment">// 用于判断是否重置计时器</span><br>    <span class="hljs-type">bool</span> has_reset = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 当缓冲区内的报文已经被ackno确认，则将已经确认的报文进行丢弃</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> _cache.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>           _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">header</span>().seqno.<span class="hljs-built_in">raw_value</span>() + _cache.<span class="hljs-built_in">front</span>().<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= ackno.<span class="hljs-built_in">raw_value</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> has_reset) &#123;<br>            <span class="hljs-comment">// 有效的确认报文到达，重置计时器</span><br>            _rto_timer.<span class="hljs-built_in">reset</span>(_initial_retransmission_timeout);<br>            has_reset = <span class="hljs-literal">true</span>;<br>        &#125;<br>        _cache.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_cache.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 所有数据包都被确认了，所以暂停计时器</span><br>        _rto_timer.<span class="hljs-built_in">stop</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果剩余的窗口还有空间，就填入内容</span><br>    <span class="hljs-built_in">fill_window</span>();<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="tick"><a class="markdownIt-Anchor" href="#tick"></a> tick()</h4><p>该函数主要的作用是推动时间流动，并且判断是否触发超时重传，如果触发了超时重传首先将计时器更新到当前时间。然后当对方窗口不繁忙的情况下（window_size非零）触发了重传就把下次重传的等待时间翻倍，并且记录一次重连；如果对方窗口正处于繁忙期（window_size为零），则不翻倍连接时间。然后再将缓冲区内第一个发送的报文进行重新发送。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    <span class="hljs-comment">// 更新当前时间</span><br>    _rto_timer.<span class="hljs-built_in">update</span>(ms_since_last_tick);<br><br>    <span class="hljs-comment">// 检测是否超时</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">not</span> _rto_timer.<span class="hljs-built_in">is_timeout</span>())) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果上一个收到的报文中，窗口大小不是零，但是依旧超时，说明是网络堵塞，执行慢启动</span><br>    <span class="hljs-keyword">if</span> (_window_size != <span class="hljs-number">0</span>) &#123;<br>        _rto_timer.<span class="hljs-built_in">slow_start</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 重传次数小于最大重传次数，就重传</span><br>    <span class="hljs-keyword">if</span> (_rto_timer.<span class="hljs-built_in">rto_count</span>() &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123;<br>        <span class="hljs-comment">// 发送缓冲区中的第一个报文段</span><br>        _segments_out.<span class="hljs-built_in">push</span>(_cache.<span class="hljs-built_in">front</span>());<br>        _rto_timer.<span class="hljs-built_in">restart</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="consecutive_retransmissions"><a class="markdownIt-Anchor" href="#consecutive_retransmissions"></a> consecutive_retransmissions()</h4><p>这个函数就是直接返回次数的，直接返回<code>_rto_timer.rto_count();</code>的大小即可。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" class="category-chain-item">知识记录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/cs144/" class="print-no-link">#cs144</a> <a href="/tags/network/" class="print-no-link">#network</a></div></div><div class="license-box my-3"><div class="license-title"><div>CS144-Lab3 计算机网络：TCP Sender的实现</div><div>https://halc.top/p/73e1b791</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>HalcyonAzure</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年12月3日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/p/4457ea2b" title="使用Yadm管理Linux配置文件"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">使用Yadm管理Linux配置文件</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/p/4e68707" title="CS144-Lab2 计算机网络：TCP Receiver的实现"><span class="hidden-mobile">CS144-Lab2 计算机网络：TCP Receiver的实现</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){var t=document.documentElement.getAttribute("data-user-color-scheme");t="dark"===t?"github-dark":"github-light",window.UtterancesThemeLight="github-light",window.UtterancesThemeDark="github-dark";var e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","HalcyonAzure/HalcyonAzure.github.io"),e.setAttribute("issue-term","title"),e.setAttribute("label","blog commit"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/DynamicLine.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>